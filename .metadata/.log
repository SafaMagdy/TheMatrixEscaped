!SESSION 2021-10-24 20:27:02.024 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=16.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-24 20:27:18.797
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-24 20:27:18.797
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2b62475a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4990b335,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-24 20:27:22.493
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\safam'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-10-28 18:34:58.535 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=16.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-28 18:35:14.746
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-28 18:35:14.746
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5d74507c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2a984952,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-28 18:35:17.002
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\safam'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jface 4 2 2021-10-28 20:19:13.459
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jface".
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.jdt.core.dom.ASTNode.getParent()" because "node" is null
	at org.eclipse.jdt.internal.corext.dom.ASTNodes.getParent(ASTNodes.java:2474)
	at org.eclipse.jdt.internal.corext.refactoring.structure.ASTNodeSearchUtil.getMethodDeclarationNode(ASTNodeSearchUtil.java:129)
	at org.eclipse.jdt.internal.corext.refactoring.RefactoringAvailabilityTester.isCanonicalConstructor(RefactoringAvailabilityTester.java:208)
	at org.eclipse.jdt.internal.corext.refactoring.RefactoringAvailabilityTester.isIntroduceParameterObjectAvailable(RefactoringAvailabilityTester.java:1250)
	at org.eclipse.jdt.internal.ui.actions.IntroduceParameterObjectAction.selectionChanged(IntroduceParameterObjectAction.java:74)
	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.dispatchSelectionChanged(SelectionDispatchAction.java:262)
	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.selectionChanged(SelectionDispatchAction.java:257)
	at org.eclipse.jface.viewers.Viewer$1.run(Viewer.java:151)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:174)
	at org.eclipse.jface.viewers.Viewer.fireSelectionChanged(Viewer.java:148)
	at org.eclipse.jface.viewers.StructuredViewer.updateSelection(StructuredViewer.java:2132)
	at org.eclipse.jface.viewers.StructuredViewer.setSelection(StructuredViewer.java:1662)
	at org.eclipse.jface.viewers.TreeViewer.setSelection(TreeViewer.java:1084)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaOutlinePage.select(JavaOutlinePage.java:1127)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.synchronizeOutlinePage(JavaEditor.java:2153)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.synchronizeOutlinePage(JavaEditor.java:2141)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.selectionChanged(JavaEditor.java:2248)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:78)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:654)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1462)

!ENTRY org.eclipse.jdt.ui 4 10001 2021-10-28 21:34:56.786
!MESSAGE Internal Error
!STACK 1
Java Model Exception: Java Model Status [whatInCell(int, int) [in TreeNode [in [Working copy] TreeNode.java [in code [in src [in AI]]]]] does not exist]
	at org.eclipse.jdt.internal.core.JavaElement.newNotPresentException(JavaElement.java:574)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:617)
	at org.eclipse.jdt.internal.core.JavaElement.getElementInfo(JavaElement.java:327)
	at org.eclipse.jdt.internal.core.JavaElement.getElementInfo(JavaElement.java:313)
	at org.eclipse.jdt.internal.core.SourceRefElement.getSourceRange(SourceRefElement.java:233)
	at org.eclipse.jdt.internal.core.Member.getJavadocRange(Member.java:301)
	at org.eclipse.jdt.internal.ui.text.javadoc.JavadocContentAccess2.getHTMLContentFromSource(JavadocContentAccess2.java:639)
	at org.eclipse.jdt.internal.ui.text.javadoc.JavadocContentAccess2.getHTMLContent(JavadocContentAccess2.java:515)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:748)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)
!SUBENTRY 1 org.eclipse.jdt.core 4 969 2021-10-28 21:34:56.786
!MESSAGE whatInCell(int, int) [in TreeNode [in [Working copy] TreeNode.java [in code [in src [in AI]]]]] does not exist
!SESSION 2021-11-03 14:07:32.288 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=16.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-03 14:07:45.144
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-03 14:07:45.144
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6b86826a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3c2dda7c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-03 14:07:48.486
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\safam'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2021-11-03 17:28:37.685
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package code;
import java.util.ArrayList;

import code.Location;

public class TreeNode {
	
	//list for tracking the previous cells visited to avoid repeated states
	public ArrayList<Location> prevCells;
	//current node location
	public Location myLoc;
	//number of current alive hostages
	public int hostagesNum;
	//number of mutant hostages that must be killed
	public int mutantHostagesNum;
	//track of neo's health/damage
	public int neoHealth;
	//the updated string according to the path that led to the current node
	public String grid;
	
	public TreeNode(ArrayList<Location> prevCells, Location myLoc, int hNum, int mHNum, int neoH, String grid) {
		
		this.prevCells = prevCells;
		this.myLoc = myLoc;
		this.hostagesNum = hNum;
		this.mutantHostagesNum = mHNum;
		this.neoHealth = neoH;
		this.grid = grid;		
		
	}
	
	//method to print the content of any array
	public static void printArr (String[] arr)
	{
		for ( int i = 0 ; i < arr.length; i++) {
			System.out.print(arr[i]);
		}
		System.out.println(" ");
	}
	
	// we need to add the locations of mutant hostages in the grid
	// or implement a method that checks the damage of all hostages
	
	//return array of important values like name of the object
	//for example hostage and health
	//pad and locations
	
	
	//method to get the content of the given cell
	//can be used to determine the surroundings of the current cell 
	public static String whatInCell(int x, int y, String grid) {
		String result = "";
		//split the grid at ; to extract different categories in the grid
		String[] splitted = grid.split(";");
		//array that consists of (x,y) of the telephone booth
		String[] telephone = splitted[3].split(",");
		//array that contains locations of all the agents
		String[] agents = splitted[4].split(",");
		//array that contains locations of all pills
		String[] pills = splitted[5].split(",");
		//array that contains locations of all the pads
		//this array is always divisible by 4 since the pad comes in pairs
		//(startx, starty, finishx, finishy)
		String[] pads = splitted[6].split(",");
		//array that contains locations of all the hostages
		String[] hostages = splitted[7].split(",");
		
		if(x == Integer.parseInt(telephone[0]) && y == Integer.parseInt(telephone[1])) {
			result = "telephone;" + x + ";" + y;
			return result;
		}
		for (int i = 0 ; i < agents.length-1; i+=2) {
			if(x == Integer.parseInt(agents[i]) && y == Integer.parseInt(agents[i+1])) {
				result = "agent;" + x + ";" + y;
				return result;
			}
		}
		for (int i = 0 ; i < pills.length-1; i+=2) {
			if(x == Integer.parseInt(pills[i]) && y == Integer.parseInt(pills[i+1])) {
				result = "pill;" + x + ";" + y;
				return result;
			}
		}
		for (int i = 0 ; i < pads.length-1; i+=2) {
			if(x == Integer.parseInt(pads[i]) && y == Integer.parseInt(pads[i+1])) {
				result = "pad;" + x + ";" + y;
				i/2
				//return pair of pads attached together
				return result;
			}
		}
		for (int i = 0 ; i < hostages.length-1; i+=3) {
			System.out.println(hostages[i]);
			if(x == Integer.parseInt(hostages[i]) && y == Integer.parseInt(hostages[i+1])) {
				result = "hostage";
				return result;
			}
		}
		
		return result;
	}
	
	public static void main(String[] args) {
		
		System.out.println(whatInCell(1,2, "3,3;1;0,0;1,1;0,1;1,2;0,2,2,0;1,0,0,2,1,50,2,2,90"));
	}
	
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2991)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:494)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-11-03 17:28:37.689
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2991)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:494)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-11-03 17:28:37.690
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2991)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:494)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-11-03 17:28:37.699
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package code;
import java.util.ArrayList;

import code.Location;

public class TreeNode {
	
	//list for tracking the previous cells visited to avoid repeated states
	public ArrayList<Location> prevCells;
	//current node location
	public Location myLoc;
	//number of current alive hostages
	public int hostagesNum;
	//number of mutant hostages that must be killed
	public int mutantHostagesNum;
	//track of neo's health/damage
	public int neoHealth;
	//the updated string according to the path that led to the current node
	public String grid;
	
	public TreeNode(ArrayList<Location> prevCells, Location myLoc, int hNum, int mHNum, int neoH, String grid) {
		
		this.prevCells = prevCells;
		this.myLoc = myLoc;
		this.hostagesNum = hNum;
		this.mutantHostagesNum = mHNum;
		this.neoHealth = neoH;
		this.grid = grid;		
		
	}
	
	//method to print the content of any array
	public static void printArr (String[] arr)
	{
		for ( int i = 0 ; i < arr.length; i++) {
			System.out.print(arr[i]);
		}
		System.out.println(" ");
	}
	
	// we need to add the locations of mutant hostages in the grid
	// or implement a method that checks the damage of all hostages
	
	//return array of important values like name of the object
	//for example hostage and health
	//pad and locations
	
	
	//method to get the content of the given cell
	//can be used to determine the surroundings of the current cell 
	public static String whatInCell(int x, int y, String grid) {
		String result = "";
		//split the grid at ; to extract different categories in the grid
		String[] splitted = grid.split(";");
		//array that consists of (x,y) of the telephone booth
		String[] telephone = splitted[3].split(",");
		//array that contains locations of all the agents
		String[] agents = splitted[4].split(",");
		//array that contains locations of all pills
		String[] pills = splitted[5].split(",");
		//array that contains locations of all the pads
		//this array is always divisible by 4 since the pad comes in pairs
		//(startx, starty, finishx, finishy)
		String[] pads = splitted[6].split(",");
		//array that contains locations of all the hostages
		String[] hostages = splitted[7].split(",");
		
		if(x == Integer.parseInt(telephone[0]) && y == Integer.parseInt(telephone[1])) {
			result = "telephone;" + x + ";" + y;
			return result;
		}
		for (int i = 0 ; i < agents.length-1; i+=2) {
			if(x == Integer.parseInt(agents[i]) && y == Integer.parseInt(agents[i+1])) {
				result = "agent;" + x + ";" + y;
				return result;
			}
		}
		for (int i = 0 ; i < pills.length-1; i+=2) {
			if(x == Integer.parseInt(pills[i]) && y == Integer.parseInt(pills[i+1])) {
				result = "pill;" + x + ";" + y;
				return result;
			}
		}
		for (int i = 0 ; i < pads.length-1; i+=2) {
			if(x == Integer.parseInt(pads[i]) && y == Integer.parseInt(pads[i+1])) {
				result = "pad;" + x + ";" + y;
				i/2
				//return pair of pads attached together
				return result;
			}
		}
		for (int i = 0 ; i < hostages.length-1; i+=3) {
			System.out.println(hostages[i]);
			if(x == Integer.parseInt(hostages[i]) && y == Integer.parseInt(hostages[i+1])) {
				result = "hostage";
				return result;
			}
		}
		
		return result;
	}
	
	public static void main(String[] args) {
		
		System.out.println(whatInCell(1,2, "3,3;1;0,0;1,1;0,1;1,2;0,2,2,0;1,0,0,2,1,50,2,2,90"));
	}
	
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2991)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-11-03 17:28:37.700
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2991)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-11-03 17:28:37.700
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2991)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-11-03 17:28:40.710
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package code;
import java.util.ArrayList;

import code.Location;

public class TreeNode {
	
	//list for tracking the previous cells visited to avoid repeated states
	public ArrayList<Location> prevCells;
	//current node location
	public Location myLoc;
	//number of current alive hostages
	public int hostagesNum;
	//number of mutant hostages that must be killed
	public int mutantHostagesNum;
	//track of neo's health/damage
	public int neoHealth;
	//the updated string according to the path that led to the current node
	public String grid;
	
	public TreeNode(ArrayList<Location> prevCells, Location myLoc, int hNum, int mHNum, int neoH, String grid) {
		
		this.prevCells = prevCells;
		this.myLoc = myLoc;
		this.hostagesNum = hNum;
		this.mutantHostagesNum = mHNum;
		this.neoHealth = neoH;
		this.grid = grid;		
		
	}
	
	//method to print the content of any array
	public static void printArr (String[] arr)
	{
		for ( int i = 0 ; i < arr.length; i++) {
			System.out.print(arr[i]);
		}
		System.out.println(" ");
	}
	
	// we need to add the locations of mutant hostages in the grid
	// or implement a method that checks the damage of all hostages
	
	//return array of important values like name of the object
	//for example hostage and health
	//pad and locations
	
	
	//method to get the content of the given cell
	//can be used to determine the surroundings of the current cell 
	public static String whatInCell(int x, int y, String grid) {
		String result = "";
		//split the grid at ; to extract different categories in the grid
		String[] splitted = grid.split(";");
		//array that consists of (x,y) of the telephone booth
		String[] telephone = splitted[3].split(",");
		//array that contains locations of all the agents
		String[] agents = splitted[4].split(",");
		//array that contains locations of all pills
		String[] pills = splitted[5].split(",");
		//array that contains locations of all the pads
		//this array is always divisible by 4 since the pad comes in pairs
		//(startx, starty, finishx, finishy)
		String[] pads = splitted[6].split(",");
		//array that contains locations of all the hostages
		String[] hostages = splitted[7].split(",");
		
		if(x == Integer.parseInt(telephone[0]) && y == Integer.parseInt(telephone[1])) {
			result = "telephone;" + x + ";" + y;
			return result;
		}
		for (int i = 0 ; i < agents.length-1; i+=2) {
			if(x == Integer.parseInt(agents[i]) && y == Integer.parseInt(agents[i+1])) {
				result = "agent;" + x + ";" + y;
				return result;
			}
		}
		for (int i = 0 ; i < pills.length-1; i+=2) {
			if(x == Integer.parseInt(pills[i]) && y == Integer.parseInt(pills[i+1])) {
				result = "pill;" + x + ";" + y;
				return result;
			}
		}
		for (int i = 0 ; i < pads.length-1; i+=2) {
			if(x == Integer.parseInt(pads[i]) && y == Integer.parseInt(pads[i+1])) {
				result = "pad;" + x + ";" + y;
				i/2
				//return pair of pads attached together
				return result;
			}
		}
		for (int i = 0 ; i < hostages.length-1; i+=3) {
			System.out.println(hostages[i]);
			if(x == Integer.parseInt(hostages[i]) && y == Integer.parseInt(hostages[i+1])) {
				result = "hostage";
				return result;
			}
		}
		
		return result;
	}
	
	public static void main(String[] args) {
		
		System.out.println(whatInCell(1,2, "3,3;1;0,0;1,1;0,1;1,2;0,2,2,0;1,0,0,2,1,50,2,2,90"));
	}
	
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2991)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:494)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-11-03 17:28:40.711
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2991)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:494)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-11-03 17:28:40.711
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2991)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:494)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-11-03 17:28:40.719
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package code;
import java.util.ArrayList;

import code.Location;

public class TreeNode {
	
	//list for tracking the previous cells visited to avoid repeated states
	public ArrayList<Location> prevCells;
	//current node location
	public Location myLoc;
	//number of current alive hostages
	public int hostagesNum;
	//number of mutant hostages that must be killed
	public int mutantHostagesNum;
	//track of neo's health/damage
	public int neoHealth;
	//the updated string according to the path that led to the current node
	public String grid;
	
	public TreeNode(ArrayList<Location> prevCells, Location myLoc, int hNum, int mHNum, int neoH, String grid) {
		
		this.prevCells = prevCells;
		this.myLoc = myLoc;
		this.hostagesNum = hNum;
		this.mutantHostagesNum = mHNum;
		this.neoHealth = neoH;
		this.grid = grid;		
		
	}
	
	//method to print the content of any array
	public static void printArr (String[] arr)
	{
		for ( int i = 0 ; i < arr.length; i++) {
			System.out.print(arr[i]);
		}
		System.out.println(" ");
	}
	
	// we need to add the locations of mutant hostages in the grid
	// or implement a method that checks the damage of all hostages
	
	//return array of important values like name of the object
	//for example hostage and health
	//pad and locations
	
	
	//method to get the content of the given cell
	//can be used to determine the surroundings of the current cell 
	public static String whatInCell(int x, int y, String grid) {
		String result = "";
		//split the grid at ; to extract different categories in the grid
		String[] splitted = grid.split(";");
		//array that consists of (x,y) of the telephone booth
		String[] telephone = splitted[3].split(",");
		//array that contains locations of all the agents
		String[] agents = splitted[4].split(",");
		//array that contains locations of all pills
		String[] pills = splitted[5].split(",");
		//array that contains locations of all the pads
		//this array is always divisible by 4 since the pad comes in pairs
		//(startx, starty, finishx, finishy)
		String[] pads = splitted[6].split(",");
		//array that contains locations of all the hostages
		String[] hostages = splitted[7].split(",");
		
		if(x == Integer.parseInt(telephone[0]) && y == Integer.parseInt(telephone[1])) {
			result = "telephone;" + x + ";" + y;
			return result;
		}
		for (int i = 0 ; i < agents.length-1; i+=2) {
			if(x == Integer.parseInt(agents[i]) && y == Integer.parseInt(agents[i+1])) {
				result = "agent;" + x + ";" + y;
				return result;
			}
		}
		for (int i = 0 ; i < pills.length-1; i+=2) {
			if(x == Integer.parseInt(pills[i]) && y == Integer.parseInt(pills[i+1])) {
				result = "pill;" + x + ";" + y;
				return result;
			}
		}
		for (int i = 0 ; i < pads.length-1; i+=2) {
			if(x == Integer.parseInt(pads[i]) && y == Integer.parseInt(pads[i+1])) {
				result = "pad;" + x + ";" + y;
				i/2
				//return pair of pads attached together
				return result;
			}
		}
		for (int i = 0 ; i < hostages.length-1; i+=3) {
			System.out.println(hostages[i]);
			if(x == Integer.parseInt(hostages[i]) && y == Integer.parseInt(hostages[i+1])) {
				result = "hostage";
				return result;
			}
		}
		
		return result;
	}
	
	public static void main(String[] args) {
		
		System.out.println(whatInCell(1,2, "3,3;1;0,0;1,1;0,1;1,2;0,2,2,0;1,0,0,2,1,50,2,2,90"));
	}
	
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2991)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-11-03 17:28:40.719
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2991)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-11-03 17:28:40.720
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2991)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-11-03 17:28:48.471
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package code;
import java.util.ArrayList;

import code.Location;

public class TreeNode {
	
	//list for tracking the previous cells visited to avoid repeated states
	public ArrayList<Location> prevCells;
	//current node location
	public Location myLoc;
	//number of current alive hostages
	public int hostagesNum;
	//number of mutant hostages that must be killed
	public int mutantHostagesNum;
	//track of neo's health/damage
	public int neoHealth;
	//the updated string according to the path that led to the current node
	public String grid;
	
	public TreeNode(ArrayList<Location> prevCells, Location myLoc, int hNum, int mHNum, int neoH, String grid) {
		
		this.prevCells = prevCells;
		this.myLoc = myLoc;
		this.hostagesNum = hNum;
		this.mutantHostagesNum = mHNum;
		this.neoHealth = neoH;
		this.grid = grid;		
		
	}
	
	//method to print the content of any array
	public static void printArr (String[] arr)
	{
		for ( int i = 0 ; i < arr.length; i++) {
			System.out.print(arr[i]);
		}
		System.out.println(" ");
	}
	
	// we need to add the locations of mutant hostages in the grid
	// or implement a method that checks the damage of all hostages
	
	//return array of important values like name of the object
	//for example hostage and health
	//pad and locations
	
	
	//method to get the content of the given cell
	//can be used to determine the surroundings of the current cell 
	public static String whatInCell(int x, int y, String grid) {
		String result = "";
		//split the grid at ; to extract different categories in the grid
		String[] splitted = grid.split(";");
		//array that consists of (x,y) of the telephone booth
		String[] telephone = splitted[3].split(",");
		//array that contains locations of all the agents
		String[] agents = splitted[4].split(",");
		//array that contains locations of all pills
		String[] pills = splitted[5].split(",");
		//array that contains locations of all the pads
		//this array is always divisible by 4 since the pad comes in pairs
		//(startx, starty, finishx, finishy)
		String[] pads = splitted[6].split(",");
		//array that contains locations of all the hostages
		String[] hostages = splitted[7].split(",");
		
		if(x == Integer.parseInt(telephone[0]) && y == Integer.parseInt(telephone[1])) {
			result = "telephone;" + x + ";" + y;
			return result;
		}
		for (int i = 0 ; i < agents.length-1; i+=2) {
			if(x == Integer.parseInt(agents[i]) && y == Integer.parseInt(agents[i+1])) {
				result = "agent;" + x + ";" + y;
				return result;
			}
		}
		for (int i = 0 ; i < pills.length-1; i+=2) {
			if(x == Integer.parseInt(pills[i]) && y == Integer.parseInt(pills[i+1])) {
				result = "pill;" + x + ";" + y;
				return result;
			}
		}
		for (int i = 0 ; i < pads.length-1; i+=2) {
			if(x == Integer.parseInt(pads[i]) && y == Integer.parseInt(pads[i+1])) {
				result = "pad;" + x + ";" + y;
				i/2
				//return pair of pads attached together
				return result;
			}
		}
		for (int i = 0 ; i < hostages.length-1; i+=3) {
			System.out.println(hostages[i]);
			if(x == Integer.parseInt(hostages[i]) && y == Integer.parseInt(hostages[i+1])) {
				result = "hostage";
				return result;
			}
		}
		
		return result;
	}
	
	public static void main(String[] args) {
		
		System.out.println(whatInCell(1,2, "3,3;1;0,0;1,1;0,1;1,2;0,2,2,0;1,0,0,2,1,50,2,2,90"));
	}
	
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2991)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-11-03 17:28:48.472
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2991)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-11-03 17:28:48.472
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2991)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-11-03 17:28:51.224
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package code;
import java.util.ArrayList;

import code.Location;

public class TreeNode {
	
	//list for tracking the previous cells visited to avoid repeated states
	public ArrayList<Location> prevCells;
	//current node location
	public Location myLoc;
	//number of current alive hostages
	public int hostagesNum;
	//number of mutant hostages that must be killed
	public int mutantHostagesNum;
	//track of neo's health/damage
	public int neoHealth;
	//the updated string according to the path that led to the current node
	public String grid;
	
	public TreeNode(ArrayList<Location> prevCells, Location myLoc, int hNum, int mHNum, int neoH, String grid) {
		
		this.prevCells = prevCells;
		this.myLoc = myLoc;
		this.hostagesNum = hNum;
		this.mutantHostagesNum = mHNum;
		this.neoHealth = neoH;
		this.grid = grid;		
		
	}
	
	//method to print the content of any array
	public static void printArr (String[] arr)
	{
		for ( int i = 0 ; i < arr.length; i++) {
			System.out.print(arr[i]);
		}
		System.out.println(" ");
	}
	
	// we need to add the locations of mutant hostages in the grid
	// or implement a method that checks the damage of all hostages
	
	//return array of important values like name of the object
	//for example hostage and health
	//pad and locations
	
	
	//method to get the content of the given cell
	//can be used to determine the surroundings of the current cell 
	public static String whatInCell(int x, int y, String grid) {
		String result = "";
		//split the grid at ; to extract different categories in the grid
		String[] splitted = grid.split(";");
		//array that consists of (x,y) of the telephone booth
		String[] telephone = splitted[3].split(",");
		//array that contains locations of all the agents
		String[] agents = splitted[4].split(",");
		//array that contains locations of all pills
		String[] pills = splitted[5].split(",");
		//array that contains locations of all the pads
		//this array is always divisible by 4 since the pad comes in pairs
		//(startx, starty, finishx, finishy)
		String[] pads = splitted[6].split(",");
		//array that contains locations of all the hostages
		String[] hostages = splitted[7].split(",");
		
		if(x == Integer.parseInt(telephone[0]) && y == Integer.parseInt(telephone[1])) {
			result = "telephone;" + x + ";" + y;
			return result;
		}
		for (int i = 0 ; i < agents.length-1; i+=2) {
			if(x == Integer.parseInt(agents[i]) && y == Integer.parseInt(agents[i+1])) {
				result = "agent;" + x + ";" + y;
				return result;
			}
		}
		for (int i = 0 ; i < pills.length-1; i+=2) {
			if(x == Integer.parseInt(pills[i]) && y == Integer.parseInt(pills[i+1])) {
				result = "pill;" + x + ";" + y;
				return result;
			}
		}
		for (int i = 0 ; i < pads.length-1; i+=2) {
			if(x == Integer.parseInt(pads[i]) && y == Integer.parseInt(pads[i+1])) {
				result = "pad;" + x + ";" + y;
				(i/2
				//return pair of pads attached together
				return result;
			}
		}
		for (int i = 0 ; i < hostages.length-1; i+=3) {
			System.out.println(hostages[i]);
			if(x == Integer.parseInt(hostages[i]) && y == Integer.parseInt(hostages[i+1])) {
				result = "hostage";
				return result;
			}
		}
		
		return result;
	}
	
	public static void main(String[] args) {
		
		System.out.println(whatInCell(1,2, "3,3;1;0,0;1,1;0,1;1,2;0,2,2,0;1,0,0,2,1,50,2,2,90"));
	}
	
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2991)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:494)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-11-03 17:28:51.225
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2991)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:494)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-11-03 17:28:51.225
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2991)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:494)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-11-03 17:28:51.310
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package code;
import java.util.ArrayList;

import code.Location;

public class TreeNode {
	
	//list for tracking the previous cells visited to avoid repeated states
	public ArrayList<Location> prevCells;
	//current node location
	public Location myLoc;
	//number of current alive hostages
	public int hostagesNum;
	//number of mutant hostages that must be killed
	public int mutantHostagesNum;
	//track of neo's health/damage
	public int neoHealth;
	//the updated string according to the path that led to the current node
	public String grid;
	
	public TreeNode(ArrayList<Location> prevCells, Location myLoc, int hNum, int mHNum, int neoH, String grid) {
		
		this.prevCells = prevCells;
		this.myLoc = myLoc;
		this.hostagesNum = hNum;
		this.mutantHostagesNum = mHNum;
		this.neoHealth = neoH;
		this.grid = grid;		
		
	}
	
	//method to print the content of any array
	public static void printArr (String[] arr)
	{
		for ( int i = 0 ; i < arr.length; i++) {
			System.out.print(arr[i]);
		}
		System.out.println(" ");
	}
	
	// we need to add the locations of mutant hostages in the grid
	// or implement a method that checks the damage of all hostages
	
	//return array of important values like name of the object
	//for example hostage and health
	//pad and locations
	
	
	//method to get the content of the given cell
	//can be used to determine the surroundings of the current cell 
	public static String whatInCell(int x, int y, String grid) {
		String result = "";
		//split the grid at ; to extract different categories in the grid
		String[] splitted = grid.split(";");
		//array that consists of (x,y) of the telephone booth
		String[] telephone = splitted[3].split(",");
		//array that contains locations of all the agents
		String[] agents = splitted[4].split(",");
		//array that contains locations of all pills
		String[] pills = splitted[5].split(",");
		//array that contains locations of all the pads
		//this array is always divisible by 4 since the pad comes in pairs
		//(startx, starty, finishx, finishy)
		String[] pads = splitted[6].split(",");
		//array that contains locations of all the hostages
		String[] hostages = splitted[7].split(",");
		
		if(x == Integer.parseInt(telephone[0]) && y == Integer.parseInt(telephone[1])) {
			result = "telephone;" + x + ";" + y;
			return result;
		}
		for (int i = 0 ; i < agents.length-1; i+=2) {
			if(x == Integer.parseInt(agents[i]) && y == Integer.parseInt(agents[i+1])) {
				result = "agent;" + x + ";" + y;
				return result;
			}
		}
		for (int i = 0 ; i < pills.length-1; i+=2) {
			if(x == Integer.parseInt(pills[i]) && y == Integer.parseInt(pills[i+1])) {
				result = "pill;" + x + ";" + y;
				return result;
			}
		}
		for (int i = 0 ; i < pads.length-1; i+=2) {
			if(x == Integer.parseInt(pads[i]) && y == Integer.parseInt(pads[i+1])) {
				result = "pad;" + x + ";" + y;
				(i/2
				//return pair of pads attached together
				return result;
			}
		}
		for (int i = 0 ; i < hostages.length-1; i+=3) {
			System.out.println(hostages[i]);
			if(x == Integer.parseInt(hostages[i]) && y == Integer.parseInt(hostages[i+1])) {
				result = "hostage";
				return result;
			}
		}
		
		return result;
	}
	
	public static void main(String[] args) {
		
		System.out.println(whatInCell(1,2, "3,3;1;0,0;1,1;0,1;1,2;0,2,2,0;1,0,0,2,1,50,2,2,90"));
	}
	
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2991)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-11-03 17:28:51.310
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2991)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-11-03 17:28:51.311
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2991)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-11-03 17:28:52.347
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package code;
import java.util.ArrayList;

import code.Location;

public class TreeNode {
	
	//list for tracking the previous cells visited to avoid repeated states
	public ArrayList<Location> prevCells;
	//current node location
	public Location myLoc;
	//number of current alive hostages
	public int hostagesNum;
	//number of mutant hostages that must be killed
	public int mutantHostagesNum;
	//track of neo's health/damage
	public int neoHealth;
	//the updated string according to the path that led to the current node
	public String grid;
	
	public TreeNode(ArrayList<Location> prevCells, Location myLoc, int hNum, int mHNum, int neoH, String grid) {
		
		this.prevCells = prevCells;
		this.myLoc = myLoc;
		this.hostagesNum = hNum;
		this.mutantHostagesNum = mHNum;
		this.neoHealth = neoH;
		this.grid = grid;		
		
	}
	
	//method to print the content of any array
	public static void printArr (String[] arr)
	{
		for ( int i = 0 ; i < arr.length; i++) {
			System.out.print(arr[i]);
		}
		System.out.println(" ");
	}
	
	// we need to add the locations of mutant hostages in the grid
	// or implement a method that checks the damage of all hostages
	
	//return array of important values like name of the object
	//for example hostage and health
	//pad and locations
	
	
	//method to get the content of the given cell
	//can be used to determine the surroundings of the current cell 
	public static String whatInCell(int x, int y, String grid) {
		String result = "";
		//split the grid at ; to extract different categories in the grid
		String[] splitted = grid.split(";");
		//array that consists of (x,y) of the telephone booth
		String[] telephone = splitted[3].split(",");
		//array that contains locations of all the agents
		String[] agents = splitted[4].split(",");
		//array that contains locations of all pills
		String[] pills = splitted[5].split(",");
		//array that contains locations of all the pads
		//this array is always divisible by 4 since the pad comes in pairs
		//(startx, starty, finishx, finishy)
		String[] pads = splitted[6].split(",");
		//array that contains locations of all the hostages
		String[] hostages = splitted[7].split(",");
		
		if(x == Integer.parseInt(telephone[0]) && y == Integer.parseInt(telephone[1])) {
			result = "telephone;" + x + ";" + y;
			return result;
		}
		for (int i = 0 ; i < agents.length-1; i+=2) {
			if(x == Integer.parseInt(agents[i]) && y == Integer.parseInt(agents[i+1])) {
				result = "agent;" + x + ";" + y;
				return result;
			}
		}
		for (int i = 0 ; i < pills.length-1; i+=2) {
			if(x == Integer.parseInt(pills[i]) && y == Integer.parseInt(pills[i+1])) {
				result = "pill;" + x + ";" + y;
				return result;
			}
		}
		for (int i = 0 ; i < pads.length-1; i+=2) {
			if(x == Integer.parseInt(pads[i]) && y == Integer.parseInt(pads[i+1])) {
				result = "pad;" + x + ";" + y;
				(i/2
				//return pair of pads attached together
				return result;
			}
		}
		for (int i = 0 ; i < hostages.length-1; i+=3) {
			System.out.println(hostages[i]);
			if(x == Integer.parseInt(hostages[i]) && y == Integer.parseInt(hostages[i+1])) {
				result = "hostage";
				return result;
			}
		}
		
		return result;
	}
	
	public static void main(String[] args) {
		
		System.out.println(whatInCell(1,2, "3,3;1;0,0;1,1;0,1;1,2;0,2,2,0;1,0,0,2,1,50,2,2,90"));
	}
	
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2991)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-11-03 17:28:52.347
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2991)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-11-03 17:28:52.348
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2991)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-11-03 17:29:00.238
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package code;
import java.util.ArrayList;

import code.Location;

public class TreeNode {
	
	//list for tracking the previous cells visited to avoid repeated states
	public ArrayList<Location> prevCells;
	//current node location
	public Location myLoc;
	//number of current alive hostages
	public int hostagesNum;
	//number of mutant hostages that must be killed
	public int mutantHostagesNum;
	//track of neo's health/damage
	public int neoHealth;
	//the updated string according to the path that led to the current node
	public String grid;
	
	public TreeNode(ArrayList<Location> prevCells, Location myLoc, int hNum, int mHNum, int neoH, String grid) {
		
		this.prevCells = prevCells;
		this.myLoc = myLoc;
		this.hostagesNum = hNum;
		this.mutantHostagesNum = mHNum;
		this.neoHealth = neoH;
		this.grid = grid;		
		
	}
	
	//method to print the content of any array
	public static void printArr (String[] arr)
	{
		for ( int i = 0 ; i < arr.length; i++) {
			System.out.print(arr[i]);
		}
		System.out.println(" ");
	}
	
	// we need to add the locations of mutant hostages in the grid
	// or implement a method that checks the damage of all hostages
	
	//return array of important values like name of the object
	//for example hostage and health
	//pad and locations
	
	
	//method to get the content of the given cell
	//can be used to determine the surroundings of the current cell 
	public static String whatInCell(int x, int y, String grid) {
		String result = "";
		//split the grid at ; to extract different categories in the grid
		String[] splitted = grid.split(";");
		//array that consists of (x,y) of the telephone booth
		String[] telephone = splitted[3].split(",");
		//array that contains locations of all the agents
		String[] agents = splitted[4].split(",");
		//array that contains locations of all pills
		String[] pills = splitted[5].split(",");
		//array that contains locations of all the pads
		//this array is always divisible by 4 since the pad comes in pairs
		//(startx, starty, finishx, finishy)
		String[] pads = splitted[6].split(",");
		//array that contains locations of all the hostages
		String[] hostages = splitted[7].split(",");
		
		if(x == Integer.parseInt(telephone[0]) && y == Integer.parseInt(telephone[1])) {
			result = "telephone;" + x + ";" + y;
			return result;
		}
		for (int i = 0 ; i < agents.length-1; i+=2) {
			if(x == Integer.parseInt(agents[i]) && y == Integer.parseInt(agents[i+1])) {
				result = "agent;" + x + ";" + y;
				return result;
			}
		}
		for (int i = 0 ; i < pills.length-1; i+=2) {
			if(x == Integer.parseInt(pills[i]) && y == Integer.parseInt(pills[i+1])) {
				result = "pill;" + x + ";" + y;
				return result;
			}
		}
		for (int i = 0 ; i < pads.length-1; i+=2) {
			if(x == Integer.parseInt(pads[i]) && y == Integer.parseInt(pads[i+1])) {
				result = "pad;" + x + ";" + y;
				(i/2)
				//return pair of pads attached together
				return result;
			}
		}
		for (int i = 0 ; i < hostages.length-1; i+=3) {
			System.out.println(hostages[i]);
			if(x == Integer.parseInt(hostages[i]) && y == Integer.parseInt(hostages[i+1])) {
				result = "hostage";
				return result;
			}
		}
		
		return result;
	}
	
	public static void main(String[] args) {
		
		System.out.println(whatInCell(1,2, "3,3;1;0,0;1,1;0,1;1,2;0,2,2,0;1,0,0,2,1,50,2,2,90"));
	}
	
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2991)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:494)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-11-03 17:29:00.239
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2991)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:494)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-11-03 17:29:00.239
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2991)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:494)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-11-03 17:29:00.245
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package code;
import java.util.ArrayList;

import code.Location;

public class TreeNode {
	
	//list for tracking the previous cells visited to avoid repeated states
	public ArrayList<Location> prevCells;
	//current node location
	public Location myLoc;
	//number of current alive hostages
	public int hostagesNum;
	//number of mutant hostages that must be killed
	public int mutantHostagesNum;
	//track of neo's health/damage
	public int neoHealth;
	//the updated string according to the path that led to the current node
	public String grid;
	
	public TreeNode(ArrayList<Location> prevCells, Location myLoc, int hNum, int mHNum, int neoH, String grid) {
		
		this.prevCells = prevCells;
		this.myLoc = myLoc;
		this.hostagesNum = hNum;
		this.mutantHostagesNum = mHNum;
		this.neoHealth = neoH;
		this.grid = grid;		
		
	}
	
	//method to print the content of any array
	public static void printArr (String[] arr)
	{
		for ( int i = 0 ; i < arr.length; i++) {
			System.out.print(arr[i]);
		}
		System.out.println(" ");
	}
	
	// we need to add the locations of mutant hostages in the grid
	// or implement a method that checks the damage of all hostages
	
	//return array of important values like name of the object
	//for example hostage and health
	//pad and locations
	
	
	//method to get the content of the given cell
	//can be used to determine the surroundings of the current cell 
	public static String whatInCell(int x, int y, String grid) {
		String result = "";
		//split the grid at ; to extract different categories in the grid
		String[] splitted = grid.split(";");
		//array that consists of (x,y) of the telephone booth
		String[] telephone = splitted[3].split(",");
		//array that contains locations of all the agents
		String[] agents = splitted[4].split(",");
		//array that contains locations of all pills
		String[] pills = splitted[5].split(",");
		//array that contains locations of all the pads
		//this array is always divisible by 4 since the pad comes in pairs
		//(startx, starty, finishx, finishy)
		String[] pads = splitted[6].split(",");
		//array that contains locations of all the hostages
		String[] hostages = splitted[7].split(",");
		
		if(x == Integer.parseInt(telephone[0]) && y == Integer.parseInt(telephone[1])) {
			result = "telephone;" + x + ";" + y;
			return result;
		}
		for (int i = 0 ; i < agents.length-1; i+=2) {
			if(x == Integer.parseInt(agents[i]) && y == Integer.parseInt(agents[i+1])) {
				result = "agent;" + x + ";" + y;
				return result;
			}
		}
		for (int i = 0 ; i < pills.length-1; i+=2) {
			if(x == Integer.parseInt(pills[i]) && y == Integer.parseInt(pills[i+1])) {
				result = "pill;" + x + ";" + y;
				return result;
			}
		}
		for (int i = 0 ; i < pads.length-1; i+=2) {
			if(x == Integer.parseInt(pads[i]) && y == Integer.parseInt(pads[i+1])) {
				result = "pad;" + x + ";" + y;
				(i/2)
				//return pair of pads attached together
				return result;
			}
		}
		for (int i = 0 ; i < hostages.length-1; i+=3) {
			System.out.println(hostages[i]);
			if(x == Integer.parseInt(hostages[i]) && y == Integer.parseInt(hostages[i+1])) {
				result = "hostage";
				return result;
			}
		}
		
		return result;
	}
	
	public static void main(String[] args) {
		
		System.out.println(whatInCell(1,2, "3,3;1;0,0;1,1;0,1;1,2;0,2,2,0;1,0,0,2,1,50,2,2,90"));
	}
	
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2991)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-11-03 17:29:00.245
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2991)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-11-03 17:29:00.246
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2991)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-11-03 17:29:18.756
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package code;
import java.util.ArrayList;

import code.Location;

public class TreeNode {
	
	//list for tracking the previous cells visited to avoid repeated states
	public ArrayList<Location> prevCells;
	//current node location
	public Location myLoc;
	//number of current alive hostages
	public int hostagesNum;
	//number of mutant hostages that must be killed
	public int mutantHostagesNum;
	//track of neo's health/damage
	public int neoHealth;
	//the updated string according to the path that led to the current node
	public String grid;
	
	public TreeNode(ArrayList<Location> prevCells, Location myLoc, int hNum, int mHNum, int neoH, String grid) {
		
		this.prevCells = prevCells;
		this.myLoc = myLoc;
		this.hostagesNum = hNum;
		this.mutantHostagesNum = mHNum;
		this.neoHealth = neoH;
		this.grid = grid;		
		
	}
	
	//method to print the content of any array
	public static void printArr (String[] arr)
	{
		for ( int i = 0 ; i < arr.length; i++) {
			System.out.print(arr[i]);
		}
		System.out.println(" ");
	}
	
	// we need to add the locations of mutant hostages in the grid
	// or implement a method that checks the damage of all hostages
	
	//return array of important values like name of the object
	//for example hostage and health
	//pad and locations
	
	
	//method to get the content of the given cell
	//can be used to determine the surroundings of the current cell 
	public static String whatInCell(int x, int y, String grid) {
		String result = "";
		//split the grid at ; to extract different categories in the grid
		String[] splitted = grid.split(";");
		//array that consists of (x,y) of the telephone booth
		String[] telephone = splitted[3].split(",");
		//array that contains locations of all the agents
		String[] agents = splitted[4].split(",");
		//array that contains locations of all pills
		String[] pills = splitted[5].split(",");
		//array that contains locations of all the pads
		//this array is always divisible by 4 since the pad comes in pairs
		//(startx, starty, finishx, finishy)
		String[] pads = splitted[6].split(",");
		//array that contains locations of all the hostages
		String[] hostages = splitted[7].split(",");
		
		if(x == Integer.parseInt(telephone[0]) && y == Integer.parseInt(telephone[1])) {
			result = "telephone;" + x + ";" + y;
			return result;
		}
		for (int i = 0 ; i < agents.length-1; i+=2) {
			if(x == Integer.parseInt(agents[i]) && y == Integer.parseInt(agents[i+1])) {
				result = "agent;" + x + ";" + y;
				return result;
			}
		}
		for (int i = 0 ; i < pills.length-1; i+=2) {
			if(x == Integer.parseInt(pills[i]) && y == Integer.parseInt(pills[i+1])) {
				result = "pill;" + x + ";" + y;
				return result;
			}
		}
		for (int i = 0 ; i < pads.length-1; i+=2) {
			if(x == Integer.parseInt(pads[i]) && y == Integer.parseInt(pads[i+1])) {
				result = "pad;" + x + ";" + y;
				(i/2)//
				//return pair of pads attached together
				return result;
			}
		}
		for (int i = 0 ; i < hostages.length-1; i+=3) {
			System.out.println(hostages[i]);
			if(x == Integer.parseInt(hostages[i]) && y == Integer.parseInt(hostages[i+1])) {
				result = "hostage";
				return result;
			}
		}
		
		return result;
	}
	
	public static void main(String[] args) {
		
		System.out.println(whatInCell(1,2, "3,3;1;0,0;1,1;0,1;1,2;0,2,2,0;1,0,0,2,1,50,2,2,90"));
	}
	
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2991)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:494)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-11-03 17:29:18.756
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2991)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:494)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-11-03 17:29:18.757
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2991)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:494)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-11-03 17:29:18.762
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package code;
import java.util.ArrayList;

import code.Location;

public class TreeNode {
	
	//list for tracking the previous cells visited to avoid repeated states
	public ArrayList<Location> prevCells;
	//current node location
	public Location myLoc;
	//number of current alive hostages
	public int hostagesNum;
	//number of mutant hostages that must be killed
	public int mutantHostagesNum;
	//track of neo's health/damage
	public int neoHealth;
	//the updated string according to the path that led to the current node
	public String grid;
	
	public TreeNode(ArrayList<Location> prevCells, Location myLoc, int hNum, int mHNum, int neoH, String grid) {
		
		this.prevCells = prevCells;
		this.myLoc = myLoc;
		this.hostagesNum = hNum;
		this.mutantHostagesNum = mHNum;
		this.neoHealth = neoH;
		this.grid = grid;		
		
	}
	
	//method to print the content of any array
	public static void printArr (String[] arr)
	{
		for ( int i = 0 ; i < arr.length; i++) {
			System.out.print(arr[i]);
		}
		System.out.println(" ");
	}
	
	// we need to add the locations of mutant hostages in the grid
	// or implement a method that checks the damage of all hostages
	
	//return array of important values like name of the object
	//for example hostage and health
	//pad and locations
	
	
	//method to get the content of the given cell
	//can be used to determine the surroundings of the current cell 
	public static String whatInCell(int x, int y, String grid) {
		String result = "";
		//split the grid at ; to extract different categories in the grid
		String[] splitted = grid.split(";");
		//array that consists of (x,y) of the telephone booth
		String[] telephone = splitted[3].split(",");
		//array that contains locations of all the agents
		String[] agents = splitted[4].split(",");
		//array that contains locations of all pills
		String[] pills = splitted[5].split(",");
		//array that contains locations of all the pads
		//this array is always divisible by 4 since the pad comes in pairs
		//(startx, starty, finishx, finishy)
		String[] pads = splitted[6].split(",");
		//array that contains locations of all the hostages
		String[] hostages = splitted[7].split(",");
		
		if(x == Integer.parseInt(telephone[0]) && y == Integer.parseInt(telephone[1])) {
			result = "telephone;" + x + ";" + y;
			return result;
		}
		for (int i = 0 ; i < agents.length-1; i+=2) {
			if(x == Integer.parseInt(agents[i]) && y == Integer.parseInt(agents[i+1])) {
				result = "agent;" + x + ";" + y;
				return result;
			}
		}
		for (int i = 0 ; i < pills.length-1; i+=2) {
			if(x == Integer.parseInt(pills[i]) && y == Integer.parseInt(pills[i+1])) {
				result = "pill;" + x + ";" + y;
				return result;
			}
		}
		for (int i = 0 ; i < pads.length-1; i+=2) {
			if(x == Integer.parseInt(pads[i]) && y == Integer.parseInt(pads[i+1])) {
				result = "pad;" + x + ";" + y;
				(i/2)//
				//return pair of pads attached together
				return result;
			}
		}
		for (int i = 0 ; i < hostages.length-1; i+=3) {
			System.out.println(hostages[i]);
			if(x == Integer.parseInt(hostages[i]) && y == Integer.parseInt(hostages[i+1])) {
				result = "hostage";
				return result;
			}
		}
		
		return result;
	}
	
	public static void main(String[] args) {
		
		System.out.println(whatInCell(1,2, "3,3;1;0,0;1,1;0,1;1,2;0,2,2,0;1,0,0,2,1,50,2,2,90"));
	}
	
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2991)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-11-03 17:29:18.762
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2991)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-11-03 17:29:18.762
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2991)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2021-11-03 22:26:38.321 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=16.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-03 22:26:50.744
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-03 22:26:50.744
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6d80e411,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@32caae19,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-03 22:26:53.882
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\safam'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-11-04 22:26:33.476 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=16.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-04 22:26:47.313
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-04 22:26:47.313
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6d80e411,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@32caae19,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-04 22:26:50.409
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\safam'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-11-06 17:03:57.997 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=16.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-06 17:04:08.722
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-06 17:04:08.723
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@32caae19,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@60e67c06,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-06 17:04:11.784
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\safam'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-11-07 00:08:00.152 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=16.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-07 00:08:04.699
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-07 00:08:04.699
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@72e36677,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6b86826a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-07 00:08:07.590
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\safam'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-11-07 11:12:28.691 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=16.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-07 11:13:16.813
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-07 11:13:16.813
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3c2dda7c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4b9fa2f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-07 11:13:20.345
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\safam'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-11-07 12:26:07.108 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=16.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-07 12:26:12.107
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-07 12:26:12.108
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4b9fa2f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6d80e411,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-07 12:26:14.695
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\safam'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-11-07 13:43:57.374 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=16.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-07 13:44:04.428
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-07 13:44:04.429
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@60e67c06,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2bc59ab7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-07 13:44:07.135
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\safam'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-11-07 14:08:02.918 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=16.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-07 14:08:07.731
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-07 14:08:07.731
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4b9fa2f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6d80e411,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-07 14:08:10.606
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\safam'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-11-07 19:08:42.867 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=16.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-07 19:09:03.973
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-07 19:09:03.973
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6b86826a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3c2dda7c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-07 19:09:07.434
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\safam'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-11-07 23:14:33.756 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=16.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-07 23:14:37.992
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-07 23:14:37.992
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4b9fa2f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6d80e411,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-07 23:14:40.504
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\safam'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-11-10 14:13:52.700 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=16.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-10 14:14:06.345
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-10 14:14:06.345
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6b86826a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3c2dda7c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-10 14:14:09.618
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\safam'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-11-10 23:50:43.824 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=16.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-10 23:50:47.444
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-10 23:50:47.444
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@39ae6408,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@cfacf0,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-10 23:50:50.001
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\safam'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-11-12 18:51:56.769 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=16.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-12 18:52:14.457
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-12 18:52:14.457
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@32caae19,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@60e67c06,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-12 18:52:17.527
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\safam'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-11-12 22:46:49.385 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=16.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-12 22:46:53.369
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-12 22:46:53.370
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@60e67c06,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2bc59ab7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-12 22:46:55.942
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\safam'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-11-14 13:44:47.403 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=16.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-14 13:44:58.780
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-14 13:44:58.780
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@60e67c06,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2bc59ab7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-14 13:45:02.163
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\safam'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-11-14 19:54:19.821 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=16.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-14 19:54:29.197
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-14 19:54:29.197
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4b9fa2f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6d80e411,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-14 19:54:31.739
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\safam'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-11-15 00:30:49.656 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=16.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-15 00:30:53.857
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-15 00:30:53.857
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7210f559,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@49b9ba6a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-15 00:30:57.056
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\safam'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-11-15 01:52:00.279 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=16.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-15 01:52:04.375
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-15 01:52:04.375
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4b9fa2f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6d80e411,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-15 01:52:07.100
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\safam'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-11-15 13:36:13.170 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=16.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-15 13:36:25.326
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-15 13:36:25.326
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6d80e411,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@32caae19,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-15 13:36:29.353
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\safam'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2021-11-15 23:13:13.054
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package code;

import java.util.ArrayList;

import code.Location;
import code.TreeNode;
import code.Queue.*;

public abstract class GeneralSearch {

	// habdyn el cost wl depth
	// check game over

	public static String generalSearch(String grid, String strategy, boolean visualize) {
		String result = "";
		//initialize everything as this is the start
		ArrayList<TreeNode> prevNodes = new ArrayList<TreeNode>();
		ArrayList<PreNode> preNodes = new ArrayList<PreNode>();
		String[] splitted = grid.split(";");
		//get Neo's starting position
		String[] preNeo = splitted[2].split(",");
		Location neo = new Location(Integer.parseInt(preNeo[0]), Integer.parseInt(preNeo[1]));
		//array to store the damages of the carried hostages
		//also used to keep track of the number of carried hostages
		ArrayList<Integer> carried = new ArrayList<Integer>();
		
		// create initial starting node
		##TO-DO
		// reminder: cost
		TreeNode start = new TreeNode(null, prevNodes, neo, 0, grid, 0, 0, "Start", 0, 0, carried);
		PreNode startPre = new PreNode("Start", neo, start, 0);

		prevNodes.add(start);

		// create the queue for search
		Queue queue;
		switch (strategy) {
		case ("DF"):
			queue = new DFQueue();
			break;
		default:
			//temporary
			queue = new DFQueue();
			break;
		}

		// get the possible actions for the starting node
		ArrayList<String> possibleActions = getPossibleActions(neo, grid);
		printArr(possibleActions);
		for (int i = 0; i < possibleActions.size(); i++) {
			String[] pa = possibleActions.get(i).split(",");
			Location affected = new Location(Integer.parseInt(pa[1]), Integer.parseInt(pa[2]));
			PreNode pn = new PreNode(pa[0], affected, start, 0);
			queue.enqueue(pn);
		}

		queue.display();

		boolean failed = false;
		String finalGrid = "";

		while (!queue.queue.isEmpty()) {
			System.out.println("habd2 ml awl");
			PreNode frontPreNode = queue.dequeue();
			boolean repeated = false;
			/*
			for (int i = 0 ; i < prevNodes.size(); i++) {
				if(frontPreNode.prevNode.myLoc.x == prevNodes.get(i).myLoc.x && 
						frontPreNode.prevNode.myLoc.y == prevNodes.get(i).myLoc.y) {
					if (!(queue.queue.isEmpty())) {
					frontPreNode = queue.dequeue();
					}
				}
			}
			*/
			TreeNode frontTreeNode = update(
					frontPreNode.action + "," + frontPreNode.affectedCell.x + "," + frontPreNode.affectedCell.y,
					frontPreNode.prevNode, prevNodes);
			for (int i = 0 ; i < prevNodes.size(); i++) {
				if(frontTreeNode.myLoc.x == prevNodes.get(i).myLoc.x && 
						frontTreeNode.myLoc.y == prevNodes.get(i).myLoc.y &&
						compareGrids(frontTreeNode.grid, prevNodes.get(i).grid) == true) {
					//ignore this path
					repeated = true;
					break;
					//if (!(queue.queue.isEmpty())) {
					//frontPreNode = queue.dequeue();
					//}
				}
			}
			if (repeated == true) {
				System.out.println("msh hakml");
				continue;
			}
			System.out.println("tamam");
			prevNodes.add(frontTreeNode);
			possibleActions = getPossibleActions(frontTreeNode.myLoc, frontTreeNode.grid);
			
			for (int i = 0; i < possibleActions.size(); i++) {
				String[] pa = possibleActions.get(i).split(",");
				//System.out.println(possibleActions.get(i));
				Location affected = new Location(Integer.parseInt(pa[1]), Integer.parseInt(pa[2]));
				PreNode pn = new PreNode(pa[0], affected, frontTreeNode, 0);
				queue.enqueue(pn);
				//queue.display();
			}
			boolean goal = isItGoal(frontTreeNode);
			System.out.println(frontPreNode.action);
			queue.display();
			if (queue.queue.isEmpty()) {
				failed = true;
			}
			
			if (frontTreeNode.neoDamage >= 100) {
				return "fail";
			}
			
			finalGrid = frontTreeNode.grid;

		}
		return finalGrid;
	}
	
	//this might be tricky if we needed the damages as a difference
	public static boolean compareGrids(String grid1, String grid2) {
		boolean similar = false;
		//if same number of agents and hostages and pills then similar
		String[] splitted1 = grid1.split(";");
		String[] splitted2 = grid2.split(";");
		String[] agents1 = splitted1[4].split(",");
		String[] agents2 = splitted2[4].split(",");
		if (agents1.length == agents2.length) {
			//check pills
			String[] pills1 = splitted1[5].split(",");
			String[] pills2 = splitted2[5].split(",");
			if (pills1.length == pills2.length) {
				//check hostages
				String[] hos1;
				if (splitted1.length <= 7 ) {
					//no more hostages
					hos1 = new String[0];
				}else {
					hos1 = splitted1[7].split(",");
				}
				
				String[] hos2;
				if (splitted2.length <= 7 ) {
					//no more hostages
					hos2 = new String[0];
				}else {
					hos2 = splitted2[7].split(",");
				}
				if (hos1.length ==hos2.length) {
					similar = true;
				}else {
					similar = false;
				}
			}else {
				similar = false;
			}
		}else {
			similar = false;
		}
		return similar;
	}

	// goal test
	public static boolean isItGoal(TreeNode n) {

		boolean goal = false;
		String grid = n.grid;
		ArrayList<String> hostages = getHostages(grid);
		ArrayList<String> mutantHostages = getMutantHostages(grid);
		if (mutantHostages.size() == 0 && hostages.size() == 0) {
			goal = true;
		}
		return goal;

	}

	// method to print the content of any array
	public static void printArr(ArrayList<String> arr) {
		for (int i = 0; i < arr.size(); i++) {
			System.out.println(arr.get(i));
		}
		System.out.println(" ");
	}

	// method to fill the hostages and damage
	public static ArrayList<String> getHostages(String grid) {
		ArrayList<String> result = new ArrayList<String>();
		String[] splitted = grid.split(";");
		// System.out.println(splitted.length);
		// array that contains locations of all the hostages
		String[] hostages;
		if (splitted.length <= 7) {
			hostages = new String[0];
		}else {
			hostages = splitted[7].split(",");
		}

		for (int i = 0; i < hostages.length - 1; i += 3) {
			// store the location and damage in a string
			String temp = "";
			// check the damage to know if mutant or alive
			// if mutant then skip this iteration
			if (Integer.parseInt(hostages[i + 2]) < 100) {
				temp += hostages[i] + "," + hostages[i + 1] + "," + hostages[i + 2];
				result.add(temp);
			}

		}

		return result;
	}

	// method to fill the mutant hostages
	public static ArrayList<String> getMutantHostages(String grid) {
		ArrayList<String> result = new ArrayList<String>();

		String[] splitted = grid.split(";");
		// array that contains locations of all the hostages
		String[] hostages;
		if (splitted.length <= 7) {
			hostages = new String[0];
		}else {
			hostages = splitted[7].split(",");
		}

		for (int i = 0; i < hostages.length - 1; i += 3) {
			// store the location in a string
			String temp = "";
			// check the damage to know if mutant or alive
			// if alive then skip this iteration
			if (Integer.parseInt(hostages[i + 2]) >= 100) {
				// add only the location since we do not need the damage
				temp += hostages[i] + "," + hostages[i + 1];
				result.add(temp);
			}

		}

		return result;
	}

	// method to get the content of the given cell and useful information about
	// content of cell
	// can be used to determine the surroundings of the current cell
	public static String whatInCell(int x, int y, String grid) {
		String result = "";
		// split the grid at ; to extract different categories in the grid
		String[] splitted = grid.split(";");
		// array that consists of (x,y) of the telephone booth
		String[] telephone = splitted[3].split(",");
		// array that contains locations of all the agents
		String[] agents = splitted[4].split(",");
		// array that contains locations of all pills
		String[] pills = splitted[5].split(",");
		// array that contains locations of all the pads
		// this array is always divisible by 4 since the pad comes in pairs
		// (startx, starty, finishx, finishy)
		String[] pads = splitted[6].split(",");
		// array that contains locations of all the hostages
		String[] hostages;
		if (splitted.length <=7) {
			hostages = new String[0];
		}else {
			hostages = splitted[7].split(",");
		}

		if (x == Integer.parseInt(telephone[0]) && y == Integer.parseInt(telephone[1])) {
			result = "telephone;" + x + ";" + y;
			return result;
		}
		for (int i = 0; i < agents.length - 1; i += 2) {
			if (x == Integer.parseInt(agents[i]) && y == Integer.parseInt(agents[i + 1])) {
				result = "agent;" + x + ";" + y;
				return result;
			}
		}
		for (int i = 0; i < pills.length - 1; i += 2) {
			if (x == Integer.parseInt(pills[i]) && y == Integer.parseInt(pills[i + 1])) {
				result = "pill;" + x + ";" + y;
				return result;
			}
		}
		for (int i = 0; i < pads.length - 1; i += 2) {
			if (x == Integer.parseInt(pads[i]) && y == Integer.parseInt(pads[i + 1])) {
				result = "pad;" + x + ";" + y;
				if ((i / 2) % 2 == 0) {
					result += ";" + pads[i + 2] + ";" + pads[i + 3];
				} else {
					result += ";" + pads[i - 2] + ";" + pads[i - 1];
				}
				// return pair of pads attached together
				return result;
			}
		}
		for (int i = 0; i < hostages.length - 1; i += 3) {
			if (x == Integer.parseInt(hostages[i]) && y == Integer.parseInt(hostages[i + 1])) {
				result = "hostage;" + x + ";" + y + ";" + hostages[i + 2];
				return result;
			}
		}

		return result;
	}

	// method to detect where can I move
	public static ArrayList<String> whereCanIMove(Location current, String grid) {
		ArrayList<String> result = new ArrayList<String>();
		// check all possible directions
		String[] splitted = grid.split(";");
		String[] dimensions = splitted[0].split(",");
		int cols = Integer.parseInt(dimensions[1]);
		int rows = Integer.parseInt(dimensions[0]);
		boolean up = false;
		boolean right = false;
		boolean down = false;
		boolean left = false;
		// check if I can go left
		if (current.y > 0) {
			// check if there is an agent or a mutant agent
			String upCellComponent = whatInCell(current.x, current.y - 1, grid);
			if (!(upCellComponent.contains("agent"))) {
				// check if there is a mutant hostage
				if (upCellComponent.contains("hostage")) {
					// check the damage to know if it is mutant
					String[] hos = upCellComponent.split(";");
					if (Integer.parseInt(hos[3]) < 100) {
						left = true;
					} else {
						result.add("KillLeft");
					}
				}
				left = true;
			} else {
				result.add("KillLeft");
			}
		}
		// check if I can go down
		if (current.x < rows - 1) {
			// check if there is an agent or a mutant agent
			String rightCellComponent = whatInCell(current.x + 1, current.y, grid);
			if (!(rightCellComponent.contains("agent"))) {
				// check if there is a mutant hostage
				if (rightCellComponent.contains("hostage")) {
					// System.out.println(rightCellComponent);
					// check the damage to know if it is mutant
					String[] hos = rightCellComponent.split(";");
					if (Integer.parseInt(hos[3]) < 100) {
						down = true;
					} else {
						result.add("KillDown");
					}
				}
				down = true;
			} else {
				result.add("KillDown");
			}
		}
		// check if I can go right
		if (current.y < cols - 1) {
			// check if there is an agent or a mutant agent
			String downCellComponent = whatInCell(current.x, current.y + 1, grid);
			if (!(downCellComponent.contains("agent"))) {
				// check if there is a mutant hostage
				if (downCellComponent.contains("hostage")) {
					// check the damage to know if it is mutant
					String[] hos = downCellComponent.split(";");
					if (Integer.parseInt(hos[3]) < 100) {
						right = true;
					} else {
						result.add("KillRight");
					}
				}
				right = true;
			} else {
				result.add("KillRight");
			}
		}
		// check if I can go Up
		if (current.x > 0) {
			// check if there is an agent or a mutant agent
			String leftCellComponent = whatInCell(current.x - 1, current.y, grid);
			if (!(leftCellComponent.contains("agent"))) {
				// check if there is a mutant hostage
				if (leftCellComponent.contains("hostage")) {
					// check the damage to know if it is mutant
					String[] hos = leftCellComponent.split(";");
					if (Integer.parseInt(hos[3]) < 100) {
						up = true;
					} else {
						result.add("KillUp");
					}
				}
				up = true;
			} else {
				result.add("KillUp");
			}
		}
		if (up) {
			result.add("Up");
		}
		if (right) {
			result.add("Right");
		}
		if (down) {
			result.add("Down");
		}
		if (left) {
			result.add("Left");
		}

		return result;
	}

	// method to detect possible actions and insert in queue
	// this method returns array of strings of the following format
	// "ActionName", "affectedLocation"
	public static ArrayList<String> getPossibleActions(Location current, String grid) {
		ArrayList<String> result = new ArrayList<String>();
		// check the current cell components
		String currentCellComponent = whatInCell(current.x, current.y, grid);
		if (currentCellComponent.contains("pill")) {
			// either take it or leave it
			result.add("Pill," + current.x + "," + current.y);
		}
		if (currentCellComponent.contains("hostage")) {
			// cannot be a mutant hostage because we do not add this option to happen during
			// movement
			result.add("Carry," + current.x + "," + current.y);
		}
		if (currentCellComponent.contains("pad")) {
			// get the go-to pad from the string
			String[] pillData = currentCellComponent.split(";");
			// we know that the current cell is the first pad in the string so ignore it
			int fx = Integer.parseInt(pillData[3]);
			int fy = Integer.parseInt(pillData[4]);
			result.add("Fly," + fx + "," + fy);
		}
		if (currentCellComponent.contains("telephone")) {
			// you can either drop or leave
			// check before drop if there is a hostage to drop
			result.add("Drop," + current.x + "," + current.y);
		}

		// get the possible movements
		ArrayList<String> movements = whereCanIMove(current, grid);
		if (!(movements.isEmpty())) {
			for (int i = 0; i < movements.size(); i++) {
				if (movements.get(i) == "Up") {
					result.add("Up," + (current.x - 1) + "," + current.y);
				} else if (movements.get(i) == "Right") {
					result.add("Right," + current.x + "," + (current.y + 1));
				} else if (movements.get(i) == "Down") {
					result.add("Down," + (current.x + 1) + "," + current.y);
				} else if (movements.get(i) == "Left") {
					result.add("Left," + current.x + "," + (current.y - 1));
				} else if (movements.get(i) == "KillUp") {
					result.add("Kill," + (current.x - 1) + "," + current.y);
				} else if (movements.get(i) == "KillRight") {
					result.add("Kill," + current.x + "," + (current.y + 1));
				} else if (movements.get(i) == "KillDown") {
					result.add("Kill," + (current.x + 1) + "," + current.y);
				} else if (movements.get(i) == "KillLeft") {
					result.add("Kill," + current.x + "," + (current.y - 1));
				}

			}
		}
		return result;

	}

	// reminder: make the location of the carried hostage should be that of neo
	// reminder: adjust damage abl maymot law pill
	// reminder e3mly el ba2y
	// 5aly update ta5od el node

	// updates everything needed according to the action taken
	// I think it should return the new grid string
	public static TreeNode update(String action, TreeNode prevNode, ArrayList<TreeNode> prevNodes) {
		// we assume that Neo starts with 0 damage
		// update damage of all hostages

		// resultant grid
		String result = "";
		// split the grid at ; to extract different categories in the grid
		String[] splitted = prevNode.grid.split(";");
		// since the dimensions and neo's initial position and TB position are constant,
		// append to result
		result += splitted[0] + ";" + splitted[1] + ";" + splitted[2] + ";" + splitted[3] + ";";

		// array that contains locations of all the agents
		String[] agents = splitted[4].split(",");
		// array that contains the locations of all mutant hostages
		ArrayList<String> mutantHostages = getMutantHostages(prevNode.grid);
		// array that contains locations of all the pills
		String[] pills = splitted[5].split(",");
		// array that contains locations of all the pads
		// this array is always divisible by 4 since the pad comes in pairs
		// (startx, starty, finishx, finishy)
		String pads = splitted[6];
		// array that contains locations of all the hostages
		// get this array from the method getHostages to avoid getting mutant hostages
		// from the grid string
		ArrayList<String> hostages = getHostages(prevNode.grid);
		ArrayList<Integer> carried = prevNode.carried;
		int deaths = prevNode.deaths;

		for (int i = 0; i < hostages.size(); i++) {
			// each entry in the arraylist is a string with commas splitting the x and y and
			// damage
			String[] splittedHos = hostages.get(i).split(",");
			// the third element is the damage
			int oldDamage = Integer.parseInt(splittedHos[2]) + 2;
			if (action == "Pill") {
				oldDamage -= 2;
			}
			// set the new damage
			hostages.set(i, splittedHos[0] + "," + splittedHos[1] + "," + oldDamage);
			// check if it reached 100
			if (oldDamage >= 100) {
				// remove this hostage from the hostages array and add it to mutant
				mutantHostages.add(hostages.get(i));
				hostages.remove(i);
				// update the grid by adding the new hostage damage
				// as we do not add a different category in the grid string to represent the
				// mutant hostages
				// we rely on having the damage of 100 or greater to reflect this change
			}
		}
		for (int i = 0; i < carried.size(); i++) {
			int d = carried.get(i);
			if (action == "Pill") {
				if (d < 100) {
					if (d < 20) {
						carried.set(i, 0);
					} else {
						carried.set(i, d - 20);
					}

				}
			} else if (d < 100) {
				carried.set(i, d + 2);
				if (carried.get(i) >= 100) {
					deaths++;
				}
			}

		}
		int kills = prevNode.kills;
		int neoD = prevNode.neoDamage;
		Location newLocation = prevNode.myLoc;

		// get the affected location from action
		String[] actionDetails = action.split(",");
		Location moveTo = new Location(Integer.parseInt(actionDetails[1]), Integer.parseInt(actionDetails[2]));

		// check the action performed and accordingly update the grid or damage
		switch (actionDetails[0]) {
		case ("Kill"):
			System.out.println("hamoot" + (prevNode.myLoc.y == Integer.parseInt(agents[1])));
			// update grid by removing the killed agent or mutant hostage
			// increment Neo's damage by 20
			kills++;
			neoD += 20;
			// increment the number of killings by 1 if it is an agent
			for (int i = 0; i < agents.length - 1; i += 2) {
				if (Integer.parseInt(actionDetails[1]) == Integer.parseInt(agents[i])
						&& Integer.parseInt(actionDetails[2]) == Integer.parseInt(agents[i + 1])) {
					
					// replace the x and y with negatives so that when we combine the string again
					// we can know that this is not valid
					
					agents[i] = "-1";
					agents[i + 1] = "-1";
					break;
				}
			}
			for (int i = 0; i < mutantHostages.size() - 1; i += 2) {
				if (prevNode.myLoc.x == Integer.parseInt(mutantHostages.get(i))
						&& prevNode.myLoc.y == Integer.parseInt(mutantHostages.get(i + 1))) {
					// remove the mutant hostages from the arraylist
					mutantHostages.remove(i + 1);
					mutantHostages.remove(i);
					// also remove the hostage from the grid string
					break;
				}
			}

			break;
		case ("Pill"):
			// update grid method above
			// Decrement the damages of hostages and Neo by 20
			for (int i = 0; i < pills.length - 1; i += 2) {
				if (prevNode.myLoc.x == Integer.parseInt(pills[i])
						&& prevNode.myLoc.y == Integer.parseInt(pills[i + 1])) {
					// replace the x and y with negatives so that when we combine the string again
					// we can know that this is not valid
					pills[i] = "-1";
					pills[i + 1] = "-1";
					break;
				}
			}

			if (neoD < 20) {
				neoD = 0;
			} else {
				neoD -= 20;
			}

			for (int i = 0; i < hostages.size(); i++) {
				// each entry in the arraylist is a string with commas splitting the x and y and
				// damage
				String[] splitted2 = hostages.get(i).split(",");
				// the third element is the damage
				// decrement by 22 because we already incremented by 2 at the beginning of the
				// method
				int oldDamage2 = Integer.parseInt(splitted2[2]);
				if (oldDamage2 < 20) {
					oldDamage2 = 0;
				} else {
					oldDamage2 -= 20;
				}
				// set the new damage
				if (oldDamage2 < 0) {
					hostages.set(i, splitted2[0] + "," + splitted2[1] + "," + oldDamage2);
					// check that is cannot reach below 0
				}
			}
			// Decrement Neo damage by 20
			break;
		case ("Carry"):
			// update grid method above
			int cAllowed = Integer.parseInt(splitted[1]);
			if (carried.size() + 1 < cAllowed) {
				// increment c by 1
				for (int i = 0; i < hostages.size() - 1; i += 3) {
					if (prevNode.myLoc.x == Integer.parseInt(hostages.get(i))
							&& prevNode.myLoc.y == Integer.parseInt(hostages.get(i + 1))) {
						// replace the x and y with negatives so that when we combine the string again
						// we can know that this is not valid

						// set the location to that of neo
						hostages.remove(i + 1);
						hostages.remove(i);
						carried.add(Integer.parseInt(hostages.remove(i + 2)));
						break;
					}
				}
			}

			break;
		case ("Drop"):
			// Reset carried
			prevNode.carried = new ArrayList<Integer>();
			carried = new ArrayList<Integer>();
			break;
		case ("Down"):
			System.out.println("here2");
			// nothing changes in the grid only the overall hostage damage increases by 2
			// and this is already handled above
			newLocation = moveTo;

			break;
		case ("Up"):
			// nothing changes in the grid only the overall hostage damage increases by 2
			// and this is already handled above
			newLocation = moveTo;

			break;
		case ("Right"):
			// nothing changes in the grid only the overall hostage damage increases by 2
			// and this is already handled above
			newLocation = moveTo;

			break;
		case ("Left"):
			// nothing changes in the grid only the overall hostage damage increases by 2
			// and this is already handled above
			newLocation = moveTo;

			break;
		case ("Fly"):
			// change hostages carried location
			// nothing changes in the grid only the overall hostage damage increases by 2
			// and this is already handled above
			newLocation = moveTo;
			break;
		default:
			break;
		}

		// then we need to form the new grid

		for (int i = 0; i < agents.length - 1; i += 2) {
			if (agents[i] == "-1") {
				// killed
				continue;
			} else {
				result += agents[i] + "," + agents[i + 1];
				if (i < agents.length - 3) {
					result += ",";
				}
			}
		}
		result += ";";

		for (int i = 0; i < pills.length - 1; i += 2) {
			if (pills[i] == "-1") {
				// taken
				continue;
			} else {

				result += pills[i] + "," + pills[i + 1];
				if (i < pills.length - 3) {
					result += ",";
				}
			}
		}

		result += ";" + pads + ";";

		for (int i = 0; i < hostages.size() - 2; i += 3) {
			result += hostages.get(i) + "," + hostages.get(i + 1) + "," + hostages.get(i + 2);
			if (i < hostages.size() - 4) {
				result += ",";
			}
		}

		// add the mutant hostages to the hostages category in the grid
		for (int i = 0; i < mutantHostages.size() - 1; i += 2) {
			result += mutantHostages.get(i) + "," + mutantHostages.get(i + 1) + "," + "100";
			if (i < mutantHostages.size() - 3) {
				result += ",";
			}
		}

		TreeNode resNode = new TreeNode(prevNode, prevNodes, newLocation, neoD, result, kills, deaths, actionDetails[0],
				prevNode.depth + 1, 0, carried);
		System.out.println(result + "griiiid");
		return resNode;

	}

	// raz3yn el depth wl costs
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:494)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-11-15 23:13:13.058
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:494)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-11-15 23:13:13.058
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:494)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-11-15 23:13:13.153
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package code;

import java.util.ArrayList;

import code.Location;
import code.TreeNode;
import code.Queue.*;

public abstract class GeneralSearch {

	// habdyn el cost wl depth
	// check game over

	public static String generalSearch(String grid, String strategy, boolean visualize) {
		String result = "";
		//initialize everything as this is the start
		ArrayList<TreeNode> prevNodes = new ArrayList<TreeNode>();
		ArrayList<PreNode> preNodes = new ArrayList<PreNode>();
		String[] splitted = grid.split(";");
		//get Neo's starting position
		String[] preNeo = splitted[2].split(",");
		Location neo = new Location(Integer.parseInt(preNeo[0]), Integer.parseInt(preNeo[1]));
		//array to store the damages of the carried hostages
		//also used to keep track of the number of carried hostages
		ArrayList<Integer> carried = new ArrayList<Integer>();
		
		// create initial starting node
		##TO-DO
		// reminder: cost
		TreeNode start = new TreeNode(null, prevNodes, neo, 0, grid, 0, 0, "Start", 0, 0, carried);
		PreNode startPre = new PreNode("Start", neo, start, 0);

		prevNodes.add(start);

		// create the queue for search
		Queue queue;
		switch (strategy) {
		case ("DF"):
			queue = new DFQueue();
			break;
		default:
			//temporary
			queue = new DFQueue();
			break;
		}

		// get the possible actions for the starting node
		ArrayList<String> possibleActions = getPossibleActions(neo, grid);
		printArr(possibleActions);
		for (int i = 0; i < possibleActions.size(); i++) {
			String[] pa = possibleActions.get(i).split(",");
			Location affected = new Location(Integer.parseInt(pa[1]), Integer.parseInt(pa[2]));
			PreNode pn = new PreNode(pa[0], affected, start, 0);
			queue.enqueue(pn);
		}

		queue.display();

		boolean failed = false;
		String finalGrid = "";

		while (!queue.queue.isEmpty()) {
			System.out.println("habd2 ml awl");
			PreNode frontPreNode = queue.dequeue();
			boolean repeated = false;
			/*
			for (int i = 0 ; i < prevNodes.size(); i++) {
				if(frontPreNode.prevNode.myLoc.x == prevNodes.get(i).myLoc.x && 
						frontPreNode.prevNode.myLoc.y == prevNodes.get(i).myLoc.y) {
					if (!(queue.queue.isEmpty())) {
					frontPreNode = queue.dequeue();
					}
				}
			}
			*/
			TreeNode frontTreeNode = update(
					frontPreNode.action + "," + frontPreNode.affectedCell.x + "," + frontPreNode.affectedCell.y,
					frontPreNode.prevNode, prevNodes);
			for (int i = 0 ; i < prevNodes.size(); i++) {
				if(frontTreeNode.myLoc.x == prevNodes.get(i).myLoc.x && 
						frontTreeNode.myLoc.y == prevNodes.get(i).myLoc.y &&
						compareGrids(frontTreeNode.grid, prevNodes.get(i).grid) == true) {
					//ignore this path
					repeated = true;
					break;
					//if (!(queue.queue.isEmpty())) {
					//frontPreNode = queue.dequeue();
					//}
				}
			}
			if (repeated == true) {
				System.out.println("msh hakml");
				continue;
			}
			System.out.println("tamam");
			prevNodes.add(frontTreeNode);
			possibleActions = getPossibleActions(frontTreeNode.myLoc, frontTreeNode.grid);
			
			for (int i = 0; i < possibleActions.size(); i++) {
				String[] pa = possibleActions.get(i).split(",");
				//System.out.println(possibleActions.get(i));
				Location affected = new Location(Integer.parseInt(pa[1]), Integer.parseInt(pa[2]));
				PreNode pn = new PreNode(pa[0], affected, frontTreeNode, 0);
				queue.enqueue(pn);
				//queue.display();
			}
			boolean goal = isItGoal(frontTreeNode);
			System.out.println(frontPreNode.action);
			queue.display();
			if (queue.queue.isEmpty()) {
				failed = true;
			}
			
			if (frontTreeNode.neoDamage >= 100) {
				return "fail";
			}
			
			finalGrid = frontTreeNode.grid;

		}
		return finalGrid;
	}
	
	//this might be tricky if we needed the damages as a difference
	public static boolean compareGrids(String grid1, String grid2) {
		boolean similar = false;
		//if same number of agents and hostages and pills then similar
		String[] splitted1 = grid1.split(";");
		String[] splitted2 = grid2.split(";");
		String[] agents1 = splitted1[4].split(",");
		String[] agents2 = splitted2[4].split(",");
		if (agents1.length == agents2.length) {
			//check pills
			String[] pills1 = splitted1[5].split(",");
			String[] pills2 = splitted2[5].split(",");
			if (pills1.length == pills2.length) {
				//check hostages
				String[] hos1;
				if (splitted1.length <= 7 ) {
					//no more hostages
					hos1 = new String[0];
				}else {
					hos1 = splitted1[7].split(",");
				}
				
				String[] hos2;
				if (splitted2.length <= 7 ) {
					//no more hostages
					hos2 = new String[0];
				}else {
					hos2 = splitted2[7].split(",");
				}
				if (hos1.length ==hos2.length) {
					similar = true;
				}else {
					similar = false;
				}
			}else {
				similar = false;
			}
		}else {
			similar = false;
		}
		return similar;
	}

	// goal test
	public static boolean isItGoal(TreeNode n) {

		boolean goal = false;
		String grid = n.grid;
		ArrayList<String> hostages = getHostages(grid);
		ArrayList<String> mutantHostages = getMutantHostages(grid);
		if (mutantHostages.size() == 0 && hostages.size() == 0) {
			goal = true;
		}
		return goal;

	}

	// method to print the content of any array
	public static void printArr(ArrayList<String> arr) {
		for (int i = 0; i < arr.size(); i++) {
			System.out.println(arr.get(i));
		}
		System.out.println(" ");
	}

	// method to fill the hostages and damage
	public static ArrayList<String> getHostages(String grid) {
		ArrayList<String> result = new ArrayList<String>();
		String[] splitted = grid.split(";");
		// System.out.println(splitted.length);
		// array that contains locations of all the hostages
		String[] hostages;
		if (splitted.length <= 7) {
			hostages = new String[0];
		}else {
			hostages = splitted[7].split(",");
		}

		for (int i = 0; i < hostages.length - 1; i += 3) {
			// store the location and damage in a string
			String temp = "";
			// check the damage to know if mutant or alive
			// if mutant then skip this iteration
			if (Integer.parseInt(hostages[i + 2]) < 100) {
				temp += hostages[i] + "," + hostages[i + 1] + "," + hostages[i + 2];
				result.add(temp);
			}

		}

		return result;
	}

	// method to fill the mutant hostages
	public static ArrayList<String> getMutantHostages(String grid) {
		ArrayList<String> result = new ArrayList<String>();

		String[] splitted = grid.split(";");
		// array that contains locations of all the hostages
		String[] hostages;
		if (splitted.length <= 7) {
			hostages = new String[0];
		}else {
			hostages = splitted[7].split(",");
		}

		for (int i = 0; i < hostages.length - 1; i += 3) {
			// store the location in a string
			String temp = "";
			// check the damage to know if mutant or alive
			// if alive then skip this iteration
			if (Integer.parseInt(hostages[i + 2]) >= 100) {
				// add only the location since we do not need the damage
				temp += hostages[i] + "," + hostages[i + 1];
				result.add(temp);
			}

		}

		return result;
	}

	// method to get the content of the given cell and useful information about
	// content of cell
	// can be used to determine the surroundings of the current cell
	public static String whatInCell(int x, int y, String grid) {
		String result = "";
		// split the grid at ; to extract different categories in the grid
		String[] splitted = grid.split(";");
		// array that consists of (x,y) of the telephone booth
		String[] telephone = splitted[3].split(",");
		// array that contains locations of all the agents
		String[] agents = splitted[4].split(",");
		// array that contains locations of all pills
		String[] pills = splitted[5].split(",");
		// array that contains locations of all the pads
		// this array is always divisible by 4 since the pad comes in pairs
		// (startx, starty, finishx, finishy)
		String[] pads = splitted[6].split(",");
		// array that contains locations of all the hostages
		String[] hostages;
		if (splitted.length <=7) {
			hostages = new String[0];
		}else {
			hostages = splitted[7].split(",");
		}

		if (x == Integer.parseInt(telephone[0]) && y == Integer.parseInt(telephone[1])) {
			result = "telephone;" + x + ";" + y;
			return result;
		}
		for (int i = 0; i < agents.length - 1; i += 2) {
			if (x == Integer.parseInt(agents[i]) && y == Integer.parseInt(agents[i + 1])) {
				result = "agent;" + x + ";" + y;
				return result;
			}
		}
		for (int i = 0; i < pills.length - 1; i += 2) {
			if (x == Integer.parseInt(pills[i]) && y == Integer.parseInt(pills[i + 1])) {
				result = "pill;" + x + ";" + y;
				return result;
			}
		}
		for (int i = 0; i < pads.length - 1; i += 2) {
			if (x == Integer.parseInt(pads[i]) && y == Integer.parseInt(pads[i + 1])) {
				result = "pad;" + x + ";" + y;
				if ((i / 2) % 2 == 0) {
					result += ";" + pads[i + 2] + ";" + pads[i + 3];
				} else {
					result += ";" + pads[i - 2] + ";" + pads[i - 1];
				}
				// return pair of pads attached together
				return result;
			}
		}
		for (int i = 0; i < hostages.length - 1; i += 3) {
			if (x == Integer.parseInt(hostages[i]) && y == Integer.parseInt(hostages[i + 1])) {
				result = "hostage;" + x + ";" + y + ";" + hostages[i + 2];
				return result;
			}
		}

		return result;
	}

	// method to detect where can I move
	public static ArrayList<String> whereCanIMove(Location current, String grid) {
		ArrayList<String> result = new ArrayList<String>();
		// check all possible directions
		String[] splitted = grid.split(";");
		String[] dimensions = splitted[0].split(",");
		int cols = Integer.parseInt(dimensions[1]);
		int rows = Integer.parseInt(dimensions[0]);
		boolean up = false;
		boolean right = false;
		boolean down = false;
		boolean left = false;
		// check if I can go left
		if (current.y > 0) {
			// check if there is an agent or a mutant agent
			String upCellComponent = whatInCell(current.x, current.y - 1, grid);
			if (!(upCellComponent.contains("agent"))) {
				// check if there is a mutant hostage
				if (upCellComponent.contains("hostage")) {
					// check the damage to know if it is mutant
					String[] hos = upCellComponent.split(";");
					if (Integer.parseInt(hos[3]) < 100) {
						left = true;
					} else {
						result.add("KillLeft");
					}
				}
				left = true;
			} else {
				result.add("KillLeft");
			}
		}
		// check if I can go down
		if (current.x < rows - 1) {
			// check if there is an agent or a mutant agent
			String rightCellComponent = whatInCell(current.x + 1, current.y, grid);
			if (!(rightCellComponent.contains("agent"))) {
				// check if there is a mutant hostage
				if (rightCellComponent.contains("hostage")) {
					// System.out.println(rightCellComponent);
					// check the damage to know if it is mutant
					String[] hos = rightCellComponent.split(";");
					if (Integer.parseInt(hos[3]) < 100) {
						down = true;
					} else {
						result.add("KillDown");
					}
				}
				down = true;
			} else {
				result.add("KillDown");
			}
		}
		// check if I can go right
		if (current.y < cols - 1) {
			// check if there is an agent or a mutant agent
			String downCellComponent = whatInCell(current.x, current.y + 1, grid);
			if (!(downCellComponent.contains("agent"))) {
				// check if there is a mutant hostage
				if (downCellComponent.contains("hostage")) {
					// check the damage to know if it is mutant
					String[] hos = downCellComponent.split(";");
					if (Integer.parseInt(hos[3]) < 100) {
						right = true;
					} else {
						result.add("KillRight");
					}
				}
				right = true;
			} else {
				result.add("KillRight");
			}
		}
		// check if I can go Up
		if (current.x > 0) {
			// check if there is an agent or a mutant agent
			String leftCellComponent = whatInCell(current.x - 1, current.y, grid);
			if (!(leftCellComponent.contains("agent"))) {
				// check if there is a mutant hostage
				if (leftCellComponent.contains("hostage")) {
					// check the damage to know if it is mutant
					String[] hos = leftCellComponent.split(";");
					if (Integer.parseInt(hos[3]) < 100) {
						up = true;
					} else {
						result.add("KillUp");
					}
				}
				up = true;
			} else {
				result.add("KillUp");
			}
		}
		if (up) {
			result.add("Up");
		}
		if (right) {
			result.add("Right");
		}
		if (down) {
			result.add("Down");
		}
		if (left) {
			result.add("Left");
		}

		return result;
	}

	// method to detect possible actions and insert in queue
	// this method returns array of strings of the following format
	// "ActionName", "affectedLocation"
	public static ArrayList<String> getPossibleActions(Location current, String grid) {
		ArrayList<String> result = new ArrayList<String>();
		// check the current cell components
		String currentCellComponent = whatInCell(current.x, current.y, grid);
		if (currentCellComponent.contains("pill")) {
			// either take it or leave it
			result.add("Pill," + current.x + "," + current.y);
		}
		if (currentCellComponent.contains("hostage")) {
			// cannot be a mutant hostage because we do not add this option to happen during
			// movement
			result.add("Carry," + current.x + "," + current.y);
		}
		if (currentCellComponent.contains("pad")) {
			// get the go-to pad from the string
			String[] pillData = currentCellComponent.split(";");
			// we know that the current cell is the first pad in the string so ignore it
			int fx = Integer.parseInt(pillData[3]);
			int fy = Integer.parseInt(pillData[4]);
			result.add("Fly," + fx + "," + fy);
		}
		if (currentCellComponent.contains("telephone")) {
			// you can either drop or leave
			// check before drop if there is a hostage to drop
			result.add("Drop," + current.x + "," + current.y);
		}

		// get the possible movements
		ArrayList<String> movements = whereCanIMove(current, grid);
		if (!(movements.isEmpty())) {
			for (int i = 0; i < movements.size(); i++) {
				if (movements.get(i) == "Up") {
					result.add("Up," + (current.x - 1) + "," + current.y);
				} else if (movements.get(i) == "Right") {
					result.add("Right," + current.x + "," + (current.y + 1));
				} else if (movements.get(i) == "Down") {
					result.add("Down," + (current.x + 1) + "," + current.y);
				} else if (movements.get(i) == "Left") {
					result.add("Left," + current.x + "," + (current.y - 1));
				} else if (movements.get(i) == "KillUp") {
					result.add("Kill," + (current.x - 1) + "," + current.y);
				} else if (movements.get(i) == "KillRight") {
					result.add("Kill," + current.x + "," + (current.y + 1));
				} else if (movements.get(i) == "KillDown") {
					result.add("Kill," + (current.x + 1) + "," + current.y);
				} else if (movements.get(i) == "KillLeft") {
					result.add("Kill," + current.x + "," + (current.y - 1));
				}

			}
		}
		return result;

	}

	// reminder: make the location of the carried hostage should be that of neo
	// reminder: adjust damage abl maymot law pill
	// reminder e3mly el ba2y
	// 5aly update ta5od el node

	// updates everything needed according to the action taken
	// I think it should return the new grid string
	public static TreeNode update(String action, TreeNode prevNode, ArrayList<TreeNode> prevNodes) {
		// we assume that Neo starts with 0 damage
		// update damage of all hostages

		// resultant grid
		String result = "";
		// split the grid at ; to extract different categories in the grid
		String[] splitted = prevNode.grid.split(";");
		// since the dimensions and neo's initial position and TB position are constant,
		// append to result
		result += splitted[0] + ";" + splitted[1] + ";" + splitted[2] + ";" + splitted[3] + ";";

		// array that contains locations of all the agents
		String[] agents = splitted[4].split(",");
		// array that contains the locations of all mutant hostages
		ArrayList<String> mutantHostages = getMutantHostages(prevNode.grid);
		// array that contains locations of all the pills
		String[] pills = splitted[5].split(",");
		// array that contains locations of all the pads
		// this array is always divisible by 4 since the pad comes in pairs
		// (startx, starty, finishx, finishy)
		String pads = splitted[6];
		// array that contains locations of all the hostages
		// get this array from the method getHostages to avoid getting mutant hostages
		// from the grid string
		ArrayList<String> hostages = getHostages(prevNode.grid);
		ArrayList<Integer> carried = prevNode.carried;
		int deaths = prevNode.deaths;

		for (int i = 0; i < hostages.size(); i++) {
			// each entry in the arraylist is a string with commas splitting the x and y and
			// damage
			String[] splittedHos = hostages.get(i).split(",");
			// the third element is the damage
			int oldDamage = Integer.parseInt(splittedHos[2]) + 2;
			if (action == "Pill") {
				oldDamage -= 2;
			}
			// set the new damage
			hostages.set(i, splittedHos[0] + "," + splittedHos[1] + "," + oldDamage);
			// check if it reached 100
			if (oldDamage >= 100) {
				// remove this hostage from the hostages array and add it to mutant
				mutantHostages.add(hostages.get(i));
				hostages.remove(i);
				// update the grid by adding the new hostage damage
				// as we do not add a different category in the grid string to represent the
				// mutant hostages
				// we rely on having the damage of 100 or greater to reflect this change
			}
		}
		for (int i = 0; i < carried.size(); i++) {
			int d = carried.get(i);
			if (action == "Pill") {
				if (d < 100) {
					if (d < 20) {
						carried.set(i, 0);
					} else {
						carried.set(i, d - 20);
					}

				}
			} else if (d < 100) {
				carried.set(i, d + 2);
				if (carried.get(i) >= 100) {
					deaths++;
				}
			}

		}
		int kills = prevNode.kills;
		int neoD = prevNode.neoDamage;
		Location newLocation = prevNode.myLoc;

		// get the affected location from action
		String[] actionDetails = action.split(",");
		Location moveTo = new Location(Integer.parseInt(actionDetails[1]), Integer.parseInt(actionDetails[2]));

		// check the action performed and accordingly update the grid or damage
		switch (actionDetails[0]) {
		case ("Kill"):
			System.out.println("hamoot" + (prevNode.myLoc.y == Integer.parseInt(agents[1])));
			// update grid by removing the killed agent or mutant hostage
			// increment Neo's damage by 20
			kills++;
			neoD += 20;
			// increment the number of killings by 1 if it is an agent
			for (int i = 0; i < agents.length - 1; i += 2) {
				if (Integer.parseInt(actionDetails[1]) == Integer.parseInt(agents[i])
						&& Integer.parseInt(actionDetails[2]) == Integer.parseInt(agents[i + 1])) {
					
					// replace the x and y with negatives so that when we combine the string again
					// we can know that this is not valid
					
					agents[i] = "-1";
					agents[i + 1] = "-1";
					break;
				}
			}
			for (int i = 0; i < mutantHostages.size() - 1; i += 2) {
				if (prevNode.myLoc.x == Integer.parseInt(mutantHostages.get(i))
						&& prevNode.myLoc.y == Integer.parseInt(mutantHostages.get(i + 1))) {
					// remove the mutant hostages from the arraylist
					mutantHostages.remove(i + 1);
					mutantHostages.remove(i);
					// also remove the hostage from the grid string
					break;
				}
			}

			break;
		case ("Pill"):
			// update grid method above
			// Decrement the damages of hostages and Neo by 20
			for (int i = 0; i < pills.length - 1; i += 2) {
				if (prevNode.myLoc.x == Integer.parseInt(pills[i])
						&& prevNode.myLoc.y == Integer.parseInt(pills[i + 1])) {
					// replace the x and y with negatives so that when we combine the string again
					// we can know that this is not valid
					pills[i] = "-1";
					pills[i + 1] = "-1";
					break;
				}
			}

			if (neoD < 20) {
				neoD = 0;
			} else {
				neoD -= 20;
			}

			for (int i = 0; i < hostages.size(); i++) {
				// each entry in the arraylist is a string with commas splitting the x and y and
				// damage
				String[] splitted2 = hostages.get(i).split(",");
				// the third element is the damage
				// decrement by 22 because we already incremented by 2 at the beginning of the
				// method
				int oldDamage2 = Integer.parseInt(splitted2[2]);
				if (oldDamage2 < 20) {
					oldDamage2 = 0;
				} else {
					oldDamage2 -= 20;
				}
				// set the new damage
				if (oldDamage2 < 0) {
					hostages.set(i, splitted2[0] + "," + splitted2[1] + "," + oldDamage2);
					// check that is cannot reach below 0
				}
			}
			// Decrement Neo damage by 20
			break;
		case ("Carry"):
			// update grid method above
			int cAllowed = Integer.parseInt(splitted[1]);
			if (carried.size() + 1 < cAllowed) {
				// increment c by 1
				for (int i = 0; i < hostages.size() - 1; i += 3) {
					if (prevNode.myLoc.x == Integer.parseInt(hostages.get(i))
							&& prevNode.myLoc.y == Integer.parseInt(hostages.get(i + 1))) {
						// replace the x and y with negatives so that when we combine the string again
						// we can know that this is not valid

						// set the location to that of neo
						hostages.remove(i + 1);
						hostages.remove(i);
						carried.add(Integer.parseInt(hostages.remove(i + 2)));
						break;
					}
				}
			}

			break;
		case ("Drop"):
			// Reset carried
			prevNode.carried = new ArrayList<Integer>();
			carried = new ArrayList<Integer>();
			break;
		case ("Down"):
			System.out.println("here2");
			// nothing changes in the grid only the overall hostage damage increases by 2
			// and this is already handled above
			newLocation = moveTo;

			break;
		case ("Up"):
			// nothing changes in the grid only the overall hostage damage increases by 2
			// and this is already handled above
			newLocation = moveTo;

			break;
		case ("Right"):
			// nothing changes in the grid only the overall hostage damage increases by 2
			// and this is already handled above
			newLocation = moveTo;

			break;
		case ("Left"):
			// nothing changes in the grid only the overall hostage damage increases by 2
			// and this is already handled above
			newLocation = moveTo;

			break;
		case ("Fly"):
			// change hostages carried location
			// nothing changes in the grid only the overall hostage damage increases by 2
			// and this is already handled above
			newLocation = moveTo;
			break;
		default:
			break;
		}

		// then we need to form the new grid

		for (int i = 0; i < agents.length - 1; i += 2) {
			if (agents[i] == "-1") {
				// killed
				continue;
			} else {
				result += agents[i] + "," + agents[i + 1];
				if (i < agents.length - 3) {
					result += ",";
				}
			}
		}
		result += ";";

		for (int i = 0; i < pills.length - 1; i += 2) {
			if (pills[i] == "-1") {
				// taken
				continue;
			} else {

				result += pills[i] + "," + pills[i + 1];
				if (i < pills.length - 3) {
					result += ",";
				}
			}
		}

		result += ";" + pads + ";";

		for (int i = 0; i < hostages.size() - 2; i += 3) {
			result += hostages.get(i) + "," + hostages.get(i + 1) + "," + hostages.get(i + 2);
			if (i < hostages.size() - 4) {
				result += ",";
			}
		}

		// add the mutant hostages to the hostages category in the grid
		for (int i = 0; i < mutantHostages.size() - 1; i += 2) {
			result += mutantHostages.get(i) + "," + mutantHostages.get(i + 1) + "," + "100";
			if (i < mutantHostages.size() - 3) {
				result += ",";
			}
		}

		TreeNode resNode = new TreeNode(prevNode, prevNodes, newLocation, neoD, result, kills, deaths, actionDetails[0],
				prevNode.depth + 1, 0, carried);
		System.out.println(result + "griiiid");
		return resNode;

	}

	// raz3yn el depth wl costs
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-11-15 23:13:13.155
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-11-15 23:13:13.155
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-11-15 23:13:15.126
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package code;

import java.util.ArrayList;

import code.Location;
import code.TreeNode;
import code.Queue.*;

public abstract class GeneralSearch {

	// habdyn el cost wl depth
	// check game over

	public static String generalSearch(String grid, String strategy, boolean visualize) {
		String result = "";
		//initialize everything as this is the start
		ArrayList<TreeNode> prevNodes = new ArrayList<TreeNode>();
		ArrayList<PreNode> preNodes = new ArrayList<PreNode>();
		String[] splitted = grid.split(";");
		//get Neo's starting position
		String[] preNeo = splitted[2].split(",");
		Location neo = new Location(Integer.parseInt(preNeo[0]), Integer.parseInt(preNeo[1]));
		//array to store the damages of the carried hostages
		//also used to keep track of the number of carried hostages
		ArrayList<Integer> carried = new ArrayList<Integer>();
		
		// create initial starting node
		##TO-DO
		// reminder: cost
		TreeNode start = new TreeNode(null, prevNodes, neo, 0, grid, 0, 0, "Start", 0, 0, carried);
		PreNode startPre = new PreNode("Start", neo, start, 0);

		prevNodes.add(start);

		// create the queue for search
		Queue queue;
		switch (strategy) {
		case ("DF"):
			queue = new DFQueue();
			break;
		default:
			//temporary
			queue = new DFQueue();
			break;
		}

		// get the possible actions for the starting node
		ArrayList<String> possibleActions = getPossibleActions(neo, grid);
		printArr(possibleActions);
		for (int i = 0; i < possibleActions.size(); i++) {
			String[] pa = possibleActions.get(i).split(",");
			Location affected = new Location(Integer.parseInt(pa[1]), Integer.parseInt(pa[2]));
			PreNode pn = new PreNode(pa[0], affected, start, 0);
			queue.enqueue(pn);
		}

		queue.display();

		boolean failed = false;
		String finalGrid = "";

		while (!queue.queue.isEmpty()) {
			System.out.println("habd2 ml awl");
			PreNode frontPreNode = queue.dequeue();
			boolean repeated = false;
			/*
			for (int i = 0 ; i < prevNodes.size(); i++) {
				if(frontPreNode.prevNode.myLoc.x == prevNodes.get(i).myLoc.x && 
						frontPreNode.prevNode.myLoc.y == prevNodes.get(i).myLoc.y) {
					if (!(queue.queue.isEmpty())) {
					frontPreNode = queue.dequeue();
					}
				}
			}
			*/
			TreeNode frontTreeNode = update(
					frontPreNode.action + "," + frontPreNode.affectedCell.x + "," + frontPreNode.affectedCell.y,
					frontPreNode.prevNode, prevNodes);
			for (int i = 0 ; i < prevNodes.size(); i++) {
				if(frontTreeNode.myLoc.x == prevNodes.get(i).myLoc.x && 
						frontTreeNode.myLoc.y == prevNodes.get(i).myLoc.y &&
						compareGrids(frontTreeNode.grid, prevNodes.get(i).grid) == true) {
					//ignore this path
					repeated = true;
					break;
					//if (!(queue.queue.isEmpty())) {
					//frontPreNode = queue.dequeue();
					//}
				}
			}
			if (repeated == true) {
				System.out.println("msh hakml");
				continue;
			}
			System.out.println("tamam");
			prevNodes.add(frontTreeNode);
			possibleActions = getPossibleActions(frontTreeNode.myLoc, frontTreeNode.grid);
			
			for (int i = 0; i < possibleActions.size(); i++) {
				String[] pa = possibleActions.get(i).split(",");
				//System.out.println(possibleActions.get(i));
				Location affected = new Location(Integer.parseInt(pa[1]), Integer.parseInt(pa[2]));
				PreNode pn = new PreNode(pa[0], affected, frontTreeNode, 0);
				queue.enqueue(pn);
				//queue.display();
			}
			boolean goal = isItGoal(frontTreeNode);
			System.out.println(frontPreNode.action);
			queue.display();
			if (queue.queue.isEmpty()) {
				failed = true;
			}
			
			if (frontTreeNode.neoDamage >= 100) {
				return "fail";
			}
			
			finalGrid = frontTreeNode.grid;

		}
		return finalGrid;
	}
	
	//this might be tricky if we needed the damages as a difference
	public static boolean compareGrids(String grid1, String grid2) {
		boolean similar = false;
		//if same number of agents and hostages and pills then similar
		String[] splitted1 = grid1.split(";");
		String[] splitted2 = grid2.split(";");
		String[] agents1 = splitted1[4].split(",");
		String[] agents2 = splitted2[4].split(",");
		if (agents1.length == agents2.length) {
			//check pills
			String[] pills1 = splitted1[5].split(",");
			String[] pills2 = splitted2[5].split(",");
			if (pills1.length == pills2.length) {
				//check hostages
				String[] hos1;
				if (splitted1.length <= 7 ) {
					//no more hostages
					hos1 = new String[0];
				}else {
					hos1 = splitted1[7].split(",");
				}
				
				String[] hos2;
				if (splitted2.length <= 7 ) {
					//no more hostages
					hos2 = new String[0];
				}else {
					hos2 = splitted2[7].split(",");
				}
				if (hos1.length ==hos2.length) {
					similar = true;
				}else {
					similar = false;
				}
			}else {
				similar = false;
			}
		}else {
			similar = false;
		}
		return similar;
	}

	// goal test
	public static boolean isItGoal(TreeNode n) {

		boolean goal = false;
		String grid = n.grid;
		ArrayList<String> hostages = getHostages(grid);
		ArrayList<String> mutantHostages = getMutantHostages(grid);
		if (mutantHostages.size() == 0 && hostages.size() == 0) {
			goal = true;
		}
		return goal;

	}

	// method to print the content of any array
	public static void printArr(ArrayList<String> arr) {
		for (int i = 0; i < arr.size(); i++) {
			System.out.println(arr.get(i));
		}
		System.out.println(" ");
	}

	// method to fill the hostages and damage
	public static ArrayList<String> getHostages(String grid) {
		ArrayList<String> result = new ArrayList<String>();
		String[] splitted = grid.split(";");
		// System.out.println(splitted.length);
		// array that contains locations of all the hostages
		String[] hostages;
		if (splitted.length <= 7) {
			hostages = new String[0];
		}else {
			hostages = splitted[7].split(",");
		}

		for (int i = 0; i < hostages.length - 1; i += 3) {
			// store the location and damage in a string
			String temp = "";
			// check the damage to know if mutant or alive
			// if mutant then skip this iteration
			if (Integer.parseInt(hostages[i + 2]) < 100) {
				temp += hostages[i] + "," + hostages[i + 1] + "," + hostages[i + 2];
				result.add(temp);
			}

		}

		return result;
	}

	// method to fill the mutant hostages
	public static ArrayList<String> getMutantHostages(String grid) {
		ArrayList<String> result = new ArrayList<String>();

		String[] splitted = grid.split(";");
		// array that contains locations of all the hostages
		String[] hostages;
		if (splitted.length <= 7) {
			hostages = new String[0];
		}else {
			hostages = splitted[7].split(",");
		}

		for (int i = 0; i < hostages.length - 1; i += 3) {
			// store the location in a string
			String temp = "";
			// check the damage to know if mutant or alive
			// if alive then skip this iteration
			if (Integer.parseInt(hostages[i + 2]) >= 100) {
				// add only the location since we do not need the damage
				temp += hostages[i] + "," + hostages[i + 1];
				result.add(temp);
			}

		}

		return result;
	}

	// method to get the content of the given cell and useful information about
	// content of cell
	// can be used to determine the surroundings of the current cell
	public static String whatInCell(int x, int y, String grid) {
		String result = "";
		// split the grid at ; to extract different categories in the grid
		String[] splitted = grid.split(";");
		// array that consists of (x,y) of the telephone booth
		String[] telephone = splitted[3].split(",");
		// array that contains locations of all the agents
		String[] agents = splitted[4].split(",");
		// array that contains locations of all pills
		String[] pills = splitted[5].split(",");
		// array that contains locations of all the pads
		// this array is always divisible by 4 since the pad comes in pairs
		// (startx, starty, finishx, finishy)
		String[] pads = splitted[6].split(",");
		// array that contains locations of all the hostages
		String[] hostages;
		if (splitted.length <=7) {
			hostages = new String[0];
		}else {
			hostages = splitted[7].split(",");
		}

		if (x == Integer.parseInt(telephone[0]) && y == Integer.parseInt(telephone[1])) {
			result = "telephone;" + x + ";" + y;
			return result;
		}
		for (int i = 0; i < agents.length - 1; i += 2) {
			if (x == Integer.parseInt(agents[i]) && y == Integer.parseInt(agents[i + 1])) {
				result = "agent;" + x + ";" + y;
				return result;
			}
		}
		for (int i = 0; i < pills.length - 1; i += 2) {
			if (x == Integer.parseInt(pills[i]) && y == Integer.parseInt(pills[i + 1])) {
				result = "pill;" + x + ";" + y;
				return result;
			}
		}
		for (int i = 0; i < pads.length - 1; i += 2) {
			if (x == Integer.parseInt(pads[i]) && y == Integer.parseInt(pads[i + 1])) {
				result = "pad;" + x + ";" + y;
				if ((i / 2) % 2 == 0) {
					result += ";" + pads[i + 2] + ";" + pads[i + 3];
				} else {
					result += ";" + pads[i - 2] + ";" + pads[i - 1];
				}
				// return pair of pads attached together
				return result;
			}
		}
		for (int i = 0; i < hostages.length - 1; i += 3) {
			if (x == Integer.parseInt(hostages[i]) && y == Integer.parseInt(hostages[i + 1])) {
				result = "hostage;" + x + ";" + y + ";" + hostages[i + 2];
				return result;
			}
		}

		return result;
	}

	// method to detect where can I move
	public static ArrayList<String> whereCanIMove(Location current, String grid) {
		ArrayList<String> result = new ArrayList<String>();
		// check all possible directions
		String[] splitted = grid.split(";");
		String[] dimensions = splitted[0].split(",");
		int cols = Integer.parseInt(dimensions[1]);
		int rows = Integer.parseInt(dimensions[0]);
		boolean up = false;
		boolean right = false;
		boolean down = false;
		boolean left = false;
		// check if I can go left
		if (current.y > 0) {
			// check if there is an agent or a mutant agent
			String upCellComponent = whatInCell(current.x, current.y - 1, grid);
			if (!(upCellComponent.contains("agent"))) {
				// check if there is a mutant hostage
				if (upCellComponent.contains("hostage")) {
					// check the damage to know if it is mutant
					String[] hos = upCellComponent.split(";");
					if (Integer.parseInt(hos[3]) < 100) {
						left = true;
					} else {
						result.add("KillLeft");
					}
				}
				left = true;
			} else {
				result.add("KillLeft");
			}
		}
		// check if I can go down
		if (current.x < rows - 1) {
			// check if there is an agent or a mutant agent
			String rightCellComponent = whatInCell(current.x + 1, current.y, grid);
			if (!(rightCellComponent.contains("agent"))) {
				// check if there is a mutant hostage
				if (rightCellComponent.contains("hostage")) {
					// System.out.println(rightCellComponent);
					// check the damage to know if it is mutant
					String[] hos = rightCellComponent.split(";");
					if (Integer.parseInt(hos[3]) < 100) {
						down = true;
					} else {
						result.add("KillDown");
					}
				}
				down = true;
			} else {
				result.add("KillDown");
			}
		}
		// check if I can go right
		if (current.y < cols - 1) {
			// check if there is an agent or a mutant agent
			String downCellComponent = whatInCell(current.x, current.y + 1, grid);
			if (!(downCellComponent.contains("agent"))) {
				// check if there is a mutant hostage
				if (downCellComponent.contains("hostage")) {
					// check the damage to know if it is mutant
					String[] hos = downCellComponent.split(";");
					if (Integer.parseInt(hos[3]) < 100) {
						right = true;
					} else {
						result.add("KillRight");
					}
				}
				right = true;
			} else {
				result.add("KillRight");
			}
		}
		// check if I can go Up
		if (current.x > 0) {
			// check if there is an agent or a mutant agent
			String leftCellComponent = whatInCell(current.x - 1, current.y, grid);
			if (!(leftCellComponent.contains("agent"))) {
				// check if there is a mutant hostage
				if (leftCellComponent.contains("hostage")) {
					// check the damage to know if it is mutant
					String[] hos = leftCellComponent.split(";");
					if (Integer.parseInt(hos[3]) < 100) {
						up = true;
					} else {
						result.add("KillUp");
					}
				}
				up = true;
			} else {
				result.add("KillUp");
			}
		}
		if (up) {
			result.add("Up");
		}
		if (right) {
			result.add("Right");
		}
		if (down) {
			result.add("Down");
		}
		if (left) {
			result.add("Left");
		}

		return result;
	}

	// method to detect possible actions and insert in queue
	// this method returns array of strings of the following format
	// "ActionName", "affectedLocation"
	public static ArrayList<String> getPossibleActions(Location current, String grid) {
		ArrayList<String> result = new ArrayList<String>();
		// check the current cell components
		String currentCellComponent = whatInCell(current.x, current.y, grid);
		if (currentCellComponent.contains("pill")) {
			// either take it or leave it
			result.add("Pill," + current.x + "," + current.y);
		}
		if (currentCellComponent.contains("hostage")) {
			// cannot be a mutant hostage because we do not add this option to happen during
			// movement
			result.add("Carry," + current.x + "," + current.y);
		}
		if (currentCellComponent.contains("pad")) {
			// get the go-to pad from the string
			String[] pillData = currentCellComponent.split(";");
			// we know that the current cell is the first pad in the string so ignore it
			int fx = Integer.parseInt(pillData[3]);
			int fy = Integer.parseInt(pillData[4]);
			result.add("Fly," + fx + "," + fy);
		}
		if (currentCellComponent.contains("telephone")) {
			// you can either drop or leave
			// check before drop if there is a hostage to drop
			result.add("Drop," + current.x + "," + current.y);
		}

		// get the possible movements
		ArrayList<String> movements = whereCanIMove(current, grid);
		if (!(movements.isEmpty())) {
			for (int i = 0; i < movements.size(); i++) {
				if (movements.get(i) == "Up") {
					result.add("Up," + (current.x - 1) + "," + current.y);
				} else if (movements.get(i) == "Right") {
					result.add("Right," + current.x + "," + (current.y + 1));
				} else if (movements.get(i) == "Down") {
					result.add("Down," + (current.x + 1) + "," + current.y);
				} else if (movements.get(i) == "Left") {
					result.add("Left," + current.x + "," + (current.y - 1));
				} else if (movements.get(i) == "KillUp") {
					result.add("Kill," + (current.x - 1) + "," + current.y);
				} else if (movements.get(i) == "KillRight") {
					result.add("Kill," + current.x + "," + (current.y + 1));
				} else if (movements.get(i) == "KillDown") {
					result.add("Kill," + (current.x + 1) + "," + current.y);
				} else if (movements.get(i) == "KillLeft") {
					result.add("Kill," + current.x + "," + (current.y - 1));
				}

			}
		}
		return result;

	}

	// reminder: make the location of the carried hostage should be that of neo
	// reminder: adjust damage abl maymot law pill
	// reminder e3mly el ba2y
	// 5aly update ta5od el node

	// updates everything needed according to the action taken
	// I think it should return the new grid string
	public static TreeNode update(String action, TreeNode prevNode, ArrayList<TreeNode> prevNodes) {
		// we assume that Neo starts with 0 damage
		// update damage of all hostages

		// resultant grid
		String result = "";
		// split the grid at ; to extract different categories in the grid
		String[] splitted = prevNode.grid.split(";");
		// since the dimensions and neo's initial position and TB position are constant,
		// append to result
		result += splitted[0] + ";" + splitted[1] + ";" + splitted[2] + ";" + splitted[3] + ";";

		// array that contains locations of all the agents
		String[] agents = splitted[4].split(",");
		// array that contains the locations of all mutant hostages
		ArrayList<String> mutantHostages = getMutantHostages(prevNode.grid);
		// array that contains locations of all the pills
		String[] pills = splitted[5].split(",");
		// array that contains locations of all the pads
		// this array is always divisible by 4 since the pad comes in pairs
		// (startx, starty, finishx, finishy)
		String pads = splitted[6];
		// array that contains locations of all the hostages
		// get this array from the method getHostages to avoid getting mutant hostages
		// from the grid string
		ArrayList<String> hostages = getHostages(prevNode.grid);
		ArrayList<Integer> carried = prevNode.carried;
		int deaths = prevNode.deaths;

		for (int i = 0; i < hostages.size(); i++) {
			// each entry in the arraylist is a string with commas splitting the x and y and
			// damage
			String[] splittedHos = hostages.get(i).split(",");
			// the third element is the damage
			int oldDamage = Integer.parseInt(splittedHos[2]) + 2;
			if (action == "Pill") {
				oldDamage -= 2;
			}
			// set the new damage
			hostages.set(i, splittedHos[0] + "," + splittedHos[1] + "," + oldDamage);
			// check if it reached 100
			if (oldDamage >= 100) {
				// remove this hostage from the hostages array and add it to mutant
				mutantHostages.add(hostages.get(i));
				hostages.remove(i);
				// update the grid by adding the new hostage damage
				// as we do not add a different category in the grid string to represent the
				// mutant hostages
				// we rely on having the damage of 100 or greater to reflect this change
			}
		}
		for (int i = 0; i < carried.size(); i++) {
			int d = carried.get(i);
			if (action == "Pill") {
				if (d < 100) {
					if (d < 20) {
						carried.set(i, 0);
					} else {
						carried.set(i, d - 20);
					}

				}
			} else if (d < 100) {
				carried.set(i, d + 2);
				if (carried.get(i) >= 100) {
					deaths++;
				}
			}

		}
		int kills = prevNode.kills;
		int neoD = prevNode.neoDamage;
		Location newLocation = prevNode.myLoc;

		// get the affected location from action
		String[] actionDetails = action.split(",");
		Location moveTo = new Location(Integer.parseInt(actionDetails[1]), Integer.parseInt(actionDetails[2]));

		// check the action performed and accordingly update the grid or damage
		switch (actionDetails[0]) {
		case ("Kill"):
			System.out.println("hamoot" + (prevNode.myLoc.y == Integer.parseInt(agents[1])));
			// update grid by removing the killed agent or mutant hostage
			// increment Neo's damage by 20
			kills++;
			neoD += 20;
			// increment the number of killings by 1 if it is an agent
			for (int i = 0; i < agents.length - 1; i += 2) {
				if (Integer.parseInt(actionDetails[1]) == Integer.parseInt(agents[i])
						&& Integer.parseInt(actionDetails[2]) == Integer.parseInt(agents[i + 1])) {
					
					// replace the x and y with negatives so that when we combine the string again
					// we can know that this is not valid
					
					agents[i] = "-1";
					agents[i + 1] = "-1";
					break;
				}
			}
			for (int i = 0; i < mutantHostages.size() - 1; i += 2) {
				if (prevNode.myLoc.x == Integer.parseInt(mutantHostages.get(i))
						&& prevNode.myLoc.y == Integer.parseInt(mutantHostages.get(i + 1))) {
					// remove the mutant hostages from the arraylist
					mutantHostages.remove(i + 1);
					mutantHostages.remove(i);
					// also remove the hostage from the grid string
					break;
				}
			}

			break;
		case ("Pill"):
			// update grid method above
			// Decrement the damages of hostages and Neo by 20
			for (int i = 0; i < pills.length - 1; i += 2) {
				if (prevNode.myLoc.x == Integer.parseInt(pills[i])
						&& prevNode.myLoc.y == Integer.parseInt(pills[i + 1])) {
					// replace the x and y with negatives so that when we combine the string again
					// we can know that this is not valid
					pills[i] = "-1";
					pills[i + 1] = "-1";
					break;
				}
			}

			if (neoD < 20) {
				neoD = 0;
			} else {
				neoD -= 20;
			}

			for (int i = 0; i < hostages.size(); i++) {
				// each entry in the arraylist is a string with commas splitting the x and y and
				// damage
				String[] splitted2 = hostages.get(i).split(",");
				// the third element is the damage
				// decrement by 22 because we already incremented by 2 at the beginning of the
				// method
				int oldDamage2 = Integer.parseInt(splitted2[2]);
				if (oldDamage2 < 20) {
					oldDamage2 = 0;
				} else {
					oldDamage2 -= 20;
				}
				// set the new damage
				if (oldDamage2 < 0) {
					hostages.set(i, splitted2[0] + "," + splitted2[1] + "," + oldDamage2);
					// check that is cannot reach below 0
				}
			}
			// Decrement Neo damage by 20
			break;
		case ("Carry"):
			// update grid method above
			int cAllowed = Integer.parseInt(splitted[1]);
			if (carried.size() + 1 < cAllowed) {
				// increment c by 1
				for (int i = 0; i < hostages.size() - 1; i += 3) {
					if (prevNode.myLoc.x == Integer.parseInt(hostages.get(i))
							&& prevNode.myLoc.y == Integer.parseInt(hostages.get(i + 1))) {
						// replace the x and y with negatives so that when we combine the string again
						// we can know that this is not valid

						// set the location to that of neo
						hostages.remove(i + 1);
						hostages.remove(i);
						carried.add(Integer.parseInt(hostages.remove(i + 2)));
						break;
					}
				}
			}

			break;
		case ("Drop"):
			// Reset carried
			prevNode.carried = new ArrayList<Integer>();
			carried = new ArrayList<Integer>();
			break;
		case ("Down"):
			System.out.println("here2");
			// nothing changes in the grid only the overall hostage damage increases by 2
			// and this is already handled above
			newLocation = moveTo;

			break;
		case ("Up"):
			// nothing changes in the grid only the overall hostage damage increases by 2
			// and this is already handled above
			newLocation = moveTo;

			break;
		case ("Right"):
			// nothing changes in the grid only the overall hostage damage increases by 2
			// and this is already handled above
			newLocation = moveTo;

			break;
		case ("Left"):
			// nothing changes in the grid only the overall hostage damage increases by 2
			// and this is already handled above
			newLocation = moveTo;

			break;
		case ("Fly"):
			// change hostages carried location
			// nothing changes in the grid only the overall hostage damage increases by 2
			// and this is already handled above
			newLocation = moveTo;
			break;
		default:
			break;
		}

		// then we need to form the new grid

		for (int i = 0; i < agents.length - 1; i += 2) {
			if (agents[i] == "-1") {
				// killed
				continue;
			} else {
				result += agents[i] + "," + agents[i + 1];
				if (i < agents.length - 3) {
					result += ",";
				}
			}
		}
		result += ";";

		for (int i = 0; i < pills.length - 1; i += 2) {
			if (pills[i] == "-1") {
				// taken
				continue;
			} else {

				result += pills[i] + "," + pills[i + 1];
				if (i < pills.length - 3) {
					result += ",";
				}
			}
		}

		result += ";" + pads + ";";

		for (int i = 0; i < hostages.size() - 2; i += 3) {
			result += hostages.get(i) + "," + hostages.get(i + 1) + "," + hostages.get(i + 2);
			if (i < hostages.size() - 4) {
				result += ",";
			}
		}

		// add the mutant hostages to the hostages category in the grid
		for (int i = 0; i < mutantHostages.size() - 1; i += 2) {
			result += mutantHostages.get(i) + "," + mutantHostages.get(i + 1) + "," + "100";
			if (i < mutantHostages.size() - 3) {
				result += ",";
			}
		}

		TreeNode resNode = new TreeNode(prevNode, prevNodes, newLocation, neoD, result, kills, deaths, actionDetails[0],
				prevNode.depth + 1, 0, carried);
		System.out.println(result + "griiiid");
		return resNode;

	}

	// raz3yn el depth wl costs
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-11-15 23:13:15.126
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-11-15 23:13:15.126
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2021-11-15 23:13:15.149
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package code;

import java.util.ArrayList;

import code.Location;
import code.TreeNode;
import code.Queue.*;

public abstract class GeneralSearch {

	// habdyn el cost wl depth
	// check game over

	public static String generalSearch(String grid, String strategy, boolean visualize) {
		String result = "";
		//initialize everything as this is the start
		ArrayList<TreeNode> prevNodes = new ArrayList<TreeNode>();
		ArrayList<PreNode> preNodes = new ArrayList<PreNode>();
		String[] splitted = grid.split(";");
		//get Neo's starting position
		String[] preNeo = splitted[2].split(",");
		Location neo = new Location(Integer.parseInt(preNeo[0]), Integer.parseInt(preNeo[1]));
		//array to store the damages of the carried hostages
		//also used to keep track of the number of carried hostages
		ArrayList<Integer> carried = new ArrayList<Integer>();
		
		// create initial starting node
		##TO-DO
		// reminder: cost
		TreeNode start = new TreeNode(null, prevNodes, neo, 0, grid, 0, 0, "Start", 0, 0, carried);
		PreNode startPre = new PreNode("Start", neo, start, 0);

		prevNodes.add(start);

		// create the queue for search
		Queue queue;
		switch (strategy) {
		case ("DF"):
			queue = new DFQueue();
			break;
		default:
			//temporary
			queue = new DFQueue();
			break;
		}

		// get the possible actions for the starting node
		ArrayList<String> possibleActions = getPossibleActions(neo, grid);
		printArr(possibleActions);
		for (int i = 0; i < possibleActions.size(); i++) {
			String[] pa = possibleActions.get(i).split(",");
			Location affected = new Location(Integer.parseInt(pa[1]), Integer.parseInt(pa[2]));
			PreNode pn = new PreNode(pa[0], affected, start, 0);
			queue.enqueue(pn);
		}

		queue.display();

		boolean failed = false;
		String finalGrid = "";

		while (!queue.queue.isEmpty()) {
			System.out.println("habd2 ml awl");
			PreNode frontPreNode = queue.dequeue();
			boolean repeated = false;
			/*
			for (int i = 0 ; i < prevNodes.size(); i++) {
				if(frontPreNode.prevNode.myLoc.x == prevNodes.get(i).myLoc.x && 
						frontPreNode.prevNode.myLoc.y == prevNodes.get(i).myLoc.y) {
					if (!(queue.queue.isEmpty())) {
					frontPreNode = queue.dequeue();
					}
				}
			}
			*/
			TreeNode frontTreeNode = update(
					frontPreNode.action + "," + frontPreNode.affectedCell.x + "," + frontPreNode.affectedCell.y,
					frontPreNode.prevNode, prevNodes);
			for (int i = 0 ; i < prevNodes.size(); i++) {
				if(frontTreeNode.myLoc.x == prevNodes.get(i).myLoc.x && 
						frontTreeNode.myLoc.y == prevNodes.get(i).myLoc.y &&
						compareGrids(frontTreeNode.grid, prevNodes.get(i).grid) == true) {
					//ignore this path
					repeated = true;
					break;
					//if (!(queue.queue.isEmpty())) {
					//frontPreNode = queue.dequeue();
					//}
				}
			}
			if (repeated == true) {
				System.out.println("msh hakml");
				continue;
			}
			System.out.println("tamam");
			prevNodes.add(frontTreeNode);
			possibleActions = getPossibleActions(frontTreeNode.myLoc, frontTreeNode.grid);
			
			for (int i = 0; i < possibleActions.size(); i++) {
				String[] pa = possibleActions.get(i).split(",");
				//System.out.println(possibleActions.get(i));
				Location affected = new Location(Integer.parseInt(pa[1]), Integer.parseInt(pa[2]));
				PreNode pn = new PreNode(pa[0], affected, frontTreeNode, 0);
				queue.enqueue(pn);
				//queue.display();
			}
			boolean goal = isItGoal(frontTreeNode);
			System.out.println(frontPreNode.action);
			queue.display();
			if (queue.queue.isEmpty()) {
				failed = true;
			}
			
			if (frontTreeNode.neoDamage >= 100) {
				return "fail";
			}
			
			finalGrid = frontTreeNode.grid;

		}
		return finalGrid;
	}
	
	//this might be tricky if we needed the damages as a difference
	public static boolean compareGrids(String grid1, String grid2) {
		boolean similar = false;
		//if same number of agents and hostages and pills then similar
		String[] splitted1 = grid1.split(";");
		String[] splitted2 = grid2.split(";");
		String[] agents1 = splitted1[4].split(",");
		String[] agents2 = splitted2[4].split(",");
		if (agents1.length == agents2.length) {
			//check pills
			String[] pills1 = splitted1[5].split(",");
			String[] pills2 = splitted2[5].split(",");
			if (pills1.length == pills2.length) {
				//check hostages
				String[] hos1;
				if (splitted1.length <= 7 ) {
					//no more hostages
					hos1 = new String[0];
				}else {
					hos1 = splitted1[7].split(",");
				}
				
				String[] hos2;
				if (splitted2.length <= 7 ) {
					//no more hostages
					hos2 = new String[0];
				}else {
					hos2 = splitted2[7].split(",");
				}
				if (hos1.length ==hos2.length) {
					similar = true;
				}else {
					similar = false;
				}
			}else {
				similar = false;
			}
		}else {
			similar = false;
		}
		return similar;
	}

	// goal test
	public static boolean isItGoal(TreeNode n) {

		boolean goal = false;
		String grid = n.grid;
		ArrayList<String> hostages = getHostages(grid);
		ArrayList<String> mutantHostages = getMutantHostages(grid);
		if (mutantHostages.size() == 0 && hostages.size() == 0) {
			goal = true;
		}
		return goal;

	}

	// method to print the content of any array
	public static void printArr(ArrayList<String> arr) {
		for (int i = 0; i < arr.size(); i++) {
			System.out.println(arr.get(i));
		}
		System.out.println(" ");
	}

	// method to fill the hostages and damage
	public static ArrayList<String> getHostages(String grid) {
		ArrayList<String> result = new ArrayList<String>();
		String[] splitted = grid.split(";");
		// System.out.println(splitted.length);
		// array that contains locations of all the hostages
		String[] hostages;
		if (splitted.length <= 7) {
			hostages = new String[0];
		}else {
			hostages = splitted[7].split(",");
		}

		for (int i = 0; i < hostages.length - 1; i += 3) {
			// store the location and damage in a string
			String temp = "";
			// check the damage to know if mutant or alive
			// if mutant then skip this iteration
			if (Integer.parseInt(hostages[i + 2]) < 100) {
				temp += hostages[i] + "," + hostages[i + 1] + "," + hostages[i + 2];
				result.add(temp);
			}

		}

		return result;
	}

	// method to fill the mutant hostages
	public static ArrayList<String> getMutantHostages(String grid) {
		ArrayList<String> result = new ArrayList<String>();

		String[] splitted = grid.split(";");
		// array that contains locations of all the hostages
		String[] hostages;
		if (splitted.length <= 7) {
			hostages = new String[0];
		}else {
			hostages = splitted[7].split(",");
		}

		for (int i = 0; i < hostages.length - 1; i += 3) {
			// store the location in a string
			String temp = "";
			// check the damage to know if mutant or alive
			// if alive then skip this iteration
			if (Integer.parseInt(hostages[i + 2]) >= 100) {
				// add only the location since we do not need the damage
				temp += hostages[i] + "," + hostages[i + 1];
				result.add(temp);
			}

		}

		return result;
	}

	// method to get the content of the given cell and useful information about
	// content of cell
	// can be used to determine the surroundings of the current cell
	public static String whatInCell(int x, int y, String grid) {
		String result = "";
		// split the grid at ; to extract different categories in the grid
		String[] splitted = grid.split(";");
		// array that consists of (x,y) of the telephone booth
		String[] telephone = splitted[3].split(",");
		// array that contains locations of all the agents
		String[] agents = splitted[4].split(",");
		// array that contains locations of all pills
		String[] pills = splitted[5].split(",");
		// array that contains locations of all the pads
		// this array is always divisible by 4 since the pad comes in pairs
		// (startx, starty, finishx, finishy)
		String[] pads = splitted[6].split(",");
		// array that contains locations of all the hostages
		String[] hostages;
		if (splitted.length <=7) {
			hostages = new String[0];
		}else {
			hostages = splitted[7].split(",");
		}

		if (x == Integer.parseInt(telephone[0]) && y == Integer.parseInt(telephone[1])) {
			result = "telephone;" + x + ";" + y;
			return result;
		}
		for (int i = 0; i < agents.length - 1; i += 2) {
			if (x == Integer.parseInt(agents[i]) && y == Integer.parseInt(agents[i + 1])) {
				result = "agent;" + x + ";" + y;
				return result;
			}
		}
		for (int i = 0; i < pills.length - 1; i += 2) {
			if (x == Integer.parseInt(pills[i]) && y == Integer.parseInt(pills[i + 1])) {
				result = "pill;" + x + ";" + y;
				return result;
			}
		}
		for (int i = 0; i < pads.length - 1; i += 2) {
			if (x == Integer.parseInt(pads[i]) && y == Integer.parseInt(pads[i + 1])) {
				result = "pad;" + x + ";" + y;
				if ((i / 2) % 2 == 0) {
					result += ";" + pads[i + 2] + ";" + pads[i + 3];
				} else {
					result += ";" + pads[i - 2] + ";" + pads[i - 1];
				}
				// return pair of pads attached together
				return result;
			}
		}
		for (int i = 0; i < hostages.length - 1; i += 3) {
			if (x == Integer.parseInt(hostages[i]) && y == Integer.parseInt(hostages[i + 1])) {
				result = "hostage;" + x + ";" + y + ";" + hostages[i + 2];
				return result;
			}
		}

		return result;
	}

	// method to detect where can I move
	public static ArrayList<String> whereCanIMove(Location current, String grid) {
		ArrayList<String> result = new ArrayList<String>();
		// check all possible directions
		String[] splitted = grid.split(";");
		String[] dimensions = splitted[0].split(",");
		int cols = Integer.parseInt(dimensions[1]);
		int rows = Integer.parseInt(dimensions[0]);
		boolean up = false;
		boolean right = false;
		boolean down = false;
		boolean left = false;
		// check if I can go left
		if (current.y > 0) {
			// check if there is an agent or a mutant agent
			String upCellComponent = whatInCell(current.x, current.y - 1, grid);
			if (!(upCellComponent.contains("agent"))) {
				// check if there is a mutant hostage
				if (upCellComponent.contains("hostage")) {
					// check the damage to know if it is mutant
					String[] hos = upCellComponent.split(";");
					if (Integer.parseInt(hos[3]) < 100) {
						left = true;
					} else {
						result.add("KillLeft");
					}
				}
				left = true;
			} else {
				result.add("KillLeft");
			}
		}
		// check if I can go down
		if (current.x < rows - 1) {
			// check if there is an agent or a mutant agent
			String rightCellComponent = whatInCell(current.x + 1, current.y, grid);
			if (!(rightCellComponent.contains("agent"))) {
				// check if there is a mutant hostage
				if (rightCellComponent.contains("hostage")) {
					// System.out.println(rightCellComponent);
					// check the damage to know if it is mutant
					String[] hos = rightCellComponent.split(";");
					if (Integer.parseInt(hos[3]) < 100) {
						down = true;
					} else {
						result.add("KillDown");
					}
				}
				down = true;
			} else {
				result.add("KillDown");
			}
		}
		// check if I can go right
		if (current.y < cols - 1) {
			// check if there is an agent or a mutant agent
			String downCellComponent = whatInCell(current.x, current.y + 1, grid);
			if (!(downCellComponent.contains("agent"))) {
				// check if there is a mutant hostage
				if (downCellComponent.contains("hostage")) {
					// check the damage to know if it is mutant
					String[] hos = downCellComponent.split(";");
					if (Integer.parseInt(hos[3]) < 100) {
						right = true;
					} else {
						result.add("KillRight");
					}
				}
				right = true;
			} else {
				result.add("KillRight");
			}
		}
		// check if I can go Up
		if (current.x > 0) {
			// check if there is an agent or a mutant agent
			String leftCellComponent = whatInCell(current.x - 1, current.y, grid);
			if (!(leftCellComponent.contains("agent"))) {
				// check if there is a mutant hostage
				if (leftCellComponent.contains("hostage")) {
					// check the damage to know if it is mutant
					String[] hos = leftCellComponent.split(";");
					if (Integer.parseInt(hos[3]) < 100) {
						up = true;
					} else {
						result.add("KillUp");
					}
				}
				up = true;
			} else {
				result.add("KillUp");
			}
		}
		if (up) {
			result.add("Up");
		}
		if (right) {
			result.add("Right");
		}
		if (down) {
			result.add("Down");
		}
		if (left) {
			result.add("Left");
		}

		return result;
	}

	// method to detect possible actions and insert in queue
	// this method returns array of strings of the following format
	// "ActionName", "affectedLocation"
	public static ArrayList<String> getPossibleActions(Location current, String grid) {
		ArrayList<String> result = new ArrayList<String>();
		// check the current cell components
		String currentCellComponent = whatInCell(current.x, current.y, grid);
		if (currentCellComponent.contains("pill")) {
			// either take it or leave it
			result.add("Pill," + current.x + "," + current.y);
		}
		if (currentCellComponent.contains("hostage")) {
			// cannot be a mutant hostage because we do not add this option to happen during
			// movement
			result.add("Carry," + current.x + "," + current.y);
		}
		if (currentCellComponent.contains("pad")) {
			// get the go-to pad from the string
			String[] pillData = currentCellComponent.split(";");
			// we know that the current cell is the first pad in the string so ignore it
			int fx = Integer.parseInt(pillData[3]);
			int fy = Integer.parseInt(pillData[4]);
			result.add("Fly," + fx + "," + fy);
		}
		if (currentCellComponent.contains("telephone")) {
			// you can either drop or leave
			// check before drop if there is a hostage to drop
			result.add("Drop," + current.x + "," + current.y);
		}

		// get the possible movements
		ArrayList<String> movements = whereCanIMove(current, grid);
		if (!(movements.isEmpty())) {
			for (int i = 0; i < movements.size(); i++) {
				if (movements.get(i) == "Up") {
					result.add("Up," + (current.x - 1) + "," + current.y);
				} else if (movements.get(i) == "Right") {
					result.add("Right," + current.x + "," + (current.y + 1));
				} else if (movements.get(i) == "Down") {
					result.add("Down," + (current.x + 1) + "," + current.y);
				} else if (movements.get(i) == "Left") {
					result.add("Left," + current.x + "," + (current.y - 1));
				} else if (movements.get(i) == "KillUp") {
					result.add("Kill," + (current.x - 1) + "," + current.y);
				} else if (movements.get(i) == "KillRight") {
					result.add("Kill," + current.x + "," + (current.y + 1));
				} else if (movements.get(i) == "KillDown") {
					result.add("Kill," + (current.x + 1) + "," + current.y);
				} else if (movements.get(i) == "KillLeft") {
					result.add("Kill," + current.x + "," + (current.y - 1));
				}

			}
		}
		return result;

	}

	// reminder: make the location of the carried hostage should be that of neo
	// reminder: adjust damage abl maymot law pill
	// reminder e3mly el ba2y
	// 5aly update ta5od el node

	// updates everything needed according to the action taken
	// I think it should return the new grid string
	public static TreeNode update(String action, TreeNode prevNode, ArrayList<TreeNode> prevNodes) {
		// we assume that Neo starts with 0 damage
		// update damage of all hostages

		// resultant grid
		String result = "";
		// split the grid at ; to extract different categories in the grid
		String[] splitted = prevNode.grid.split(";");
		// since the dimensions and neo's initial position and TB position are constant,
		// append to result
		result += splitted[0] + ";" + splitted[1] + ";" + splitted[2] + ";" + splitted[3] + ";";

		// array that contains locations of all the agents
		String[] agents = splitted[4].split(",");
		// array that contains the locations of all mutant hostages
		ArrayList<String> mutantHostages = getMutantHostages(prevNode.grid);
		// array that contains locations of all the pills
		String[] pills = splitted[5].split(",");
		// array that contains locations of all the pads
		// this array is always divisible by 4 since the pad comes in pairs
		// (startx, starty, finishx, finishy)
		String pads = splitted[6];
		// array that contains locations of all the hostages
		// get this array from the method getHostages to avoid getting mutant hostages
		// from the grid string
		ArrayList<String> hostages = getHostages(prevNode.grid);
		ArrayList<Integer> carried = prevNode.carried;
		int deaths = prevNode.deaths;

		for (int i = 0; i < hostages.size(); i++) {
			// each entry in the arraylist is a string with commas splitting the x and y and
			// damage
			String[] splittedHos = hostages.get(i).split(",");
			// the third element is the damage
			int oldDamage = Integer.parseInt(splittedHos[2]) + 2;
			if (action == "Pill") {
				oldDamage -= 2;
			}
			// set the new damage
			hostages.set(i, splittedHos[0] + "," + splittedHos[1] + "," + oldDamage);
			// check if it reached 100
			if (oldDamage >= 100) {
				// remove this hostage from the hostages array and add it to mutant
				mutantHostages.add(hostages.get(i));
				hostages.remove(i);
				// update the grid by adding the new hostage damage
				// as we do not add a different category in the grid string to represent the
				// mutant hostages
				// we rely on having the damage of 100 or greater to reflect this change
			}
		}
		for (int i = 0; i < carried.size(); i++) {
			int d = carried.get(i);
			if (action == "Pill") {
				if (d < 100) {
					if (d < 20) {
						carried.set(i, 0);
					} else {
						carried.set(i, d - 20);
					}

				}
			} else if (d < 100) {
				carried.set(i, d + 2);
				if (carried.get(i) >= 100) {
					deaths++;
				}
			}

		}
		int kills = prevNode.kills;
		int neoD = prevNode.neoDamage;
		Location newLocation = prevNode.myLoc;

		// get the affected location from action
		String[] actionDetails = action.split(",");
		Location moveTo = new Location(Integer.parseInt(actionDetails[1]), Integer.parseInt(actionDetails[2]));

		// check the action performed and accordingly update the grid or damage
		switch (actionDetails[0]) {
		case ("Kill"):
			System.out.println("hamoot" + (prevNode.myLoc.y == Integer.parseInt(agents[1])));
			// update grid by removing the killed agent or mutant hostage
			// increment Neo's damage by 20
			kills++;
			neoD += 20;
			// increment the number of killings by 1 if it is an agent
			for (int i = 0; i < agents.length - 1; i += 2) {
				if (Integer.parseInt(actionDetails[1]) == Integer.parseInt(agents[i])
						&& Integer.parseInt(actionDetails[2]) == Integer.parseInt(agents[i + 1])) {
					
					// replace the x and y with negatives so that when we combine the string again
					// we can know that this is not valid
					
					agents[i] = "-1";
					agents[i + 1] = "-1";
					break;
				}
			}
			for (int i = 0; i < mutantHostages.size() - 1; i += 2) {
				if (prevNode.myLoc.x == Integer.parseInt(mutantHostages.get(i))
						&& prevNode.myLoc.y == Integer.parseInt(mutantHostages.get(i + 1))) {
					// remove the mutant hostages from the arraylist
					mutantHostages.remove(i + 1);
					mutantHostages.remove(i);
					// also remove the hostage from the grid string
					break;
				}
			}

			break;
		case ("Pill"):
			// update grid method above
			// Decrement the damages of hostages and Neo by 20
			for (int i = 0; i < pills.length - 1; i += 2) {
				if (prevNode.myLoc.x == Integer.parseInt(pills[i])
						&& prevNode.myLoc.y == Integer.parseInt(pills[i + 1])) {
					// replace the x and y with negatives so that when we combine the string again
					// we can know that this is not valid
					pills[i] = "-1";
					pills[i + 1] = "-1";
					break;
				}
			}

			if (neoD < 20) {
				neoD = 0;
			} else {
				neoD -= 20;
			}

			for (int i = 0; i < hostages.size(); i++) {
				// each entry in the arraylist is a string with commas splitting the x and y and
				// damage
				String[] splitted2 = hostages.get(i).split(",");
				// the third element is the damage
				// decrement by 22 because we already incremented by 2 at the beginning of the
				// method
				int oldDamage2 = Integer.parseInt(splitted2[2]);
				if (oldDamage2 < 20) {
					oldDamage2 = 0;
				} else {
					oldDamage2 -= 20;
				}
				// set the new damage
				if (oldDamage2 < 0) {
					hostages.set(i, splitted2[0] + "," + splitted2[1] + "," + oldDamage2);
					// check that is cannot reach below 0
				}
			}
			// Decrement Neo damage by 20
			break;
		case ("Carry"):
			// update grid method above
			int cAllowed = Integer.parseInt(splitted[1]);
			if (carried.size() + 1 < cAllowed) {
				// increment c by 1
				for (int i = 0; i < hostages.size() - 1; i += 3) {
					if (prevNode.myLoc.x == Integer.parseInt(hostages.get(i))
							&& prevNode.myLoc.y == Integer.parseInt(hostages.get(i + 1))) {
						// replace the x and y with negatives so that when we combine the string again
						// we can know that this is not valid

						// set the location to that of neo
						hostages.remove(i + 1);
						hostages.remove(i);
						carried.add(Integer.parseInt(hostages.remove(i + 2)));
						break;
					}
				}
			}

			break;
		case ("Drop"):
			// Reset carried
			prevNode.carried = new ArrayList<Integer>();
			carried = new ArrayList<Integer>();
			break;
		case ("Down"):
			System.out.println("here2");
			// nothing changes in the grid only the overall hostage damage increases by 2
			// and this is already handled above
			newLocation = moveTo;

			break;
		case ("Up"):
			// nothing changes in the grid only the overall hostage damage increases by 2
			// and this is already handled above
			newLocation = moveTo;

			break;
		case ("Right"):
			// nothing changes in the grid only the overall hostage damage increases by 2
			// and this is already handled above
			newLocation = moveTo;

			break;
		case ("Left"):
			// nothing changes in the grid only the overall hostage damage increases by 2
			// and this is already handled above
			newLocation = moveTo;

			break;
		case ("Fly"):
			// change hostages carried location
			// nothing changes in the grid only the overall hostage damage increases by 2
			// and this is already handled above
			newLocation = moveTo;
			break;
		default:
			break;
		}

		// then we need to form the new grid

		for (int i = 0; i < agents.length - 1; i += 2) {
			if (agents[i] == "-1") {
				// killed
				continue;
			} else {
				result += agents[i] + "," + agents[i + 1];
				if (i < agents.length - 3) {
					result += ",";
				}
			}
		}
		result += ";";

		for (int i = 0; i < pills.length - 1; i += 2) {
			if (pills[i] == "-1") {
				// taken
				continue;
			} else {

				result += pills[i] + "," + pills[i + 1];
				if (i < pills.length - 3) {
					result += ",";
				}
			}
		}

		result += ";" + pads + ";";

		for (int i = 0; i < hostages.size() - 2; i += 3) {
			result += hostages.get(i) + "," + hostages.get(i + 1) + "," + hostages.get(i + 2);
			if (i < hostages.size() - 4) {
				result += ",";
			}
		}

		// add the mutant hostages to the hostages category in the grid
		for (int i = 0; i < mutantHostages.size() - 1; i += 2) {
			result += mutantHostages.get(i) + "," + mutantHostages.get(i + 1) + "," + "100";
			if (i < mutantHostages.size() - 3) {
				result += ",";
			}
		}

		TreeNode resNode = new TreeNode(prevNode, prevNodes, newLocation, neoD, result, kills, deaths, actionDetails[0],
				prevNode.depth + 1, 0, carried);
		System.out.println(result + "griiiid");
		return resNode;

	}

	// raz3yn el depth wl costs
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-11-15 23:13:15.150
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-11-15 23:13:15.150
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2021-11-15 23:13:15.994
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package code;

import java.util.ArrayList;

import code.Location;
import code.TreeNode;
import code.Queue.*;

public abstract class GeneralSearch {

	// habdyn el cost wl depth
	// check game over

	public static String generalSearch(String grid, String strategy, boolean visualize) {
		String result = "";
		//initialize everything as this is the start
		ArrayList<TreeNode> prevNodes = new ArrayList<TreeNode>();
		ArrayList<PreNode> preNodes = new ArrayList<PreNode>();
		String[] splitted = grid.split(";");
		//get Neo's starting position
		String[] preNeo = splitted[2].split(",");
		Location neo = new Location(Integer.parseInt(preNeo[0]), Integer.parseInt(preNeo[1]));
		//array to store the damages of the carried hostages
		//also used to keep track of the number of carried hostages
		ArrayList<Integer> carried = new ArrayList<Integer>();
		
		// create initial starting node
		##TO-DO
		// reminder: cost
		TreeNode start = new TreeNode(null, prevNodes, neo, 0, grid, 0, 0, "Start", 0, 0, carried);
		PreNode startPre = new PreNode("Start", neo, start, 0);

		prevNodes.add(start);

		// create the queue for search
		Queue queue;
		switch (strategy) {
		case ("DF"):
			queue = new DFQueue();
			break;
		default:
			//temporary
			queue = new DFQueue();
			break;
		}

		// get the possible actions for the starting node
		ArrayList<String> possibleActions = getPossibleActions(neo, grid);
		printArr(possibleActions);
		for (int i = 0; i < possibleActions.size(); i++) {
			String[] pa = possibleActions.get(i).split(",");
			Location affected = new Location(Integer.parseInt(pa[1]), Integer.parseInt(pa[2]));
			PreNode pn = new PreNode(pa[0], affected, start, 0);
			queue.enqueue(pn);
		}

		queue.display();

		boolean failed = false;
		String finalGrid = "";

		while (!queue.queue.isEmpty()) {
			System.out.println("habd2 ml awl");
			PreNode frontPreNode = queue.dequeue();
			boolean repeated = false;
			/*
			for (int i = 0 ; i < prevNodes.size(); i++) {
				if(frontPreNode.prevNode.myLoc.x == prevNodes.get(i).myLoc.x && 
						frontPreNode.prevNode.myLoc.y == prevNodes.get(i).myLoc.y) {
					if (!(queue.queue.isEmpty())) {
					frontPreNode = queue.dequeue();
					}
				}
			}
			*/
			TreeNode frontTreeNode = update(
					frontPreNode.action + "," + frontPreNode.affectedCell.x + "," + frontPreNode.affectedCell.y,
					frontPreNode.prevNode, prevNodes);
			for (int i = 0 ; i < prevNodes.size(); i++) {
				if(frontTreeNode.myLoc.x == prevNodes.get(i).myLoc.x && 
						frontTreeNode.myLoc.y == prevNodes.get(i).myLoc.y &&
						compareGrids(frontTreeNode.grid, prevNodes.get(i).grid) == true) {
					//ignore this path
					repeated = true;
					break;
					//if (!(queue.queue.isEmpty())) {
					//frontPreNode = queue.dequeue();
					//}
				}
			}
			if (repeated == true) {
				System.out.println("msh hakml");
				continue;
			}
			System.out.println("tamam");
			prevNodes.add(frontTreeNode);
			possibleActions = getPossibleActions(frontTreeNode.myLoc, frontTreeNode.grid);
			
			for (int i = 0; i < possibleActions.size(); i++) {
				String[] pa = possibleActions.get(i).split(",");
				//System.out.println(possibleActions.get(i));
				Location affected = new Location(Integer.parseInt(pa[1]), Integer.parseInt(pa[2]));
				PreNode pn = new PreNode(pa[0], affected, frontTreeNode, 0);
				queue.enqueue(pn);
				//queue.display();
			}
			boolean goal = isItGoal(frontTreeNode);
			System.out.println(frontPreNode.action);
			queue.display();
			if (queue.queue.isEmpty()) {
				failed = true;
			}
			
			if (frontTreeNode.neoDamage >= 100) {
				return "fail";
			}
			
			finalGrid = frontTreeNode.grid;

		}
		return finalGrid;
	}
	
	//this might be tricky if we needed the damages as a difference
	public static boolean compareGrids(String grid1, String grid2) {
		boolean similar = false;
		//if same number of agents and hostages and pills then similar
		String[] splitted1 = grid1.split(";");
		String[] splitted2 = grid2.split(";");
		String[] agents1 = splitted1[4].split(",");
		String[] agents2 = splitted2[4].split(",");
		if (agents1.length == agents2.length) {
			//check pills
			String[] pills1 = splitted1[5].split(",");
			String[] pills2 = splitted2[5].split(",");
			if (pills1.length == pills2.length) {
				//check hostages
				String[] hos1;
				if (splitted1.length <= 7 ) {
					//no more hostages
					hos1 = new String[0];
				}else {
					hos1 = splitted1[7].split(",");
				}
				
				String[] hos2;
				if (splitted2.length <= 7 ) {
					//no more hostages
					hos2 = new String[0];
				}else {
					hos2 = splitted2[7].split(",");
				}
				if (hos1.length ==hos2.length) {
					similar = true;
				}else {
					similar = false;
				}
			}else {
				similar = false;
			}
		}else {
			similar = false;
		}
		return similar;
	}

	// goal test
	public static boolean isItGoal(TreeNode n) {

		boolean goal = false;
		String grid = n.grid;
		ArrayList<String> hostages = getHostages(grid);
		ArrayList<String> mutantHostages = getMutantHostages(grid);
		if (mutantHostages.size() == 0 && hostages.size() == 0) {
			goal = true;
		}
		return goal;

	}

	// method to print the content of any array
	public static void printArr(ArrayList<String> arr) {
		for (int i = 0; i < arr.size(); i++) {
			System.out.println(arr.get(i));
		}
		System.out.println(" ");
	}

	// method to fill the hostages and damage
	public static ArrayList<String> getHostages(String grid) {
		ArrayList<String> result = new ArrayList<String>();
		String[] splitted = grid.split(";");
		// System.out.println(splitted.length);
		// array that contains locations of all the hostages
		String[] hostages;
		if (splitted.length <= 7) {
			hostages = new String[0];
		}else {
			hostages = splitted[7].split(",");
		}

		for (int i = 0; i < hostages.length - 1; i += 3) {
			// store the location and damage in a string
			String temp = "";
			// check the damage to know if mutant or alive
			// if mutant then skip this iteration
			if (Integer.parseInt(hostages[i + 2]) < 100) {
				temp += hostages[i] + "," + hostages[i + 1] + "," + hostages[i + 2];
				result.add(temp);
			}

		}

		return result;
	}

	// method to fill the mutant hostages
	public static ArrayList<String> getMutantHostages(String grid) {
		ArrayList<String> result = new ArrayList<String>();

		String[] splitted = grid.split(";");
		// array that contains locations of all the hostages
		String[] hostages;
		if (splitted.length <= 7) {
			hostages = new String[0];
		}else {
			hostages = splitted[7].split(",");
		}

		for (int i = 0; i < hostages.length - 1; i += 3) {
			// store the location in a string
			String temp = "";
			// check the damage to know if mutant or alive
			// if alive then skip this iteration
			if (Integer.parseInt(hostages[i + 2]) >= 100) {
				// add only the location since we do not need the damage
				temp += hostages[i] + "," + hostages[i + 1];
				result.add(temp);
			}

		}

		return result;
	}

	// method to get the content of the given cell and useful information about
	// content of cell
	// can be used to determine the surroundings of the current cell
	public static String whatInCell(int x, int y, String grid) {
		String result = "";
		// split the grid at ; to extract different categories in the grid
		String[] splitted = grid.split(";");
		// array that consists of (x,y) of the telephone booth
		String[] telephone = splitted[3].split(",");
		// array that contains locations of all the agents
		String[] agents = splitted[4].split(",");
		// array that contains locations of all pills
		String[] pills = splitted[5].split(",");
		// array that contains locations of all the pads
		// this array is always divisible by 4 since the pad comes in pairs
		// (startx, starty, finishx, finishy)
		String[] pads = splitted[6].split(",");
		// array that contains locations of all the hostages
		String[] hostages;
		if (splitted.length <=7) {
			hostages = new String[0];
		}else {
			hostages = splitted[7].split(",");
		}

		if (x == Integer.parseInt(telephone[0]) && y == Integer.parseInt(telephone[1])) {
			result = "telephone;" + x + ";" + y;
			return result;
		}
		for (int i = 0; i < agents.length - 1; i += 2) {
			if (x == Integer.parseInt(agents[i]) && y == Integer.parseInt(agents[i + 1])) {
				result = "agent;" + x + ";" + y;
				return result;
			}
		}
		for (int i = 0; i < pills.length - 1; i += 2) {
			if (x == Integer.parseInt(pills[i]) && y == Integer.parseInt(pills[i + 1])) {
				result = "pill;" + x + ";" + y;
				return result;
			}
		}
		for (int i = 0; i < pads.length - 1; i += 2) {
			if (x == Integer.parseInt(pads[i]) && y == Integer.parseInt(pads[i + 1])) {
				result = "pad;" + x + ";" + y;
				if ((i / 2) % 2 == 0) {
					result += ";" + pads[i + 2] + ";" + pads[i + 3];
				} else {
					result += ";" + pads[i - 2] + ";" + pads[i - 1];
				}
				// return pair of pads attached together
				return result;
			}
		}
		for (int i = 0; i < hostages.length - 1; i += 3) {
			if (x == Integer.parseInt(hostages[i]) && y == Integer.parseInt(hostages[i + 1])) {
				result = "hostage;" + x + ";" + y + ";" + hostages[i + 2];
				return result;
			}
		}

		return result;
	}

	// method to detect where can I move
	public static ArrayList<String> whereCanIMove(Location current, String grid) {
		ArrayList<String> result = new ArrayList<String>();
		// check all possible directions
		String[] splitted = grid.split(";");
		String[] dimensions = splitted[0].split(",");
		int cols = Integer.parseInt(dimensions[1]);
		int rows = Integer.parseInt(dimensions[0]);
		boolean up = false;
		boolean right = false;
		boolean down = false;
		boolean left = false;
		// check if I can go left
		if (current.y > 0) {
			// check if there is an agent or a mutant agent
			String upCellComponent = whatInCell(current.x, current.y - 1, grid);
			if (!(upCellComponent.contains("agent"))) {
				// check if there is a mutant hostage
				if (upCellComponent.contains("hostage")) {
					// check the damage to know if it is mutant
					String[] hos = upCellComponent.split(";");
					if (Integer.parseInt(hos[3]) < 100) {
						left = true;
					} else {
						result.add("KillLeft");
					}
				}
				left = true;
			} else {
				result.add("KillLeft");
			}
		}
		// check if I can go down
		if (current.x < rows - 1) {
			// check if there is an agent or a mutant agent
			String rightCellComponent = whatInCell(current.x + 1, current.y, grid);
			if (!(rightCellComponent.contains("agent"))) {
				// check if there is a mutant hostage
				if (rightCellComponent.contains("hostage")) {
					// System.out.println(rightCellComponent);
					// check the damage to know if it is mutant
					String[] hos = rightCellComponent.split(";");
					if (Integer.parseInt(hos[3]) < 100) {
						down = true;
					} else {
						result.add("KillDown");
					}
				}
				down = true;
			} else {
				result.add("KillDown");
			}
		}
		// check if I can go right
		if (current.y < cols - 1) {
			// check if there is an agent or a mutant agent
			String downCellComponent = whatInCell(current.x, current.y + 1, grid);
			if (!(downCellComponent.contains("agent"))) {
				// check if there is a mutant hostage
				if (downCellComponent.contains("hostage")) {
					// check the damage to know if it is mutant
					String[] hos = downCellComponent.split(";");
					if (Integer.parseInt(hos[3]) < 100) {
						right = true;
					} else {
						result.add("KillRight");
					}
				}
				right = true;
			} else {
				result.add("KillRight");
			}
		}
		// check if I can go Up
		if (current.x > 0) {
			// check if there is an agent or a mutant agent
			String leftCellComponent = whatInCell(current.x - 1, current.y, grid);
			if (!(leftCellComponent.contains("agent"))) {
				// check if there is a mutant hostage
				if (leftCellComponent.contains("hostage")) {
					// check the damage to know if it is mutant
					String[] hos = leftCellComponent.split(";");
					if (Integer.parseInt(hos[3]) < 100) {
						up = true;
					} else {
						result.add("KillUp");
					}
				}
				up = true;
			} else {
				result.add("KillUp");
			}
		}
		if (up) {
			result.add("Up");
		}
		if (right) {
			result.add("Right");
		}
		if (down) {
			result.add("Down");
		}
		if (left) {
			result.add("Left");
		}

		return result;
	}

	// method to detect possible actions and insert in queue
	// this method returns array of strings of the following format
	// "ActionName", "affectedLocation"
	public static ArrayList<String> getPossibleActions(Location current, String grid) {
		ArrayList<String> result = new ArrayList<String>();
		// check the current cell components
		String currentCellComponent = whatInCell(current.x, current.y, grid);
		if (currentCellComponent.contains("pill")) {
			// either take it or leave it
			result.add("Pill," + current.x + "," + current.y);
		}
		if (currentCellComponent.contains("hostage")) {
			// cannot be a mutant hostage because we do not add this option to happen during
			// movement
			result.add("Carry," + current.x + "," + current.y);
		}
		if (currentCellComponent.contains("pad")) {
			// get the go-to pad from the string
			String[] pillData = currentCellComponent.split(";");
			// we know that the current cell is the first pad in the string so ignore it
			int fx = Integer.parseInt(pillData[3]);
			int fy = Integer.parseInt(pillData[4]);
			result.add("Fly," + fx + "," + fy);
		}
		if (currentCellComponent.contains("telephone")) {
			// you can either drop or leave
			// check before drop if there is a hostage to drop
			result.add("Drop," + current.x + "," + current.y);
		}

		// get the possible movements
		ArrayList<String> movements = whereCanIMove(current, grid);
		if (!(movements.isEmpty())) {
			for (int i = 0; i < movements.size(); i++) {
				if (movements.get(i) == "Up") {
					result.add("Up," + (current.x - 1) + "," + current.y);
				} else if (movements.get(i) == "Right") {
					result.add("Right," + current.x + "," + (current.y + 1));
				} else if (movements.get(i) == "Down") {
					result.add("Down," + (current.x + 1) + "," + current.y);
				} else if (movements.get(i) == "Left") {
					result.add("Left," + current.x + "," + (current.y - 1));
				} else if (movements.get(i) == "KillUp") {
					result.add("Kill," + (current.x - 1) + "," + current.y);
				} else if (movements.get(i) == "KillRight") {
					result.add("Kill," + current.x + "," + (current.y + 1));
				} else if (movements.get(i) == "KillDown") {
					result.add("Kill," + (current.x + 1) + "," + current.y);
				} else if (movements.get(i) == "KillLeft") {
					result.add("Kill," + current.x + "," + (current.y - 1));
				}

			}
		}
		return result;

	}

	// reminder: make the location of the carried hostage should be that of neo
	// reminder: adjust damage abl maymot law pill
	// reminder e3mly el ba2y
	// 5aly update ta5od el node

	// updates everything needed according to the action taken
	// I think it should return the new grid string
	public static TreeNode update(String action, TreeNode prevNode, ArrayList<TreeNode> prevNodes) {
		// we assume that Neo starts with 0 damage
		// update damage of all hostages

		// resultant grid
		String result = "";
		// split the grid at ; to extract different categories in the grid
		String[] splitted = prevNode.grid.split(";");
		// since the dimensions and neo's initial position and TB position are constant,
		// append to result
		result += splitted[0] + ";" + splitted[1] + ";" + splitted[2] + ";" + splitted[3] + ";";

		// array that contains locations of all the agents
		String[] agents = splitted[4].split(",");
		// array that contains the locations of all mutant hostages
		ArrayList<String> mutantHostages = getMutantHostages(prevNode.grid);
		// array that contains locations of all the pills
		String[] pills = splitted[5].split(",");
		// array that contains locations of all the pads
		// this array is always divisible by 4 since the pad comes in pairs
		// (startx, starty, finishx, finishy)
		String pads = splitted[6];
		// array that contains locations of all the hostages
		// get this array from the method getHostages to avoid getting mutant hostages
		// from the grid string
		ArrayList<String> hostages = getHostages(prevNode.grid);
		ArrayList<Integer> carried = prevNode.carried;
		int deaths = prevNode.deaths;

		for (int i = 0; i < hostages.size(); i++) {
			// each entry in the arraylist is a string with commas splitting the x and y and
			// damage
			String[] splittedHos = hostages.get(i).split(",");
			// the third element is the damage
			int oldDamage = Integer.parseInt(splittedHos[2]) + 2;
			if (action == "Pill") {
				oldDamage -= 2;
			}
			// set the new damage
			hostages.set(i, splittedHos[0] + "," + splittedHos[1] + "," + oldDamage);
			// check if it reached 100
			if (oldDamage >= 100) {
				// remove this hostage from the hostages array and add it to mutant
				mutantHostages.add(hostages.get(i));
				hostages.remove(i);
				// update the grid by adding the new hostage damage
				// as we do not add a different category in the grid string to represent the
				// mutant hostages
				// we rely on having the damage of 100 or greater to reflect this change
			}
		}
		for (int i = 0; i < carried.size(); i++) {
			int d = carried.get(i);
			if (action == "Pill") {
				if (d < 100) {
					if (d < 20) {
						carried.set(i, 0);
					} else {
						carried.set(i, d - 20);
					}

				}
			} else if (d < 100) {
				carried.set(i, d + 2);
				if (carried.get(i) >= 100) {
					deaths++;
				}
			}

		}
		int kills = prevNode.kills;
		int neoD = prevNode.neoDamage;
		Location newLocation = prevNode.myLoc;

		// get the affected location from action
		String[] actionDetails = action.split(",");
		Location moveTo = new Location(Integer.parseInt(actionDetails[1]), Integer.parseInt(actionDetails[2]));

		// check the action performed and accordingly update the grid or damage
		switch (actionDetails[0]) {
		case ("Kill"):
			System.out.println("hamoot" + (prevNode.myLoc.y == Integer.parseInt(agents[1])));
			// update grid by removing the killed agent or mutant hostage
			// increment Neo's damage by 20
			kills++;
			neoD += 20;
			// increment the number of killings by 1 if it is an agent
			for (int i = 0; i < agents.length - 1; i += 2) {
				if (Integer.parseInt(actionDetails[1]) == Integer.parseInt(agents[i])
						&& Integer.parseInt(actionDetails[2]) == Integer.parseInt(agents[i + 1])) {
					
					// replace the x and y with negatives so that when we combine the string again
					// we can know that this is not valid
					
					agents[i] = "-1";
					agents[i + 1] = "-1";
					break;
				}
			}
			for (int i = 0; i < mutantHostages.size() - 1; i += 2) {
				if (prevNode.myLoc.x == Integer.parseInt(mutantHostages.get(i))
						&& prevNode.myLoc.y == Integer.parseInt(mutantHostages.get(i + 1))) {
					// remove the mutant hostages from the arraylist
					mutantHostages.remove(i + 1);
					mutantHostages.remove(i);
					// also remove the hostage from the grid string
					break;
				}
			}

			break;
		case ("Pill"):
			// update grid method above
			// Decrement the damages of hostages and Neo by 20
			for (int i = 0; i < pills.length - 1; i += 2) {
				if (prevNode.myLoc.x == Integer.parseInt(pills[i])
						&& prevNode.myLoc.y == Integer.parseInt(pills[i + 1])) {
					// replace the x and y with negatives so that when we combine the string again
					// we can know that this is not valid
					pills[i] = "-1";
					pills[i + 1] = "-1";
					break;
				}
			}

			if (neoD < 20) {
				neoD = 0;
			} else {
				neoD -= 20;
			}

			for (int i = 0; i < hostages.size(); i++) {
				// each entry in the arraylist is a string with commas splitting the x and y and
				// damage
				String[] splitted2 = hostages.get(i).split(",");
				// the third element is the damage
				// decrement by 22 because we already incremented by 2 at the beginning of the
				// method
				int oldDamage2 = Integer.parseInt(splitted2[2]);
				if (oldDamage2 < 20) {
					oldDamage2 = 0;
				} else {
					oldDamage2 -= 20;
				}
				// set the new damage
				if (oldDamage2 < 0) {
					hostages.set(i, splitted2[0] + "," + splitted2[1] + "," + oldDamage2);
					// check that is cannot reach below 0
				}
			}
			// Decrement Neo damage by 20
			break;
		case ("Carry"):
			// update grid method above
			int cAllowed = Integer.parseInt(splitted[1]);
			if (carried.size() + 1 < cAllowed) {
				// increment c by 1
				for (int i = 0; i < hostages.size() - 1; i += 3) {
					if (prevNode.myLoc.x == Integer.parseInt(hostages.get(i))
							&& prevNode.myLoc.y == Integer.parseInt(hostages.get(i + 1))) {
						// replace the x and y with negatives so that when we combine the string again
						// we can know that this is not valid

						// set the location to that of neo
						hostages.remove(i + 1);
						hostages.remove(i);
						carried.add(Integer.parseInt(hostages.remove(i + 2)));
						break;
					}
				}
			}

			break;
		case ("Drop"):
			// Reset carried
			prevNode.carried = new ArrayList<Integer>();
			carried = new ArrayList<Integer>();
			break;
		case ("Down"):
			System.out.println("here2");
			// nothing changes in the grid only the overall hostage damage increases by 2
			// and this is already handled above
			newLocation = moveTo;

			break;
		case ("Up"):
			// nothing changes in the grid only the overall hostage damage increases by 2
			// and this is already handled above
			newLocation = moveTo;

			break;
		case ("Right"):
			// nothing changes in the grid only the overall hostage damage increases by 2
			// and this is already handled above
			newLocation = moveTo;

			break;
		case ("Left"):
			// nothing changes in the grid only the overall hostage damage increases by 2
			// and this is already handled above
			newLocation = moveTo;

			break;
		case ("Fly"):
			// change hostages carried location
			// nothing changes in the grid only the overall hostage damage increases by 2
			// and this is already handled above
			newLocation = moveTo;
			break;
		default:
			break;
		}

		// then we need to form the new grid

		for (int i = 0; i < agents.length - 1; i += 2) {
			if (agents[i] == "-1") {
				// killed
				continue;
			} else {
				result += agents[i] + "," + agents[i + 1];
				if (i < agents.length - 3) {
					result += ",";
				}
			}
		}
		result += ";";

		for (int i = 0; i < pills.length - 1; i += 2) {
			if (pills[i] == "-1") {
				// taken
				continue;
			} else {

				result += pills[i] + "," + pills[i + 1];
				if (i < pills.length - 3) {
					result += ",";
				}
			}
		}

		result += ";" + pads + ";";

		for (int i = 0; i < hostages.size() - 2; i += 3) {
			result += hostages.get(i) + "," + hostages.get(i + 1) + "," + hostages.get(i + 2);
			if (i < hostages.size() - 4) {
				result += ",";
			}
		}

		// add the mutant hostages to the hostages category in the grid
		for (int i = 0; i < mutantHostages.size() - 1; i += 2) {
			result += mutantHostages.get(i) + "," + mutantHostages.get(i + 1) + "," + "100";
			if (i < mutantHostages.size() - 3) {
				result += ",";
			}
		}

		TreeNode resNode = new TreeNode(prevNode, prevNodes, newLocation, neoD, result, kills, deaths, actionDetails[0],
				prevNode.depth + 1, 0, carried);
		System.out.println(result + "griiiid");
		return resNode;

	}

	// raz3yn el depth wl costs
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-11-15 23:13:15.994
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-11-15 23:13:15.994
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2021-11-16 19:50:17.842 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=16.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-16 19:50:29.549
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-16 19:50:29.549
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@32caae19,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@60e67c06,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-16 19:50:32.933
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\safam'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-11-17 23:04:15.075 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=16.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-17 23:04:28.860
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-17 23:04:28.860
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2bc59ab7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@410f53b2,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-17 23:04:31.896
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\safam'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
