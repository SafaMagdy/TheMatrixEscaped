!SESSION 2021-10-24 20:27:02.024 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=16.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-24 20:27:18.797
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-24 20:27:18.797
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2b62475a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4990b335,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-24 20:27:22.493
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\safam'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-10-28 18:34:58.535 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=16.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-28 18:35:14.746
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-28 18:35:14.746
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5d74507c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2a984952,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-28 18:35:17.002
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\safam'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jface 4 2 2021-10-28 20:19:13.459
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jface".
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.jdt.core.dom.ASTNode.getParent()" because "node" is null
	at org.eclipse.jdt.internal.corext.dom.ASTNodes.getParent(ASTNodes.java:2474)
	at org.eclipse.jdt.internal.corext.refactoring.structure.ASTNodeSearchUtil.getMethodDeclarationNode(ASTNodeSearchUtil.java:129)
	at org.eclipse.jdt.internal.corext.refactoring.RefactoringAvailabilityTester.isCanonicalConstructor(RefactoringAvailabilityTester.java:208)
	at org.eclipse.jdt.internal.corext.refactoring.RefactoringAvailabilityTester.isIntroduceParameterObjectAvailable(RefactoringAvailabilityTester.java:1250)
	at org.eclipse.jdt.internal.ui.actions.IntroduceParameterObjectAction.selectionChanged(IntroduceParameterObjectAction.java:74)
	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.dispatchSelectionChanged(SelectionDispatchAction.java:262)
	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.selectionChanged(SelectionDispatchAction.java:257)
	at org.eclipse.jface.viewers.Viewer$1.run(Viewer.java:151)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:174)
	at org.eclipse.jface.viewers.Viewer.fireSelectionChanged(Viewer.java:148)
	at org.eclipse.jface.viewers.StructuredViewer.updateSelection(StructuredViewer.java:2132)
	at org.eclipse.jface.viewers.StructuredViewer.setSelection(StructuredViewer.java:1662)
	at org.eclipse.jface.viewers.TreeViewer.setSelection(TreeViewer.java:1084)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaOutlinePage.select(JavaOutlinePage.java:1127)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.synchronizeOutlinePage(JavaEditor.java:2153)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.synchronizeOutlinePage(JavaEditor.java:2141)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.selectionChanged(JavaEditor.java:2248)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:78)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:654)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1462)

!ENTRY org.eclipse.jdt.ui 4 10001 2021-10-28 21:34:56.786
!MESSAGE Internal Error
!STACK 1
Java Model Exception: Java Model Status [whatInCell(int, int) [in TreeNode [in [Working copy] TreeNode.java [in code [in src [in AI]]]]] does not exist]
	at org.eclipse.jdt.internal.core.JavaElement.newNotPresentException(JavaElement.java:574)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:617)
	at org.eclipse.jdt.internal.core.JavaElement.getElementInfo(JavaElement.java:327)
	at org.eclipse.jdt.internal.core.JavaElement.getElementInfo(JavaElement.java:313)
	at org.eclipse.jdt.internal.core.SourceRefElement.getSourceRange(SourceRefElement.java:233)
	at org.eclipse.jdt.internal.core.Member.getJavadocRange(Member.java:301)
	at org.eclipse.jdt.internal.ui.text.javadoc.JavadocContentAccess2.getHTMLContentFromSource(JavadocContentAccess2.java:639)
	at org.eclipse.jdt.internal.ui.text.javadoc.JavadocContentAccess2.getHTMLContent(JavadocContentAccess2.java:515)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:748)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)
!SUBENTRY 1 org.eclipse.jdt.core 4 969 2021-10-28 21:34:56.786
!MESSAGE whatInCell(int, int) [in TreeNode [in [Working copy] TreeNode.java [in code [in src [in AI]]]]] does not exist
!SESSION 2021-11-03 14:07:32.288 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=16.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-03 14:07:45.144
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-03 14:07:45.144
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6b86826a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3c2dda7c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-03 14:07:48.486
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\safam'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2021-11-03 17:28:37.685
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package code;
import java.util.ArrayList;

import code.Location;

public class TreeNode {
	
	//list for tracking the previous cells visited to avoid repeated states
	public ArrayList<Location> prevCells;
	//current node location
	public Location myLoc;
	//number of current alive hostages
	public int hostagesNum;
	//number of mutant hostages that must be killed
	public int mutantHostagesNum;
	//track of neo's health/damage
	public int neoHealth;
	//the updated string according to the path that led to the current node
	public String grid;
	
	public TreeNode(ArrayList<Location> prevCells, Location myLoc, int hNum, int mHNum, int neoH, String grid) {
		
		this.prevCells = prevCells;
		this.myLoc = myLoc;
		this.hostagesNum = hNum;
		this.mutantHostagesNum = mHNum;
		this.neoHealth = neoH;
		this.grid = grid;		
		
	}
	
	//method to print the content of any array
	public static void printArr (String[] arr)
	{
		for ( int i = 0 ; i < arr.length; i++) {
			System.out.print(arr[i]);
		}
		System.out.println(" ");
	}
	
	// we need to add the locations of mutant hostages in the grid
	// or implement a method that checks the damage of all hostages
	
	//return array of important values like name of the object
	//for example hostage and health
	//pad and locations
	
	
	//method to get the content of the given cell
	//can be used to determine the surroundings of the current cell 
	public static String whatInCell(int x, int y, String grid) {
		String result = "";
		//split the grid at ; to extract different categories in the grid
		String[] splitted = grid.split(";");
		//array that consists of (x,y) of the telephone booth
		String[] telephone = splitted[3].split(",");
		//array that contains locations of all the agents
		String[] agents = splitted[4].split(",");
		//array that contains locations of all pills
		String[] pills = splitted[5].split(",");
		//array that contains locations of all the pads
		//this array is always divisible by 4 since the pad comes in pairs
		//(startx, starty, finishx, finishy)
		String[] pads = splitted[6].split(",");
		//array that contains locations of all the hostages
		String[] hostages = splitted[7].split(",");
		
		if(x == Integer.parseInt(telephone[0]) && y == Integer.parseInt(telephone[1])) {
			result = "telephone;" + x + ";" + y;
			return result;
		}
		for (int i = 0 ; i < agents.length-1; i+=2) {
			if(x == Integer.parseInt(agents[i]) && y == Integer.parseInt(agents[i+1])) {
				result = "agent;" + x + ";" + y;
				return result;
			}
		}
		for (int i = 0 ; i < pills.length-1; i+=2) {
			if(x == Integer.parseInt(pills[i]) && y == Integer.parseInt(pills[i+1])) {
				result = "pill;" + x + ";" + y;
				return result;
			}
		}
		for (int i = 0 ; i < pads.length-1; i+=2) {
			if(x == Integer.parseInt(pads[i]) && y == Integer.parseInt(pads[i+1])) {
				result = "pad;" + x + ";" + y;
				i/2
				//return pair of pads attached together
				return result;
			}
		}
		for (int i = 0 ; i < hostages.length-1; i+=3) {
			System.out.println(hostages[i]);
			if(x == Integer.parseInt(hostages[i]) && y == Integer.parseInt(hostages[i+1])) {
				result = "hostage";
				return result;
			}
		}
		
		return result;
	}
	
	public static void main(String[] args) {
		
		System.out.println(whatInCell(1,2, "3,3;1;0,0;1,1;0,1;1,2;0,2,2,0;1,0,0,2,1,50,2,2,90"));
	}
	
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2991)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:494)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-11-03 17:28:37.689
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2991)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:494)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-11-03 17:28:37.690
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2991)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:494)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-11-03 17:28:37.699
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package code;
import java.util.ArrayList;

import code.Location;

public class TreeNode {
	
	//list for tracking the previous cells visited to avoid repeated states
	public ArrayList<Location> prevCells;
	//current node location
	public Location myLoc;
	//number of current alive hostages
	public int hostagesNum;
	//number of mutant hostages that must be killed
	public int mutantHostagesNum;
	//track of neo's health/damage
	public int neoHealth;
	//the updated string according to the path that led to the current node
	public String grid;
	
	public TreeNode(ArrayList<Location> prevCells, Location myLoc, int hNum, int mHNum, int neoH, String grid) {
		
		this.prevCells = prevCells;
		this.myLoc = myLoc;
		this.hostagesNum = hNum;
		this.mutantHostagesNum = mHNum;
		this.neoHealth = neoH;
		this.grid = grid;		
		
	}
	
	//method to print the content of any array
	public static void printArr (String[] arr)
	{
		for ( int i = 0 ; i < arr.length; i++) {
			System.out.print(arr[i]);
		}
		System.out.println(" ");
	}
	
	// we need to add the locations of mutant hostages in the grid
	// or implement a method that checks the damage of all hostages
	
	//return array of important values like name of the object
	//for example hostage and health
	//pad and locations
	
	
	//method to get the content of the given cell
	//can be used to determine the surroundings of the current cell 
	public static String whatInCell(int x, int y, String grid) {
		String result = "";
		//split the grid at ; to extract different categories in the grid
		String[] splitted = grid.split(";");
		//array that consists of (x,y) of the telephone booth
		String[] telephone = splitted[3].split(",");
		//array that contains locations of all the agents
		String[] agents = splitted[4].split(",");
		//array that contains locations of all pills
		String[] pills = splitted[5].split(",");
		//array that contains locations of all the pads
		//this array is always divisible by 4 since the pad comes in pairs
		//(startx, starty, finishx, finishy)
		String[] pads = splitted[6].split(",");
		//array that contains locations of all the hostages
		String[] hostages = splitted[7].split(",");
		
		if(x == Integer.parseInt(telephone[0]) && y == Integer.parseInt(telephone[1])) {
			result = "telephone;" + x + ";" + y;
			return result;
		}
		for (int i = 0 ; i < agents.length-1; i+=2) {
			if(x == Integer.parseInt(agents[i]) && y == Integer.parseInt(agents[i+1])) {
				result = "agent;" + x + ";" + y;
				return result;
			}
		}
		for (int i = 0 ; i < pills.length-1; i+=2) {
			if(x == Integer.parseInt(pills[i]) && y == Integer.parseInt(pills[i+1])) {
				result = "pill;" + x + ";" + y;
				return result;
			}
		}
		for (int i = 0 ; i < pads.length-1; i+=2) {
			if(x == Integer.parseInt(pads[i]) && y == Integer.parseInt(pads[i+1])) {
				result = "pad;" + x + ";" + y;
				i/2
				//return pair of pads attached together
				return result;
			}
		}
		for (int i = 0 ; i < hostages.length-1; i+=3) {
			System.out.println(hostages[i]);
			if(x == Integer.parseInt(hostages[i]) && y == Integer.parseInt(hostages[i+1])) {
				result = "hostage";
				return result;
			}
		}
		
		return result;
	}
	
	public static void main(String[] args) {
		
		System.out.println(whatInCell(1,2, "3,3;1;0,0;1,1;0,1;1,2;0,2,2,0;1,0,0,2,1,50,2,2,90"));
	}
	
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2991)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-11-03 17:28:37.700
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2991)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-11-03 17:28:37.700
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2991)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-11-03 17:28:40.710
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package code;
import java.util.ArrayList;

import code.Location;

public class TreeNode {
	
	//list for tracking the previous cells visited to avoid repeated states
	public ArrayList<Location> prevCells;
	//current node location
	public Location myLoc;
	//number of current alive hostages
	public int hostagesNum;
	//number of mutant hostages that must be killed
	public int mutantHostagesNum;
	//track of neo's health/damage
	public int neoHealth;
	//the updated string according to the path that led to the current node
	public String grid;
	
	public TreeNode(ArrayList<Location> prevCells, Location myLoc, int hNum, int mHNum, int neoH, String grid) {
		
		this.prevCells = prevCells;
		this.myLoc = myLoc;
		this.hostagesNum = hNum;
		this.mutantHostagesNum = mHNum;
		this.neoHealth = neoH;
		this.grid = grid;		
		
	}
	
	//method to print the content of any array
	public static void printArr (String[] arr)
	{
		for ( int i = 0 ; i < arr.length; i++) {
			System.out.print(arr[i]);
		}
		System.out.println(" ");
	}
	
	// we need to add the locations of mutant hostages in the grid
	// or implement a method that checks the damage of all hostages
	
	//return array of important values like name of the object
	//for example hostage and health
	//pad and locations
	
	
	//method to get the content of the given cell
	//can be used to determine the surroundings of the current cell 
	public static String whatInCell(int x, int y, String grid) {
		String result = "";
		//split the grid at ; to extract different categories in the grid
		String[] splitted = grid.split(";");
		//array that consists of (x,y) of the telephone booth
		String[] telephone = splitted[3].split(",");
		//array that contains locations of all the agents
		String[] agents = splitted[4].split(",");
		//array that contains locations of all pills
		String[] pills = splitted[5].split(",");
		//array that contains locations of all the pads
		//this array is always divisible by 4 since the pad comes in pairs
		//(startx, starty, finishx, finishy)
		String[] pads = splitted[6].split(",");
		//array that contains locations of all the hostages
		String[] hostages = splitted[7].split(",");
		
		if(x == Integer.parseInt(telephone[0]) && y == Integer.parseInt(telephone[1])) {
			result = "telephone;" + x + ";" + y;
			return result;
		}
		for (int i = 0 ; i < agents.length-1; i+=2) {
			if(x == Integer.parseInt(agents[i]) && y == Integer.parseInt(agents[i+1])) {
				result = "agent;" + x + ";" + y;
				return result;
			}
		}
		for (int i = 0 ; i < pills.length-1; i+=2) {
			if(x == Integer.parseInt(pills[i]) && y == Integer.parseInt(pills[i+1])) {
				result = "pill;" + x + ";" + y;
				return result;
			}
		}
		for (int i = 0 ; i < pads.length-1; i+=2) {
			if(x == Integer.parseInt(pads[i]) && y == Integer.parseInt(pads[i+1])) {
				result = "pad;" + x + ";" + y;
				i/2
				//return pair of pads attached together
				return result;
			}
		}
		for (int i = 0 ; i < hostages.length-1; i+=3) {
			System.out.println(hostages[i]);
			if(x == Integer.parseInt(hostages[i]) && y == Integer.parseInt(hostages[i+1])) {
				result = "hostage";
				return result;
			}
		}
		
		return result;
	}
	
	public static void main(String[] args) {
		
		System.out.println(whatInCell(1,2, "3,3;1;0,0;1,1;0,1;1,2;0,2,2,0;1,0,0,2,1,50,2,2,90"));
	}
	
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2991)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:494)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-11-03 17:28:40.711
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2991)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:494)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-11-03 17:28:40.711
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2991)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:494)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-11-03 17:28:40.719
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package code;
import java.util.ArrayList;

import code.Location;

public class TreeNode {
	
	//list for tracking the previous cells visited to avoid repeated states
	public ArrayList<Location> prevCells;
	//current node location
	public Location myLoc;
	//number of current alive hostages
	public int hostagesNum;
	//number of mutant hostages that must be killed
	public int mutantHostagesNum;
	//track of neo's health/damage
	public int neoHealth;
	//the updated string according to the path that led to the current node
	public String grid;
	
	public TreeNode(ArrayList<Location> prevCells, Location myLoc, int hNum, int mHNum, int neoH, String grid) {
		
		this.prevCells = prevCells;
		this.myLoc = myLoc;
		this.hostagesNum = hNum;
		this.mutantHostagesNum = mHNum;
		this.neoHealth = neoH;
		this.grid = grid;		
		
	}
	
	//method to print the content of any array
	public static void printArr (String[] arr)
	{
		for ( int i = 0 ; i < arr.length; i++) {
			System.out.print(arr[i]);
		}
		System.out.println(" ");
	}
	
	// we need to add the locations of mutant hostages in the grid
	// or implement a method that checks the damage of all hostages
	
	//return array of important values like name of the object
	//for example hostage and health
	//pad and locations
	
	
	//method to get the content of the given cell
	//can be used to determine the surroundings of the current cell 
	public static String whatInCell(int x, int y, String grid) {
		String result = "";
		//split the grid at ; to extract different categories in the grid
		String[] splitted = grid.split(";");
		//array that consists of (x,y) of the telephone booth
		String[] telephone = splitted[3].split(",");
		//array that contains locations of all the agents
		String[] agents = splitted[4].split(",");
		//array that contains locations of all pills
		String[] pills = splitted[5].split(",");
		//array that contains locations of all the pads
		//this array is always divisible by 4 since the pad comes in pairs
		//(startx, starty, finishx, finishy)
		String[] pads = splitted[6].split(",");
		//array that contains locations of all the hostages
		String[] hostages = splitted[7].split(",");
		
		if(x == Integer.parseInt(telephone[0]) && y == Integer.parseInt(telephone[1])) {
			result = "telephone;" + x + ";" + y;
			return result;
		}
		for (int i = 0 ; i < agents.length-1; i+=2) {
			if(x == Integer.parseInt(agents[i]) && y == Integer.parseInt(agents[i+1])) {
				result = "agent;" + x + ";" + y;
				return result;
			}
		}
		for (int i = 0 ; i < pills.length-1; i+=2) {
			if(x == Integer.parseInt(pills[i]) && y == Integer.parseInt(pills[i+1])) {
				result = "pill;" + x + ";" + y;
				return result;
			}
		}
		for (int i = 0 ; i < pads.length-1; i+=2) {
			if(x == Integer.parseInt(pads[i]) && y == Integer.parseInt(pads[i+1])) {
				result = "pad;" + x + ";" + y;
				i/2
				//return pair of pads attached together
				return result;
			}
		}
		for (int i = 0 ; i < hostages.length-1; i+=3) {
			System.out.println(hostages[i]);
			if(x == Integer.parseInt(hostages[i]) && y == Integer.parseInt(hostages[i+1])) {
				result = "hostage";
				return result;
			}
		}
		
		return result;
	}
	
	public static void main(String[] args) {
		
		System.out.println(whatInCell(1,2, "3,3;1;0,0;1,1;0,1;1,2;0,2,2,0;1,0,0,2,1,50,2,2,90"));
	}
	
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2991)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-11-03 17:28:40.719
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2991)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-11-03 17:28:40.720
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2991)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-11-03 17:28:48.471
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package code;
import java.util.ArrayList;

import code.Location;

public class TreeNode {
	
	//list for tracking the previous cells visited to avoid repeated states
	public ArrayList<Location> prevCells;
	//current node location
	public Location myLoc;
	//number of current alive hostages
	public int hostagesNum;
	//number of mutant hostages that must be killed
	public int mutantHostagesNum;
	//track of neo's health/damage
	public int neoHealth;
	//the updated string according to the path that led to the current node
	public String grid;
	
	public TreeNode(ArrayList<Location> prevCells, Location myLoc, int hNum, int mHNum, int neoH, String grid) {
		
		this.prevCells = prevCells;
		this.myLoc = myLoc;
		this.hostagesNum = hNum;
		this.mutantHostagesNum = mHNum;
		this.neoHealth = neoH;
		this.grid = grid;		
		
	}
	
	//method to print the content of any array
	public static void printArr (String[] arr)
	{
		for ( int i = 0 ; i < arr.length; i++) {
			System.out.print(arr[i]);
		}
		System.out.println(" ");
	}
	
	// we need to add the locations of mutant hostages in the grid
	// or implement a method that checks the damage of all hostages
	
	//return array of important values like name of the object
	//for example hostage and health
	//pad and locations
	
	
	//method to get the content of the given cell
	//can be used to determine the surroundings of the current cell 
	public static String whatInCell(int x, int y, String grid) {
		String result = "";
		//split the grid at ; to extract different categories in the grid
		String[] splitted = grid.split(";");
		//array that consists of (x,y) of the telephone booth
		String[] telephone = splitted[3].split(",");
		//array that contains locations of all the agents
		String[] agents = splitted[4].split(",");
		//array that contains locations of all pills
		String[] pills = splitted[5].split(",");
		//array that contains locations of all the pads
		//this array is always divisible by 4 since the pad comes in pairs
		//(startx, starty, finishx, finishy)
		String[] pads = splitted[6].split(",");
		//array that contains locations of all the hostages
		String[] hostages = splitted[7].split(",");
		
		if(x == Integer.parseInt(telephone[0]) && y == Integer.parseInt(telephone[1])) {
			result = "telephone;" + x + ";" + y;
			return result;
		}
		for (int i = 0 ; i < agents.length-1; i+=2) {
			if(x == Integer.parseInt(agents[i]) && y == Integer.parseInt(agents[i+1])) {
				result = "agent;" + x + ";" + y;
				return result;
			}
		}
		for (int i = 0 ; i < pills.length-1; i+=2) {
			if(x == Integer.parseInt(pills[i]) && y == Integer.parseInt(pills[i+1])) {
				result = "pill;" + x + ";" + y;
				return result;
			}
		}
		for (int i = 0 ; i < pads.length-1; i+=2) {
			if(x == Integer.parseInt(pads[i]) && y == Integer.parseInt(pads[i+1])) {
				result = "pad;" + x + ";" + y;
				i/2
				//return pair of pads attached together
				return result;
			}
		}
		for (int i = 0 ; i < hostages.length-1; i+=3) {
			System.out.println(hostages[i]);
			if(x == Integer.parseInt(hostages[i]) && y == Integer.parseInt(hostages[i+1])) {
				result = "hostage";
				return result;
			}
		}
		
		return result;
	}
	
	public static void main(String[] args) {
		
		System.out.println(whatInCell(1,2, "3,3;1;0,0;1,1;0,1;1,2;0,2,2,0;1,0,0,2,1,50,2,2,90"));
	}
	
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2991)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-11-03 17:28:48.472
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2991)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-11-03 17:28:48.472
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2991)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-11-03 17:28:51.224
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package code;
import java.util.ArrayList;

import code.Location;

public class TreeNode {
	
	//list for tracking the previous cells visited to avoid repeated states
	public ArrayList<Location> prevCells;
	//current node location
	public Location myLoc;
	//number of current alive hostages
	public int hostagesNum;
	//number of mutant hostages that must be killed
	public int mutantHostagesNum;
	//track of neo's health/damage
	public int neoHealth;
	//the updated string according to the path that led to the current node
	public String grid;
	
	public TreeNode(ArrayList<Location> prevCells, Location myLoc, int hNum, int mHNum, int neoH, String grid) {
		
		this.prevCells = prevCells;
		this.myLoc = myLoc;
		this.hostagesNum = hNum;
		this.mutantHostagesNum = mHNum;
		this.neoHealth = neoH;
		this.grid = grid;		
		
	}
	
	//method to print the content of any array
	public static void printArr (String[] arr)
	{
		for ( int i = 0 ; i < arr.length; i++) {
			System.out.print(arr[i]);
		}
		System.out.println(" ");
	}
	
	// we need to add the locations of mutant hostages in the grid
	// or implement a method that checks the damage of all hostages
	
	//return array of important values like name of the object
	//for example hostage and health
	//pad and locations
	
	
	//method to get the content of the given cell
	//can be used to determine the surroundings of the current cell 
	public static String whatInCell(int x, int y, String grid) {
		String result = "";
		//split the grid at ; to extract different categories in the grid
		String[] splitted = grid.split(";");
		//array that consists of (x,y) of the telephone booth
		String[] telephone = splitted[3].split(",");
		//array that contains locations of all the agents
		String[] agents = splitted[4].split(",");
		//array that contains locations of all pills
		String[] pills = splitted[5].split(",");
		//array that contains locations of all the pads
		//this array is always divisible by 4 since the pad comes in pairs
		//(startx, starty, finishx, finishy)
		String[] pads = splitted[6].split(",");
		//array that contains locations of all the hostages
		String[] hostages = splitted[7].split(",");
		
		if(x == Integer.parseInt(telephone[0]) && y == Integer.parseInt(telephone[1])) {
			result = "telephone;" + x + ";" + y;
			return result;
		}
		for (int i = 0 ; i < agents.length-1; i+=2) {
			if(x == Integer.parseInt(agents[i]) && y == Integer.parseInt(agents[i+1])) {
				result = "agent;" + x + ";" + y;
				return result;
			}
		}
		for (int i = 0 ; i < pills.length-1; i+=2) {
			if(x == Integer.parseInt(pills[i]) && y == Integer.parseInt(pills[i+1])) {
				result = "pill;" + x + ";" + y;
				return result;
			}
		}
		for (int i = 0 ; i < pads.length-1; i+=2) {
			if(x == Integer.parseInt(pads[i]) && y == Integer.parseInt(pads[i+1])) {
				result = "pad;" + x + ";" + y;
				(i/2
				//return pair of pads attached together
				return result;
			}
		}
		for (int i = 0 ; i < hostages.length-1; i+=3) {
			System.out.println(hostages[i]);
			if(x == Integer.parseInt(hostages[i]) && y == Integer.parseInt(hostages[i+1])) {
				result = "hostage";
				return result;
			}
		}
		
		return result;
	}
	
	public static void main(String[] args) {
		
		System.out.println(whatInCell(1,2, "3,3;1;0,0;1,1;0,1;1,2;0,2,2,0;1,0,0,2,1,50,2,2,90"));
	}
	
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2991)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:494)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-11-03 17:28:51.225
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2991)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:494)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-11-03 17:28:51.225
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2991)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:494)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-11-03 17:28:51.310
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package code;
import java.util.ArrayList;

import code.Location;

public class TreeNode {
	
	//list for tracking the previous cells visited to avoid repeated states
	public ArrayList<Location> prevCells;
	//current node location
	public Location myLoc;
	//number of current alive hostages
	public int hostagesNum;
	//number of mutant hostages that must be killed
	public int mutantHostagesNum;
	//track of neo's health/damage
	public int neoHealth;
	//the updated string according to the path that led to the current node
	public String grid;
	
	public TreeNode(ArrayList<Location> prevCells, Location myLoc, int hNum, int mHNum, int neoH, String grid) {
		
		this.prevCells = prevCells;
		this.myLoc = myLoc;
		this.hostagesNum = hNum;
		this.mutantHostagesNum = mHNum;
		this.neoHealth = neoH;
		this.grid = grid;		
		
	}
	
	//method to print the content of any array
	public static void printArr (String[] arr)
	{
		for ( int i = 0 ; i < arr.length; i++) {
			System.out.print(arr[i]);
		}
		System.out.println(" ");
	}
	
	// we need to add the locations of mutant hostages in the grid
	// or implement a method that checks the damage of all hostages
	
	//return array of important values like name of the object
	//for example hostage and health
	//pad and locations
	
	
	//method to get the content of the given cell
	//can be used to determine the surroundings of the current cell 
	public static String whatInCell(int x, int y, String grid) {
		String result = "";
		//split the grid at ; to extract different categories in the grid
		String[] splitted = grid.split(";");
		//array that consists of (x,y) of the telephone booth
		String[] telephone = splitted[3].split(",");
		//array that contains locations of all the agents
		String[] agents = splitted[4].split(",");
		//array that contains locations of all pills
		String[] pills = splitted[5].split(",");
		//array that contains locations of all the pads
		//this array is always divisible by 4 since the pad comes in pairs
		//(startx, starty, finishx, finishy)
		String[] pads = splitted[6].split(",");
		//array that contains locations of all the hostages
		String[] hostages = splitted[7].split(",");
		
		if(x == Integer.parseInt(telephone[0]) && y == Integer.parseInt(telephone[1])) {
			result = "telephone;" + x + ";" + y;
			return result;
		}
		for (int i = 0 ; i < agents.length-1; i+=2) {
			if(x == Integer.parseInt(agents[i]) && y == Integer.parseInt(agents[i+1])) {
				result = "agent;" + x + ";" + y;
				return result;
			}
		}
		for (int i = 0 ; i < pills.length-1; i+=2) {
			if(x == Integer.parseInt(pills[i]) && y == Integer.parseInt(pills[i+1])) {
				result = "pill;" + x + ";" + y;
				return result;
			}
		}
		for (int i = 0 ; i < pads.length-1; i+=2) {
			if(x == Integer.parseInt(pads[i]) && y == Integer.parseInt(pads[i+1])) {
				result = "pad;" + x + ";" + y;
				(i/2
				//return pair of pads attached together
				return result;
			}
		}
		for (int i = 0 ; i < hostages.length-1; i+=3) {
			System.out.println(hostages[i]);
			if(x == Integer.parseInt(hostages[i]) && y == Integer.parseInt(hostages[i+1])) {
				result = "hostage";
				return result;
			}
		}
		
		return result;
	}
	
	public static void main(String[] args) {
		
		System.out.println(whatInCell(1,2, "3,3;1;0,0;1,1;0,1;1,2;0,2,2,0;1,0,0,2,1,50,2,2,90"));
	}
	
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2991)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-11-03 17:28:51.310
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2991)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-11-03 17:28:51.311
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2991)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-11-03 17:28:52.347
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package code;
import java.util.ArrayList;

import code.Location;

public class TreeNode {
	
	//list for tracking the previous cells visited to avoid repeated states
	public ArrayList<Location> prevCells;
	//current node location
	public Location myLoc;
	//number of current alive hostages
	public int hostagesNum;
	//number of mutant hostages that must be killed
	public int mutantHostagesNum;
	//track of neo's health/damage
	public int neoHealth;
	//the updated string according to the path that led to the current node
	public String grid;
	
	public TreeNode(ArrayList<Location> prevCells, Location myLoc, int hNum, int mHNum, int neoH, String grid) {
		
		this.prevCells = prevCells;
		this.myLoc = myLoc;
		this.hostagesNum = hNum;
		this.mutantHostagesNum = mHNum;
		this.neoHealth = neoH;
		this.grid = grid;		
		
	}
	
	//method to print the content of any array
	public static void printArr (String[] arr)
	{
		for ( int i = 0 ; i < arr.length; i++) {
			System.out.print(arr[i]);
		}
		System.out.println(" ");
	}
	
	// we need to add the locations of mutant hostages in the grid
	// or implement a method that checks the damage of all hostages
	
	//return array of important values like name of the object
	//for example hostage and health
	//pad and locations
	
	
	//method to get the content of the given cell
	//can be used to determine the surroundings of the current cell 
	public static String whatInCell(int x, int y, String grid) {
		String result = "";
		//split the grid at ; to extract different categories in the grid
		String[] splitted = grid.split(";");
		//array that consists of (x,y) of the telephone booth
		String[] telephone = splitted[3].split(",");
		//array that contains locations of all the agents
		String[] agents = splitted[4].split(",");
		//array that contains locations of all pills
		String[] pills = splitted[5].split(",");
		//array that contains locations of all the pads
		//this array is always divisible by 4 since the pad comes in pairs
		//(startx, starty, finishx, finishy)
		String[] pads = splitted[6].split(",");
		//array that contains locations of all the hostages
		String[] hostages = splitted[7].split(",");
		
		if(x == Integer.parseInt(telephone[0]) && y == Integer.parseInt(telephone[1])) {
			result = "telephone;" + x + ";" + y;
			return result;
		}
		for (int i = 0 ; i < agents.length-1; i+=2) {
			if(x == Integer.parseInt(agents[i]) && y == Integer.parseInt(agents[i+1])) {
				result = "agent;" + x + ";" + y;
				return result;
			}
		}
		for (int i = 0 ; i < pills.length-1; i+=2) {
			if(x == Integer.parseInt(pills[i]) && y == Integer.parseInt(pills[i+1])) {
				result = "pill;" + x + ";" + y;
				return result;
			}
		}
		for (int i = 0 ; i < pads.length-1; i+=2) {
			if(x == Integer.parseInt(pads[i]) && y == Integer.parseInt(pads[i+1])) {
				result = "pad;" + x + ";" + y;
				(i/2
				//return pair of pads attached together
				return result;
			}
		}
		for (int i = 0 ; i < hostages.length-1; i+=3) {
			System.out.println(hostages[i]);
			if(x == Integer.parseInt(hostages[i]) && y == Integer.parseInt(hostages[i+1])) {
				result = "hostage";
				return result;
			}
		}
		
		return result;
	}
	
	public static void main(String[] args) {
		
		System.out.println(whatInCell(1,2, "3,3;1;0,0;1,1;0,1;1,2;0,2,2,0;1,0,0,2,1,50,2,2,90"));
	}
	
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2991)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-11-03 17:28:52.347
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2991)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-11-03 17:28:52.348
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2991)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-11-03 17:29:00.238
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package code;
import java.util.ArrayList;

import code.Location;

public class TreeNode {
	
	//list for tracking the previous cells visited to avoid repeated states
	public ArrayList<Location> prevCells;
	//current node location
	public Location myLoc;
	//number of current alive hostages
	public int hostagesNum;
	//number of mutant hostages that must be killed
	public int mutantHostagesNum;
	//track of neo's health/damage
	public int neoHealth;
	//the updated string according to the path that led to the current node
	public String grid;
	
	public TreeNode(ArrayList<Location> prevCells, Location myLoc, int hNum, int mHNum, int neoH, String grid) {
		
		this.prevCells = prevCells;
		this.myLoc = myLoc;
		this.hostagesNum = hNum;
		this.mutantHostagesNum = mHNum;
		this.neoHealth = neoH;
		this.grid = grid;		
		
	}
	
	//method to print the content of any array
	public static void printArr (String[] arr)
	{
		for ( int i = 0 ; i < arr.length; i++) {
			System.out.print(arr[i]);
		}
		System.out.println(" ");
	}
	
	// we need to add the locations of mutant hostages in the grid
	// or implement a method that checks the damage of all hostages
	
	//return array of important values like name of the object
	//for example hostage and health
	//pad and locations
	
	
	//method to get the content of the given cell
	//can be used to determine the surroundings of the current cell 
	public static String whatInCell(int x, int y, String grid) {
		String result = "";
		//split the grid at ; to extract different categories in the grid
		String[] splitted = grid.split(";");
		//array that consists of (x,y) of the telephone booth
		String[] telephone = splitted[3].split(",");
		//array that contains locations of all the agents
		String[] agents = splitted[4].split(",");
		//array that contains locations of all pills
		String[] pills = splitted[5].split(",");
		//array that contains locations of all the pads
		//this array is always divisible by 4 since the pad comes in pairs
		//(startx, starty, finishx, finishy)
		String[] pads = splitted[6].split(",");
		//array that contains locations of all the hostages
		String[] hostages = splitted[7].split(",");
		
		if(x == Integer.parseInt(telephone[0]) && y == Integer.parseInt(telephone[1])) {
			result = "telephone;" + x + ";" + y;
			return result;
		}
		for (int i = 0 ; i < agents.length-1; i+=2) {
			if(x == Integer.parseInt(agents[i]) && y == Integer.parseInt(agents[i+1])) {
				result = "agent;" + x + ";" + y;
				return result;
			}
		}
		for (int i = 0 ; i < pills.length-1; i+=2) {
			if(x == Integer.parseInt(pills[i]) && y == Integer.parseInt(pills[i+1])) {
				result = "pill;" + x + ";" + y;
				return result;
			}
		}
		for (int i = 0 ; i < pads.length-1; i+=2) {
			if(x == Integer.parseInt(pads[i]) && y == Integer.parseInt(pads[i+1])) {
				result = "pad;" + x + ";" + y;
				(i/2)
				//return pair of pads attached together
				return result;
			}
		}
		for (int i = 0 ; i < hostages.length-1; i+=3) {
			System.out.println(hostages[i]);
			if(x == Integer.parseInt(hostages[i]) && y == Integer.parseInt(hostages[i+1])) {
				result = "hostage";
				return result;
			}
		}
		
		return result;
	}
	
	public static void main(String[] args) {
		
		System.out.println(whatInCell(1,2, "3,3;1;0,0;1,1;0,1;1,2;0,2,2,0;1,0,0,2,1,50,2,2,90"));
	}
	
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2991)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:494)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-11-03 17:29:00.239
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2991)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:494)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-11-03 17:29:00.239
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2991)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:494)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-11-03 17:29:00.245
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package code;
import java.util.ArrayList;

import code.Location;

public class TreeNode {
	
	//list for tracking the previous cells visited to avoid repeated states
	public ArrayList<Location> prevCells;
	//current node location
	public Location myLoc;
	//number of current alive hostages
	public int hostagesNum;
	//number of mutant hostages that must be killed
	public int mutantHostagesNum;
	//track of neo's health/damage
	public int neoHealth;
	//the updated string according to the path that led to the current node
	public String grid;
	
	public TreeNode(ArrayList<Location> prevCells, Location myLoc, int hNum, int mHNum, int neoH, String grid) {
		
		this.prevCells = prevCells;
		this.myLoc = myLoc;
		this.hostagesNum = hNum;
		this.mutantHostagesNum = mHNum;
		this.neoHealth = neoH;
		this.grid = grid;		
		
	}
	
	//method to print the content of any array
	public static void printArr (String[] arr)
	{
		for ( int i = 0 ; i < arr.length; i++) {
			System.out.print(arr[i]);
		}
		System.out.println(" ");
	}
	
	// we need to add the locations of mutant hostages in the grid
	// or implement a method that checks the damage of all hostages
	
	//return array of important values like name of the object
	//for example hostage and health
	//pad and locations
	
	
	//method to get the content of the given cell
	//can be used to determine the surroundings of the current cell 
	public static String whatInCell(int x, int y, String grid) {
		String result = "";
		//split the grid at ; to extract different categories in the grid
		String[] splitted = grid.split(";");
		//array that consists of (x,y) of the telephone booth
		String[] telephone = splitted[3].split(",");
		//array that contains locations of all the agents
		String[] agents = splitted[4].split(",");
		//array that contains locations of all pills
		String[] pills = splitted[5].split(",");
		//array that contains locations of all the pads
		//this array is always divisible by 4 since the pad comes in pairs
		//(startx, starty, finishx, finishy)
		String[] pads = splitted[6].split(",");
		//array that contains locations of all the hostages
		String[] hostages = splitted[7].split(",");
		
		if(x == Integer.parseInt(telephone[0]) && y == Integer.parseInt(telephone[1])) {
			result = "telephone;" + x + ";" + y;
			return result;
		}
		for (int i = 0 ; i < agents.length-1; i+=2) {
			if(x == Integer.parseInt(agents[i]) && y == Integer.parseInt(agents[i+1])) {
				result = "agent;" + x + ";" + y;
				return result;
			}
		}
		for (int i = 0 ; i < pills.length-1; i+=2) {
			if(x == Integer.parseInt(pills[i]) && y == Integer.parseInt(pills[i+1])) {
				result = "pill;" + x + ";" + y;
				return result;
			}
		}
		for (int i = 0 ; i < pads.length-1; i+=2) {
			if(x == Integer.parseInt(pads[i]) && y == Integer.parseInt(pads[i+1])) {
				result = "pad;" + x + ";" + y;
				(i/2)
				//return pair of pads attached together
				return result;
			}
		}
		for (int i = 0 ; i < hostages.length-1; i+=3) {
			System.out.println(hostages[i]);
			if(x == Integer.parseInt(hostages[i]) && y == Integer.parseInt(hostages[i+1])) {
				result = "hostage";
				return result;
			}
		}
		
		return result;
	}
	
	public static void main(String[] args) {
		
		System.out.println(whatInCell(1,2, "3,3;1;0,0;1,1;0,1;1,2;0,2,2,0;1,0,0,2,1,50,2,2,90"));
	}
	
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2991)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-11-03 17:29:00.245
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2991)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-11-03 17:29:00.246
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2991)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-11-03 17:29:18.756
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package code;
import java.util.ArrayList;

import code.Location;

public class TreeNode {
	
	//list for tracking the previous cells visited to avoid repeated states
	public ArrayList<Location> prevCells;
	//current node location
	public Location myLoc;
	//number of current alive hostages
	public int hostagesNum;
	//number of mutant hostages that must be killed
	public int mutantHostagesNum;
	//track of neo's health/damage
	public int neoHealth;
	//the updated string according to the path that led to the current node
	public String grid;
	
	public TreeNode(ArrayList<Location> prevCells, Location myLoc, int hNum, int mHNum, int neoH, String grid) {
		
		this.prevCells = prevCells;
		this.myLoc = myLoc;
		this.hostagesNum = hNum;
		this.mutantHostagesNum = mHNum;
		this.neoHealth = neoH;
		this.grid = grid;		
		
	}
	
	//method to print the content of any array
	public static void printArr (String[] arr)
	{
		for ( int i = 0 ; i < arr.length; i++) {
			System.out.print(arr[i]);
		}
		System.out.println(" ");
	}
	
	// we need to add the locations of mutant hostages in the grid
	// or implement a method that checks the damage of all hostages
	
	//return array of important values like name of the object
	//for example hostage and health
	//pad and locations
	
	
	//method to get the content of the given cell
	//can be used to determine the surroundings of the current cell 
	public static String whatInCell(int x, int y, String grid) {
		String result = "";
		//split the grid at ; to extract different categories in the grid
		String[] splitted = grid.split(";");
		//array that consists of (x,y) of the telephone booth
		String[] telephone = splitted[3].split(",");
		//array that contains locations of all the agents
		String[] agents = splitted[4].split(",");
		//array that contains locations of all pills
		String[] pills = splitted[5].split(",");
		//array that contains locations of all the pads
		//this array is always divisible by 4 since the pad comes in pairs
		//(startx, starty, finishx, finishy)
		String[] pads = splitted[6].split(",");
		//array that contains locations of all the hostages
		String[] hostages = splitted[7].split(",");
		
		if(x == Integer.parseInt(telephone[0]) && y == Integer.parseInt(telephone[1])) {
			result = "telephone;" + x + ";" + y;
			return result;
		}
		for (int i = 0 ; i < agents.length-1; i+=2) {
			if(x == Integer.parseInt(agents[i]) && y == Integer.parseInt(agents[i+1])) {
				result = "agent;" + x + ";" + y;
				return result;
			}
		}
		for (int i = 0 ; i < pills.length-1; i+=2) {
			if(x == Integer.parseInt(pills[i]) && y == Integer.parseInt(pills[i+1])) {
				result = "pill;" + x + ";" + y;
				return result;
			}
		}
		for (int i = 0 ; i < pads.length-1; i+=2) {
			if(x == Integer.parseInt(pads[i]) && y == Integer.parseInt(pads[i+1])) {
				result = "pad;" + x + ";" + y;
				(i/2)//
				//return pair of pads attached together
				return result;
			}
		}
		for (int i = 0 ; i < hostages.length-1; i+=3) {
			System.out.println(hostages[i]);
			if(x == Integer.parseInt(hostages[i]) && y == Integer.parseInt(hostages[i+1])) {
				result = "hostage";
				return result;
			}
		}
		
		return result;
	}
	
	public static void main(String[] args) {
		
		System.out.println(whatInCell(1,2, "3,3;1;0,0;1,1;0,1;1,2;0,2,2,0;1,0,0,2,1,50,2,2,90"));
	}
	
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2991)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:494)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-11-03 17:29:18.756
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2991)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:494)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-11-03 17:29:18.757
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2991)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:494)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-11-03 17:29:18.762
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package code;
import java.util.ArrayList;

import code.Location;

public class TreeNode {
	
	//list for tracking the previous cells visited to avoid repeated states
	public ArrayList<Location> prevCells;
	//current node location
	public Location myLoc;
	//number of current alive hostages
	public int hostagesNum;
	//number of mutant hostages that must be killed
	public int mutantHostagesNum;
	//track of neo's health/damage
	public int neoHealth;
	//the updated string according to the path that led to the current node
	public String grid;
	
	public TreeNode(ArrayList<Location> prevCells, Location myLoc, int hNum, int mHNum, int neoH, String grid) {
		
		this.prevCells = prevCells;
		this.myLoc = myLoc;
		this.hostagesNum = hNum;
		this.mutantHostagesNum = mHNum;
		this.neoHealth = neoH;
		this.grid = grid;		
		
	}
	
	//method to print the content of any array
	public static void printArr (String[] arr)
	{
		for ( int i = 0 ; i < arr.length; i++) {
			System.out.print(arr[i]);
		}
		System.out.println(" ");
	}
	
	// we need to add the locations of mutant hostages in the grid
	// or implement a method that checks the damage of all hostages
	
	//return array of important values like name of the object
	//for example hostage and health
	//pad and locations
	
	
	//method to get the content of the given cell
	//can be used to determine the surroundings of the current cell 
	public static String whatInCell(int x, int y, String grid) {
		String result = "";
		//split the grid at ; to extract different categories in the grid
		String[] splitted = grid.split(";");
		//array that consists of (x,y) of the telephone booth
		String[] telephone = splitted[3].split(",");
		//array that contains locations of all the agents
		String[] agents = splitted[4].split(",");
		//array that contains locations of all pills
		String[] pills = splitted[5].split(",");
		//array that contains locations of all the pads
		//this array is always divisible by 4 since the pad comes in pairs
		//(startx, starty, finishx, finishy)
		String[] pads = splitted[6].split(",");
		//array that contains locations of all the hostages
		String[] hostages = splitted[7].split(",");
		
		if(x == Integer.parseInt(telephone[0]) && y == Integer.parseInt(telephone[1])) {
			result = "telephone;" + x + ";" + y;
			return result;
		}
		for (int i = 0 ; i < agents.length-1; i+=2) {
			if(x == Integer.parseInt(agents[i]) && y == Integer.parseInt(agents[i+1])) {
				result = "agent;" + x + ";" + y;
				return result;
			}
		}
		for (int i = 0 ; i < pills.length-1; i+=2) {
			if(x == Integer.parseInt(pills[i]) && y == Integer.parseInt(pills[i+1])) {
				result = "pill;" + x + ";" + y;
				return result;
			}
		}
		for (int i = 0 ; i < pads.length-1; i+=2) {
			if(x == Integer.parseInt(pads[i]) && y == Integer.parseInt(pads[i+1])) {
				result = "pad;" + x + ";" + y;
				(i/2)//
				//return pair of pads attached together
				return result;
			}
		}
		for (int i = 0 ; i < hostages.length-1; i+=3) {
			System.out.println(hostages[i]);
			if(x == Integer.parseInt(hostages[i]) && y == Integer.parseInt(hostages[i+1])) {
				result = "hostage";
				return result;
			}
		}
		
		return result;
	}
	
	public static void main(String[] args) {
		
		System.out.println(whatInCell(1,2, "3,3;1;0,0;1,1;0,1;1,2;0,2,2,0;1,0,0,2,1,50,2,2,90"));
	}
	
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2991)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-11-03 17:29:18.762
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2991)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-11-03 17:29:18.762
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2214)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2994)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2991)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2021-11-03 22:26:38.321 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=16.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-03 22:26:50.744
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-03 22:26:50.744
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6d80e411,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@32caae19,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-03 22:26:53.882
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\safam'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-11-04 22:26:33.476 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=16.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-04 22:26:47.313
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-04 22:26:47.313
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6d80e411,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@32caae19,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-04 22:26:50.409
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\safam'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-11-06 17:03:57.997 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=16.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-06 17:04:08.722
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-06 17:04:08.723
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@32caae19,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@60e67c06,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-06 17:04:11.784
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\safam'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-11-07 00:08:00.152 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=16.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-07 00:08:04.699
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-07 00:08:04.699
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@72e36677,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6b86826a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-07 00:08:07.590
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\safam'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-11-07 11:12:28.691 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=16.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-07 11:13:16.813
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-07 11:13:16.813
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3c2dda7c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4b9fa2f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-07 11:13:20.345
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\safam'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-11-07 12:26:07.108 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=16.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-07 12:26:12.107
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-07 12:26:12.108
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4b9fa2f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6d80e411,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-07 12:26:14.695
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\safam'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-11-07 13:43:57.374 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=16.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-07 13:44:04.428
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-07 13:44:04.429
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@60e67c06,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2bc59ab7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-07 13:44:07.135
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\safam'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-11-07 14:08:02.918 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=16.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-07 14:08:07.731
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-07 14:08:07.731
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4b9fa2f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6d80e411,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-07 14:08:10.606
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\safam'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-11-07 19:08:42.867 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=16.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-07 19:09:03.973
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-07 19:09:03.973
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6b86826a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3c2dda7c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-07 19:09:07.434
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\safam'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-11-07 23:14:33.756 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=16.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-07 23:14:37.992
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-07 23:14:37.992
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4b9fa2f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6d80e411,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-07 23:14:40.504
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\safam'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-11-10 14:13:52.700 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=16.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-10 14:14:06.345
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-10 14:14:06.345
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6b86826a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3c2dda7c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-10 14:14:09.618
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\safam'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-11-10 23:50:43.824 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=16.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-10 23:50:47.444
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-10 23:50:47.444
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@39ae6408,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@cfacf0,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-10 23:50:50.001
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\safam'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-11-12 18:51:56.769 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=16.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-12 18:52:14.457
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-12 18:52:14.457
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@32caae19,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@60e67c06,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-12 18:52:17.527
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\safam'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-11-12 22:46:49.385 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=16.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-12 22:46:53.369
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-12 22:46:53.370
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@60e67c06,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2bc59ab7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-12 22:46:55.942
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\safam'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-11-14 13:44:47.403 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=16.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-14 13:44:58.780
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-14 13:44:58.780
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@60e67c06,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2bc59ab7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-14 13:45:02.163
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\safam'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-11-14 19:54:19.821 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=16.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-14 19:54:29.197
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-14 19:54:29.197
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4b9fa2f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6d80e411,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-14 19:54:31.739
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\safam'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-11-15 00:30:49.656 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=16.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-15 00:30:53.857
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-15 00:30:53.857
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7210f559,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@49b9ba6a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-15 00:30:57.056
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\safam'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-11-15 01:52:00.279 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=16.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-15 01:52:04.375
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-15 01:52:04.375
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4b9fa2f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6d80e411,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-15 01:52:07.100
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\safam'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-11-15 13:36:13.170 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=16.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-15 13:36:25.326
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-15 13:36:25.326
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6d80e411,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@32caae19,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-15 13:36:29.353
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\safam'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2021-11-15 23:13:13.054
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package code;

import java.util.ArrayList;

import code.Location;
import code.TreeNode;
import code.Queue.*;

public abstract class GeneralSearch {

	// habdyn el cost wl depth
	// check game over

	public static String generalSearch(String grid, String strategy, boolean visualize) {
		String result = "";
		//initialize everything as this is the start
		ArrayList<TreeNode> prevNodes = new ArrayList<TreeNode>();
		ArrayList<PreNode> preNodes = new ArrayList<PreNode>();
		String[] splitted = grid.split(";");
		//get Neo's starting position
		String[] preNeo = splitted[2].split(",");
		Location neo = new Location(Integer.parseInt(preNeo[0]), Integer.parseInt(preNeo[1]));
		//array to store the damages of the carried hostages
		//also used to keep track of the number of carried hostages
		ArrayList<Integer> carried = new ArrayList<Integer>();
		
		// create initial starting node
		##TO-DO
		// reminder: cost
		TreeNode start = new TreeNode(null, prevNodes, neo, 0, grid, 0, 0, "Start", 0, 0, carried);
		PreNode startPre = new PreNode("Start", neo, start, 0);

		prevNodes.add(start);

		// create the queue for search
		Queue queue;
		switch (strategy) {
		case ("DF"):
			queue = new DFQueue();
			break;
		default:
			//temporary
			queue = new DFQueue();
			break;
		}

		// get the possible actions for the starting node
		ArrayList<String> possibleActions = getPossibleActions(neo, grid);
		printArr(possibleActions);
		for (int i = 0; i < possibleActions.size(); i++) {
			String[] pa = possibleActions.get(i).split(",");
			Location affected = new Location(Integer.parseInt(pa[1]), Integer.parseInt(pa[2]));
			PreNode pn = new PreNode(pa[0], affected, start, 0);
			queue.enqueue(pn);
		}

		queue.display();

		boolean failed = false;
		String finalGrid = "";

		while (!queue.queue.isEmpty()) {
			System.out.println("habd2 ml awl");
			PreNode frontPreNode = queue.dequeue();
			boolean repeated = false;
			/*
			for (int i = 0 ; i < prevNodes.size(); i++) {
				if(frontPreNode.prevNode.myLoc.x == prevNodes.get(i).myLoc.x && 
						frontPreNode.prevNode.myLoc.y == prevNodes.get(i).myLoc.y) {
					if (!(queue.queue.isEmpty())) {
					frontPreNode = queue.dequeue();
					}
				}
			}
			*/
			TreeNode frontTreeNode = update(
					frontPreNode.action + "," + frontPreNode.affectedCell.x + "," + frontPreNode.affectedCell.y,
					frontPreNode.prevNode, prevNodes);
			for (int i = 0 ; i < prevNodes.size(); i++) {
				if(frontTreeNode.myLoc.x == prevNodes.get(i).myLoc.x && 
						frontTreeNode.myLoc.y == prevNodes.get(i).myLoc.y &&
						compareGrids(frontTreeNode.grid, prevNodes.get(i).grid) == true) {
					//ignore this path
					repeated = true;
					break;
					//if (!(queue.queue.isEmpty())) {
					//frontPreNode = queue.dequeue();
					//}
				}
			}
			if (repeated == true) {
				System.out.println("msh hakml");
				continue;
			}
			System.out.println("tamam");
			prevNodes.add(frontTreeNode);
			possibleActions = getPossibleActions(frontTreeNode.myLoc, frontTreeNode.grid);
			
			for (int i = 0; i < possibleActions.size(); i++) {
				String[] pa = possibleActions.get(i).split(",");
				//System.out.println(possibleActions.get(i));
				Location affected = new Location(Integer.parseInt(pa[1]), Integer.parseInt(pa[2]));
				PreNode pn = new PreNode(pa[0], affected, frontTreeNode, 0);
				queue.enqueue(pn);
				//queue.display();
			}
			boolean goal = isItGoal(frontTreeNode);
			System.out.println(frontPreNode.action);
			queue.display();
			if (queue.queue.isEmpty()) {
				failed = true;
			}
			
			if (frontTreeNode.neoDamage >= 100) {
				return "fail";
			}
			
			finalGrid = frontTreeNode.grid;

		}
		return finalGrid;
	}
	
	//this might be tricky if we needed the damages as a difference
	public static boolean compareGrids(String grid1, String grid2) {
		boolean similar = false;
		//if same number of agents and hostages and pills then similar
		String[] splitted1 = grid1.split(";");
		String[] splitted2 = grid2.split(";");
		String[] agents1 = splitted1[4].split(",");
		String[] agents2 = splitted2[4].split(",");
		if (agents1.length == agents2.length) {
			//check pills
			String[] pills1 = splitted1[5].split(",");
			String[] pills2 = splitted2[5].split(",");
			if (pills1.length == pills2.length) {
				//check hostages
				String[] hos1;
				if (splitted1.length <= 7 ) {
					//no more hostages
					hos1 = new String[0];
				}else {
					hos1 = splitted1[7].split(",");
				}
				
				String[] hos2;
				if (splitted2.length <= 7 ) {
					//no more hostages
					hos2 = new String[0];
				}else {
					hos2 = splitted2[7].split(",");
				}
				if (hos1.length ==hos2.length) {
					similar = true;
				}else {
					similar = false;
				}
			}else {
				similar = false;
			}
		}else {
			similar = false;
		}
		return similar;
	}

	// goal test
	public static boolean isItGoal(TreeNode n) {

		boolean goal = false;
		String grid = n.grid;
		ArrayList<String> hostages = getHostages(grid);
		ArrayList<String> mutantHostages = getMutantHostages(grid);
		if (mutantHostages.size() == 0 && hostages.size() == 0) {
			goal = true;
		}
		return goal;

	}

	// method to print the content of any array
	public static void printArr(ArrayList<String> arr) {
		for (int i = 0; i < arr.size(); i++) {
			System.out.println(arr.get(i));
		}
		System.out.println(" ");
	}

	// method to fill the hostages and damage
	public static ArrayList<String> getHostages(String grid) {
		ArrayList<String> result = new ArrayList<String>();
		String[] splitted = grid.split(";");
		// System.out.println(splitted.length);
		// array that contains locations of all the hostages
		String[] hostages;
		if (splitted.length <= 7) {
			hostages = new String[0];
		}else {
			hostages = splitted[7].split(",");
		}

		for (int i = 0; i < hostages.length - 1; i += 3) {
			// store the location and damage in a string
			String temp = "";
			// check the damage to know if mutant or alive
			// if mutant then skip this iteration
			if (Integer.parseInt(hostages[i + 2]) < 100) {
				temp += hostages[i] + "," + hostages[i + 1] + "," + hostages[i + 2];
				result.add(temp);
			}

		}

		return result;
	}

	// method to fill the mutant hostages
	public static ArrayList<String> getMutantHostages(String grid) {
		ArrayList<String> result = new ArrayList<String>();

		String[] splitted = grid.split(";");
		// array that contains locations of all the hostages
		String[] hostages;
		if (splitted.length <= 7) {
			hostages = new String[0];
		}else {
			hostages = splitted[7].split(",");
		}

		for (int i = 0; i < hostages.length - 1; i += 3) {
			// store the location in a string
			String temp = "";
			// check the damage to know if mutant or alive
			// if alive then skip this iteration
			if (Integer.parseInt(hostages[i + 2]) >= 100) {
				// add only the location since we do not need the damage
				temp += hostages[i] + "," + hostages[i + 1];
				result.add(temp);
			}

		}

		return result;
	}

	// method to get the content of the given cell and useful information about
	// content of cell
	// can be used to determine the surroundings of the current cell
	public static String whatInCell(int x, int y, String grid) {
		String result = "";
		// split the grid at ; to extract different categories in the grid
		String[] splitted = grid.split(";");
		// array that consists of (x,y) of the telephone booth
		String[] telephone = splitted[3].split(",");
		// array that contains locations of all the agents
		String[] agents = splitted[4].split(",");
		// array that contains locations of all pills
		String[] pills = splitted[5].split(",");
		// array that contains locations of all the pads
		// this array is always divisible by 4 since the pad comes in pairs
		// (startx, starty, finishx, finishy)
		String[] pads = splitted[6].split(",");
		// array that contains locations of all the hostages
		String[] hostages;
		if (splitted.length <=7) {
			hostages = new String[0];
		}else {
			hostages = splitted[7].split(",");
		}

		if (x == Integer.parseInt(telephone[0]) && y == Integer.parseInt(telephone[1])) {
			result = "telephone;" + x + ";" + y;
			return result;
		}
		for (int i = 0; i < agents.length - 1; i += 2) {
			if (x == Integer.parseInt(agents[i]) && y == Integer.parseInt(agents[i + 1])) {
				result = "agent;" + x + ";" + y;
				return result;
			}
		}
		for (int i = 0; i < pills.length - 1; i += 2) {
			if (x == Integer.parseInt(pills[i]) && y == Integer.parseInt(pills[i + 1])) {
				result = "pill;" + x + ";" + y;
				return result;
			}
		}
		for (int i = 0; i < pads.length - 1; i += 2) {
			if (x == Integer.parseInt(pads[i]) && y == Integer.parseInt(pads[i + 1])) {
				result = "pad;" + x + ";" + y;
				if ((i / 2) % 2 == 0) {
					result += ";" + pads[i + 2] + ";" + pads[i + 3];
				} else {
					result += ";" + pads[i - 2] + ";" + pads[i - 1];
				}
				// return pair of pads attached together
				return result;
			}
		}
		for (int i = 0; i < hostages.length - 1; i += 3) {
			if (x == Integer.parseInt(hostages[i]) && y == Integer.parseInt(hostages[i + 1])) {
				result = "hostage;" + x + ";" + y + ";" + hostages[i + 2];
				return result;
			}
		}

		return result;
	}

	// method to detect where can I move
	public static ArrayList<String> whereCanIMove(Location current, String grid) {
		ArrayList<String> result = new ArrayList<String>();
		// check all possible directions
		String[] splitted = grid.split(";");
		String[] dimensions = splitted[0].split(",");
		int cols = Integer.parseInt(dimensions[1]);
		int rows = Integer.parseInt(dimensions[0]);
		boolean up = false;
		boolean right = false;
		boolean down = false;
		boolean left = false;
		// check if I can go left
		if (current.y > 0) {
			// check if there is an agent or a mutant agent
			String upCellComponent = whatInCell(current.x, current.y - 1, grid);
			if (!(upCellComponent.contains("agent"))) {
				// check if there is a mutant hostage
				if (upCellComponent.contains("hostage")) {
					// check the damage to know if it is mutant
					String[] hos = upCellComponent.split(";");
					if (Integer.parseInt(hos[3]) < 100) {
						left = true;
					} else {
						result.add("KillLeft");
					}
				}
				left = true;
			} else {
				result.add("KillLeft");
			}
		}
		// check if I can go down
		if (current.x < rows - 1) {
			// check if there is an agent or a mutant agent
			String rightCellComponent = whatInCell(current.x + 1, current.y, grid);
			if (!(rightCellComponent.contains("agent"))) {
				// check if there is a mutant hostage
				if (rightCellComponent.contains("hostage")) {
					// System.out.println(rightCellComponent);
					// check the damage to know if it is mutant
					String[] hos = rightCellComponent.split(";");
					if (Integer.parseInt(hos[3]) < 100) {
						down = true;
					} else {
						result.add("KillDown");
					}
				}
				down = true;
			} else {
				result.add("KillDown");
			}
		}
		// check if I can go right
		if (current.y < cols - 1) {
			// check if there is an agent or a mutant agent
			String downCellComponent = whatInCell(current.x, current.y + 1, grid);
			if (!(downCellComponent.contains("agent"))) {
				// check if there is a mutant hostage
				if (downCellComponent.contains("hostage")) {
					// check the damage to know if it is mutant
					String[] hos = downCellComponent.split(";");
					if (Integer.parseInt(hos[3]) < 100) {
						right = true;
					} else {
						result.add("KillRight");
					}
				}
				right = true;
			} else {
				result.add("KillRight");
			}
		}
		// check if I can go Up
		if (current.x > 0) {
			// check if there is an agent or a mutant agent
			String leftCellComponent = whatInCell(current.x - 1, current.y, grid);
			if (!(leftCellComponent.contains("agent"))) {
				// check if there is a mutant hostage
				if (leftCellComponent.contains("hostage")) {
					// check the damage to know if it is mutant
					String[] hos = leftCellComponent.split(";");
					if (Integer.parseInt(hos[3]) < 100) {
						up = true;
					} else {
						result.add("KillUp");
					}
				}
				up = true;
			} else {
				result.add("KillUp");
			}
		}
		if (up) {
			result.add("Up");
		}
		if (right) {
			result.add("Right");
		}
		if (down) {
			result.add("Down");
		}
		if (left) {
			result.add("Left");
		}

		return result;
	}

	// method to detect possible actions and insert in queue
	// this method returns array of strings of the following format
	// "ActionName", "affectedLocation"
	public static ArrayList<String> getPossibleActions(Location current, String grid) {
		ArrayList<String> result = new ArrayList<String>();
		// check the current cell components
		String currentCellComponent = whatInCell(current.x, current.y, grid);
		if (currentCellComponent.contains("pill")) {
			// either take it or leave it
			result.add("Pill," + current.x + "," + current.y);
		}
		if (currentCellComponent.contains("hostage")) {
			// cannot be a mutant hostage because we do not add this option to happen during
			// movement
			result.add("Carry," + current.x + "," + current.y);
		}
		if (currentCellComponent.contains("pad")) {
			// get the go-to pad from the string
			String[] pillData = currentCellComponent.split(";");
			// we know that the current cell is the first pad in the string so ignore it
			int fx = Integer.parseInt(pillData[3]);
			int fy = Integer.parseInt(pillData[4]);
			result.add("Fly," + fx + "," + fy);
		}
		if (currentCellComponent.contains("telephone")) {
			// you can either drop or leave
			// check before drop if there is a hostage to drop
			result.add("Drop," + current.x + "," + current.y);
		}

		// get the possible movements
		ArrayList<String> movements = whereCanIMove(current, grid);
		if (!(movements.isEmpty())) {
			for (int i = 0; i < movements.size(); i++) {
				if (movements.get(i) == "Up") {
					result.add("Up," + (current.x - 1) + "," + current.y);
				} else if (movements.get(i) == "Right") {
					result.add("Right," + current.x + "," + (current.y + 1));
				} else if (movements.get(i) == "Down") {
					result.add("Down," + (current.x + 1) + "," + current.y);
				} else if (movements.get(i) == "Left") {
					result.add("Left," + current.x + "," + (current.y - 1));
				} else if (movements.get(i) == "KillUp") {
					result.add("Kill," + (current.x - 1) + "," + current.y);
				} else if (movements.get(i) == "KillRight") {
					result.add("Kill," + current.x + "," + (current.y + 1));
				} else if (movements.get(i) == "KillDown") {
					result.add("Kill," + (current.x + 1) + "," + current.y);
				} else if (movements.get(i) == "KillLeft") {
					result.add("Kill," + current.x + "," + (current.y - 1));
				}

			}
		}
		return result;

	}

	// reminder: make the location of the carried hostage should be that of neo
	// reminder: adjust damage abl maymot law pill
	// reminder e3mly el ba2y
	// 5aly update ta5od el node

	// updates everything needed according to the action taken
	// I think it should return the new grid string
	public static TreeNode update(String action, TreeNode prevNode, ArrayList<TreeNode> prevNodes) {
		// we assume that Neo starts with 0 damage
		// update damage of all hostages

		// resultant grid
		String result = "";
		// split the grid at ; to extract different categories in the grid
		String[] splitted = prevNode.grid.split(";");
		// since the dimensions and neo's initial position and TB position are constant,
		// append to result
		result += splitted[0] + ";" + splitted[1] + ";" + splitted[2] + ";" + splitted[3] + ";";

		// array that contains locations of all the agents
		String[] agents = splitted[4].split(",");
		// array that contains the locations of all mutant hostages
		ArrayList<String> mutantHostages = getMutantHostages(prevNode.grid);
		// array that contains locations of all the pills
		String[] pills = splitted[5].split(",");
		// array that contains locations of all the pads
		// this array is always divisible by 4 since the pad comes in pairs
		// (startx, starty, finishx, finishy)
		String pads = splitted[6];
		// array that contains locations of all the hostages
		// get this array from the method getHostages to avoid getting mutant hostages
		// from the grid string
		ArrayList<String> hostages = getHostages(prevNode.grid);
		ArrayList<Integer> carried = prevNode.carried;
		int deaths = prevNode.deaths;

		for (int i = 0; i < hostages.size(); i++) {
			// each entry in the arraylist is a string with commas splitting the x and y and
			// damage
			String[] splittedHos = hostages.get(i).split(",");
			// the third element is the damage
			int oldDamage = Integer.parseInt(splittedHos[2]) + 2;
			if (action == "Pill") {
				oldDamage -= 2;
			}
			// set the new damage
			hostages.set(i, splittedHos[0] + "," + splittedHos[1] + "," + oldDamage);
			// check if it reached 100
			if (oldDamage >= 100) {
				// remove this hostage from the hostages array and add it to mutant
				mutantHostages.add(hostages.get(i));
				hostages.remove(i);
				// update the grid by adding the new hostage damage
				// as we do not add a different category in the grid string to represent the
				// mutant hostages
				// we rely on having the damage of 100 or greater to reflect this change
			}
		}
		for (int i = 0; i < carried.size(); i++) {
			int d = carried.get(i);
			if (action == "Pill") {
				if (d < 100) {
					if (d < 20) {
						carried.set(i, 0);
					} else {
						carried.set(i, d - 20);
					}

				}
			} else if (d < 100) {
				carried.set(i, d + 2);
				if (carried.get(i) >= 100) {
					deaths++;
				}
			}

		}
		int kills = prevNode.kills;
		int neoD = prevNode.neoDamage;
		Location newLocation = prevNode.myLoc;

		// get the affected location from action
		String[] actionDetails = action.split(",");
		Location moveTo = new Location(Integer.parseInt(actionDetails[1]), Integer.parseInt(actionDetails[2]));

		// check the action performed and accordingly update the grid or damage
		switch (actionDetails[0]) {
		case ("Kill"):
			System.out.println("hamoot" + (prevNode.myLoc.y == Integer.parseInt(agents[1])));
			// update grid by removing the killed agent or mutant hostage
			// increment Neo's damage by 20
			kills++;
			neoD += 20;
			// increment the number of killings by 1 if it is an agent
			for (int i = 0; i < agents.length - 1; i += 2) {
				if (Integer.parseInt(actionDetails[1]) == Integer.parseInt(agents[i])
						&& Integer.parseInt(actionDetails[2]) == Integer.parseInt(agents[i + 1])) {
					
					// replace the x and y with negatives so that when we combine the string again
					// we can know that this is not valid
					
					agents[i] = "-1";
					agents[i + 1] = "-1";
					break;
				}
			}
			for (int i = 0; i < mutantHostages.size() - 1; i += 2) {
				if (prevNode.myLoc.x == Integer.parseInt(mutantHostages.get(i))
						&& prevNode.myLoc.y == Integer.parseInt(mutantHostages.get(i + 1))) {
					// remove the mutant hostages from the arraylist
					mutantHostages.remove(i + 1);
					mutantHostages.remove(i);
					// also remove the hostage from the grid string
					break;
				}
			}

			break;
		case ("Pill"):
			// update grid method above
			// Decrement the damages of hostages and Neo by 20
			for (int i = 0; i < pills.length - 1; i += 2) {
				if (prevNode.myLoc.x == Integer.parseInt(pills[i])
						&& prevNode.myLoc.y == Integer.parseInt(pills[i + 1])) {
					// replace the x and y with negatives so that when we combine the string again
					// we can know that this is not valid
					pills[i] = "-1";
					pills[i + 1] = "-1";
					break;
				}
			}

			if (neoD < 20) {
				neoD = 0;
			} else {
				neoD -= 20;
			}

			for (int i = 0; i < hostages.size(); i++) {
				// each entry in the arraylist is a string with commas splitting the x and y and
				// damage
				String[] splitted2 = hostages.get(i).split(",");
				// the third element is the damage
				// decrement by 22 because we already incremented by 2 at the beginning of the
				// method
				int oldDamage2 = Integer.parseInt(splitted2[2]);
				if (oldDamage2 < 20) {
					oldDamage2 = 0;
				} else {
					oldDamage2 -= 20;
				}
				// set the new damage
				if (oldDamage2 < 0) {
					hostages.set(i, splitted2[0] + "," + splitted2[1] + "," + oldDamage2);
					// check that is cannot reach below 0
				}
			}
			// Decrement Neo damage by 20
			break;
		case ("Carry"):
			// update grid method above
			int cAllowed = Integer.parseInt(splitted[1]);
			if (carried.size() + 1 < cAllowed) {
				// increment c by 1
				for (int i = 0; i < hostages.size() - 1; i += 3) {
					if (prevNode.myLoc.x == Integer.parseInt(hostages.get(i))
							&& prevNode.myLoc.y == Integer.parseInt(hostages.get(i + 1))) {
						// replace the x and y with negatives so that when we combine the string again
						// we can know that this is not valid

						// set the location to that of neo
						hostages.remove(i + 1);
						hostages.remove(i);
						carried.add(Integer.parseInt(hostages.remove(i + 2)));
						break;
					}
				}
			}

			break;
		case ("Drop"):
			// Reset carried
			prevNode.carried = new ArrayList<Integer>();
			carried = new ArrayList<Integer>();
			break;
		case ("Down"):
			System.out.println("here2");
			// nothing changes in the grid only the overall hostage damage increases by 2
			// and this is already handled above
			newLocation = moveTo;

			break;
		case ("Up"):
			// nothing changes in the grid only the overall hostage damage increases by 2
			// and this is already handled above
			newLocation = moveTo;

			break;
		case ("Right"):
			// nothing changes in the grid only the overall hostage damage increases by 2
			// and this is already handled above
			newLocation = moveTo;

			break;
		case ("Left"):
			// nothing changes in the grid only the overall hostage damage increases by 2
			// and this is already handled above
			newLocation = moveTo;

			break;
		case ("Fly"):
			// change hostages carried location
			// nothing changes in the grid only the overall hostage damage increases by 2
			// and this is already handled above
			newLocation = moveTo;
			break;
		default:
			break;
		}

		// then we need to form the new grid

		for (int i = 0; i < agents.length - 1; i += 2) {
			if (agents[i] == "-1") {
				// killed
				continue;
			} else {
				result += agents[i] + "," + agents[i + 1];
				if (i < agents.length - 3) {
					result += ",";
				}
			}
		}
		result += ";";

		for (int i = 0; i < pills.length - 1; i += 2) {
			if (pills[i] == "-1") {
				// taken
				continue;
			} else {

				result += pills[i] + "," + pills[i + 1];
				if (i < pills.length - 3) {
					result += ",";
				}
			}
		}

		result += ";" + pads + ";";

		for (int i = 0; i < hostages.size() - 2; i += 3) {
			result += hostages.get(i) + "," + hostages.get(i + 1) + "," + hostages.get(i + 2);
			if (i < hostages.size() - 4) {
				result += ",";
			}
		}

		// add the mutant hostages to the hostages category in the grid
		for (int i = 0; i < mutantHostages.size() - 1; i += 2) {
			result += mutantHostages.get(i) + "," + mutantHostages.get(i + 1) + "," + "100";
			if (i < mutantHostages.size() - 3) {
				result += ",";
			}
		}

		TreeNode resNode = new TreeNode(prevNode, prevNodes, newLocation, neoD, result, kills, deaths, actionDetails[0],
				prevNode.depth + 1, 0, carried);
		System.out.println(result + "griiiid");
		return resNode;

	}

	// raz3yn el depth wl costs
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:494)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-11-15 23:13:13.058
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:494)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-11-15 23:13:13.058
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:494)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-11-15 23:13:13.153
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package code;

import java.util.ArrayList;

import code.Location;
import code.TreeNode;
import code.Queue.*;

public abstract class GeneralSearch {

	// habdyn el cost wl depth
	// check game over

	public static String generalSearch(String grid, String strategy, boolean visualize) {
		String result = "";
		//initialize everything as this is the start
		ArrayList<TreeNode> prevNodes = new ArrayList<TreeNode>();
		ArrayList<PreNode> preNodes = new ArrayList<PreNode>();
		String[] splitted = grid.split(";");
		//get Neo's starting position
		String[] preNeo = splitted[2].split(",");
		Location neo = new Location(Integer.parseInt(preNeo[0]), Integer.parseInt(preNeo[1]));
		//array to store the damages of the carried hostages
		//also used to keep track of the number of carried hostages
		ArrayList<Integer> carried = new ArrayList<Integer>();
		
		// create initial starting node
		##TO-DO
		// reminder: cost
		TreeNode start = new TreeNode(null, prevNodes, neo, 0, grid, 0, 0, "Start", 0, 0, carried);
		PreNode startPre = new PreNode("Start", neo, start, 0);

		prevNodes.add(start);

		// create the queue for search
		Queue queue;
		switch (strategy) {
		case ("DF"):
			queue = new DFQueue();
			break;
		default:
			//temporary
			queue = new DFQueue();
			break;
		}

		// get the possible actions for the starting node
		ArrayList<String> possibleActions = getPossibleActions(neo, grid);
		printArr(possibleActions);
		for (int i = 0; i < possibleActions.size(); i++) {
			String[] pa = possibleActions.get(i).split(",");
			Location affected = new Location(Integer.parseInt(pa[1]), Integer.parseInt(pa[2]));
			PreNode pn = new PreNode(pa[0], affected, start, 0);
			queue.enqueue(pn);
		}

		queue.display();

		boolean failed = false;
		String finalGrid = "";

		while (!queue.queue.isEmpty()) {
			System.out.println("habd2 ml awl");
			PreNode frontPreNode = queue.dequeue();
			boolean repeated = false;
			/*
			for (int i = 0 ; i < prevNodes.size(); i++) {
				if(frontPreNode.prevNode.myLoc.x == prevNodes.get(i).myLoc.x && 
						frontPreNode.prevNode.myLoc.y == prevNodes.get(i).myLoc.y) {
					if (!(queue.queue.isEmpty())) {
					frontPreNode = queue.dequeue();
					}
				}
			}
			*/
			TreeNode frontTreeNode = update(
					frontPreNode.action + "," + frontPreNode.affectedCell.x + "," + frontPreNode.affectedCell.y,
					frontPreNode.prevNode, prevNodes);
			for (int i = 0 ; i < prevNodes.size(); i++) {
				if(frontTreeNode.myLoc.x == prevNodes.get(i).myLoc.x && 
						frontTreeNode.myLoc.y == prevNodes.get(i).myLoc.y &&
						compareGrids(frontTreeNode.grid, prevNodes.get(i).grid) == true) {
					//ignore this path
					repeated = true;
					break;
					//if (!(queue.queue.isEmpty())) {
					//frontPreNode = queue.dequeue();
					//}
				}
			}
			if (repeated == true) {
				System.out.println("msh hakml");
				continue;
			}
			System.out.println("tamam");
			prevNodes.add(frontTreeNode);
			possibleActions = getPossibleActions(frontTreeNode.myLoc, frontTreeNode.grid);
			
			for (int i = 0; i < possibleActions.size(); i++) {
				String[] pa = possibleActions.get(i).split(",");
				//System.out.println(possibleActions.get(i));
				Location affected = new Location(Integer.parseInt(pa[1]), Integer.parseInt(pa[2]));
				PreNode pn = new PreNode(pa[0], affected, frontTreeNode, 0);
				queue.enqueue(pn);
				//queue.display();
			}
			boolean goal = isItGoal(frontTreeNode);
			System.out.println(frontPreNode.action);
			queue.display();
			if (queue.queue.isEmpty()) {
				failed = true;
			}
			
			if (frontTreeNode.neoDamage >= 100) {
				return "fail";
			}
			
			finalGrid = frontTreeNode.grid;

		}
		return finalGrid;
	}
	
	//this might be tricky if we needed the damages as a difference
	public static boolean compareGrids(String grid1, String grid2) {
		boolean similar = false;
		//if same number of agents and hostages and pills then similar
		String[] splitted1 = grid1.split(";");
		String[] splitted2 = grid2.split(";");
		String[] agents1 = splitted1[4].split(",");
		String[] agents2 = splitted2[4].split(",");
		if (agents1.length == agents2.length) {
			//check pills
			String[] pills1 = splitted1[5].split(",");
			String[] pills2 = splitted2[5].split(",");
			if (pills1.length == pills2.length) {
				//check hostages
				String[] hos1;
				if (splitted1.length <= 7 ) {
					//no more hostages
					hos1 = new String[0];
				}else {
					hos1 = splitted1[7].split(",");
				}
				
				String[] hos2;
				if (splitted2.length <= 7 ) {
					//no more hostages
					hos2 = new String[0];
				}else {
					hos2 = splitted2[7].split(",");
				}
				if (hos1.length ==hos2.length) {
					similar = true;
				}else {
					similar = false;
				}
			}else {
				similar = false;
			}
		}else {
			similar = false;
		}
		return similar;
	}

	// goal test
	public static boolean isItGoal(TreeNode n) {

		boolean goal = false;
		String grid = n.grid;
		ArrayList<String> hostages = getHostages(grid);
		ArrayList<String> mutantHostages = getMutantHostages(grid);
		if (mutantHostages.size() == 0 && hostages.size() == 0) {
			goal = true;
		}
		return goal;

	}

	// method to print the content of any array
	public static void printArr(ArrayList<String> arr) {
		for (int i = 0; i < arr.size(); i++) {
			System.out.println(arr.get(i));
		}
		System.out.println(" ");
	}

	// method to fill the hostages and damage
	public static ArrayList<String> getHostages(String grid) {
		ArrayList<String> result = new ArrayList<String>();
		String[] splitted = grid.split(";");
		// System.out.println(splitted.length);
		// array that contains locations of all the hostages
		String[] hostages;
		if (splitted.length <= 7) {
			hostages = new String[0];
		}else {
			hostages = splitted[7].split(",");
		}

		for (int i = 0; i < hostages.length - 1; i += 3) {
			// store the location and damage in a string
			String temp = "";
			// check the damage to know if mutant or alive
			// if mutant then skip this iteration
			if (Integer.parseInt(hostages[i + 2]) < 100) {
				temp += hostages[i] + "," + hostages[i + 1] + "," + hostages[i + 2];
				result.add(temp);
			}

		}

		return result;
	}

	// method to fill the mutant hostages
	public static ArrayList<String> getMutantHostages(String grid) {
		ArrayList<String> result = new ArrayList<String>();

		String[] splitted = grid.split(";");
		// array that contains locations of all the hostages
		String[] hostages;
		if (splitted.length <= 7) {
			hostages = new String[0];
		}else {
			hostages = splitted[7].split(",");
		}

		for (int i = 0; i < hostages.length - 1; i += 3) {
			// store the location in a string
			String temp = "";
			// check the damage to know if mutant or alive
			// if alive then skip this iteration
			if (Integer.parseInt(hostages[i + 2]) >= 100) {
				// add only the location since we do not need the damage
				temp += hostages[i] + "," + hostages[i + 1];
				result.add(temp);
			}

		}

		return result;
	}

	// method to get the content of the given cell and useful information about
	// content of cell
	// can be used to determine the surroundings of the current cell
	public static String whatInCell(int x, int y, String grid) {
		String result = "";
		// split the grid at ; to extract different categories in the grid
		String[] splitted = grid.split(";");
		// array that consists of (x,y) of the telephone booth
		String[] telephone = splitted[3].split(",");
		// array that contains locations of all the agents
		String[] agents = splitted[4].split(",");
		// array that contains locations of all pills
		String[] pills = splitted[5].split(",");
		// array that contains locations of all the pads
		// this array is always divisible by 4 since the pad comes in pairs
		// (startx, starty, finishx, finishy)
		String[] pads = splitted[6].split(",");
		// array that contains locations of all the hostages
		String[] hostages;
		if (splitted.length <=7) {
			hostages = new String[0];
		}else {
			hostages = splitted[7].split(",");
		}

		if (x == Integer.parseInt(telephone[0]) && y == Integer.parseInt(telephone[1])) {
			result = "telephone;" + x + ";" + y;
			return result;
		}
		for (int i = 0; i < agents.length - 1; i += 2) {
			if (x == Integer.parseInt(agents[i]) && y == Integer.parseInt(agents[i + 1])) {
				result = "agent;" + x + ";" + y;
				return result;
			}
		}
		for (int i = 0; i < pills.length - 1; i += 2) {
			if (x == Integer.parseInt(pills[i]) && y == Integer.parseInt(pills[i + 1])) {
				result = "pill;" + x + ";" + y;
				return result;
			}
		}
		for (int i = 0; i < pads.length - 1; i += 2) {
			if (x == Integer.parseInt(pads[i]) && y == Integer.parseInt(pads[i + 1])) {
				result = "pad;" + x + ";" + y;
				if ((i / 2) % 2 == 0) {
					result += ";" + pads[i + 2] + ";" + pads[i + 3];
				} else {
					result += ";" + pads[i - 2] + ";" + pads[i - 1];
				}
				// return pair of pads attached together
				return result;
			}
		}
		for (int i = 0; i < hostages.length - 1; i += 3) {
			if (x == Integer.parseInt(hostages[i]) && y == Integer.parseInt(hostages[i + 1])) {
				result = "hostage;" + x + ";" + y + ";" + hostages[i + 2];
				return result;
			}
		}

		return result;
	}

	// method to detect where can I move
	public static ArrayList<String> whereCanIMove(Location current, String grid) {
		ArrayList<String> result = new ArrayList<String>();
		// check all possible directions
		String[] splitted = grid.split(";");
		String[] dimensions = splitted[0].split(",");
		int cols = Integer.parseInt(dimensions[1]);
		int rows = Integer.parseInt(dimensions[0]);
		boolean up = false;
		boolean right = false;
		boolean down = false;
		boolean left = false;
		// check if I can go left
		if (current.y > 0) {
			// check if there is an agent or a mutant agent
			String upCellComponent = whatInCell(current.x, current.y - 1, grid);
			if (!(upCellComponent.contains("agent"))) {
				// check if there is a mutant hostage
				if (upCellComponent.contains("hostage")) {
					// check the damage to know if it is mutant
					String[] hos = upCellComponent.split(";");
					if (Integer.parseInt(hos[3]) < 100) {
						left = true;
					} else {
						result.add("KillLeft");
					}
				}
				left = true;
			} else {
				result.add("KillLeft");
			}
		}
		// check if I can go down
		if (current.x < rows - 1) {
			// check if there is an agent or a mutant agent
			String rightCellComponent = whatInCell(current.x + 1, current.y, grid);
			if (!(rightCellComponent.contains("agent"))) {
				// check if there is a mutant hostage
				if (rightCellComponent.contains("hostage")) {
					// System.out.println(rightCellComponent);
					// check the damage to know if it is mutant
					String[] hos = rightCellComponent.split(";");
					if (Integer.parseInt(hos[3]) < 100) {
						down = true;
					} else {
						result.add("KillDown");
					}
				}
				down = true;
			} else {
				result.add("KillDown");
			}
		}
		// check if I can go right
		if (current.y < cols - 1) {
			// check if there is an agent or a mutant agent
			String downCellComponent = whatInCell(current.x, current.y + 1, grid);
			if (!(downCellComponent.contains("agent"))) {
				// check if there is a mutant hostage
				if (downCellComponent.contains("hostage")) {
					// check the damage to know if it is mutant
					String[] hos = downCellComponent.split(";");
					if (Integer.parseInt(hos[3]) < 100) {
						right = true;
					} else {
						result.add("KillRight");
					}
				}
				right = true;
			} else {
				result.add("KillRight");
			}
		}
		// check if I can go Up
		if (current.x > 0) {
			// check if there is an agent or a mutant agent
			String leftCellComponent = whatInCell(current.x - 1, current.y, grid);
			if (!(leftCellComponent.contains("agent"))) {
				// check if there is a mutant hostage
				if (leftCellComponent.contains("hostage")) {
					// check the damage to know if it is mutant
					String[] hos = leftCellComponent.split(";");
					if (Integer.parseInt(hos[3]) < 100) {
						up = true;
					} else {
						result.add("KillUp");
					}
				}
				up = true;
			} else {
				result.add("KillUp");
			}
		}
		if (up) {
			result.add("Up");
		}
		if (right) {
			result.add("Right");
		}
		if (down) {
			result.add("Down");
		}
		if (left) {
			result.add("Left");
		}

		return result;
	}

	// method to detect possible actions and insert in queue
	// this method returns array of strings of the following format
	// "ActionName", "affectedLocation"
	public static ArrayList<String> getPossibleActions(Location current, String grid) {
		ArrayList<String> result = new ArrayList<String>();
		// check the current cell components
		String currentCellComponent = whatInCell(current.x, current.y, grid);
		if (currentCellComponent.contains("pill")) {
			// either take it or leave it
			result.add("Pill," + current.x + "," + current.y);
		}
		if (currentCellComponent.contains("hostage")) {
			// cannot be a mutant hostage because we do not add this option to happen during
			// movement
			result.add("Carry," + current.x + "," + current.y);
		}
		if (currentCellComponent.contains("pad")) {
			// get the go-to pad from the string
			String[] pillData = currentCellComponent.split(";");
			// we know that the current cell is the first pad in the string so ignore it
			int fx = Integer.parseInt(pillData[3]);
			int fy = Integer.parseInt(pillData[4]);
			result.add("Fly," + fx + "," + fy);
		}
		if (currentCellComponent.contains("telephone")) {
			// you can either drop or leave
			// check before drop if there is a hostage to drop
			result.add("Drop," + current.x + "," + current.y);
		}

		// get the possible movements
		ArrayList<String> movements = whereCanIMove(current, grid);
		if (!(movements.isEmpty())) {
			for (int i = 0; i < movements.size(); i++) {
				if (movements.get(i) == "Up") {
					result.add("Up," + (current.x - 1) + "," + current.y);
				} else if (movements.get(i) == "Right") {
					result.add("Right," + current.x + "," + (current.y + 1));
				} else if (movements.get(i) == "Down") {
					result.add("Down," + (current.x + 1) + "," + current.y);
				} else if (movements.get(i) == "Left") {
					result.add("Left," + current.x + "," + (current.y - 1));
				} else if (movements.get(i) == "KillUp") {
					result.add("Kill," + (current.x - 1) + "," + current.y);
				} else if (movements.get(i) == "KillRight") {
					result.add("Kill," + current.x + "," + (current.y + 1));
				} else if (movements.get(i) == "KillDown") {
					result.add("Kill," + (current.x + 1) + "," + current.y);
				} else if (movements.get(i) == "KillLeft") {
					result.add("Kill," + current.x + "," + (current.y - 1));
				}

			}
		}
		return result;

	}

	// reminder: make the location of the carried hostage should be that of neo
	// reminder: adjust damage abl maymot law pill
	// reminder e3mly el ba2y
	// 5aly update ta5od el node

	// updates everything needed according to the action taken
	// I think it should return the new grid string
	public static TreeNode update(String action, TreeNode prevNode, ArrayList<TreeNode> prevNodes) {
		// we assume that Neo starts with 0 damage
		// update damage of all hostages

		// resultant grid
		String result = "";
		// split the grid at ; to extract different categories in the grid
		String[] splitted = prevNode.grid.split(";");
		// since the dimensions and neo's initial position and TB position are constant,
		// append to result
		result += splitted[0] + ";" + splitted[1] + ";" + splitted[2] + ";" + splitted[3] + ";";

		// array that contains locations of all the agents
		String[] agents = splitted[4].split(",");
		// array that contains the locations of all mutant hostages
		ArrayList<String> mutantHostages = getMutantHostages(prevNode.grid);
		// array that contains locations of all the pills
		String[] pills = splitted[5].split(",");
		// array that contains locations of all the pads
		// this array is always divisible by 4 since the pad comes in pairs
		// (startx, starty, finishx, finishy)
		String pads = splitted[6];
		// array that contains locations of all the hostages
		// get this array from the method getHostages to avoid getting mutant hostages
		// from the grid string
		ArrayList<String> hostages = getHostages(prevNode.grid);
		ArrayList<Integer> carried = prevNode.carried;
		int deaths = prevNode.deaths;

		for (int i = 0; i < hostages.size(); i++) {
			// each entry in the arraylist is a string with commas splitting the x and y and
			// damage
			String[] splittedHos = hostages.get(i).split(",");
			// the third element is the damage
			int oldDamage = Integer.parseInt(splittedHos[2]) + 2;
			if (action == "Pill") {
				oldDamage -= 2;
			}
			// set the new damage
			hostages.set(i, splittedHos[0] + "," + splittedHos[1] + "," + oldDamage);
			// check if it reached 100
			if (oldDamage >= 100) {
				// remove this hostage from the hostages array and add it to mutant
				mutantHostages.add(hostages.get(i));
				hostages.remove(i);
				// update the grid by adding the new hostage damage
				// as we do not add a different category in the grid string to represent the
				// mutant hostages
				// we rely on having the damage of 100 or greater to reflect this change
			}
		}
		for (int i = 0; i < carried.size(); i++) {
			int d = carried.get(i);
			if (action == "Pill") {
				if (d < 100) {
					if (d < 20) {
						carried.set(i, 0);
					} else {
						carried.set(i, d - 20);
					}

				}
			} else if (d < 100) {
				carried.set(i, d + 2);
				if (carried.get(i) >= 100) {
					deaths++;
				}
			}

		}
		int kills = prevNode.kills;
		int neoD = prevNode.neoDamage;
		Location newLocation = prevNode.myLoc;

		// get the affected location from action
		String[] actionDetails = action.split(",");
		Location moveTo = new Location(Integer.parseInt(actionDetails[1]), Integer.parseInt(actionDetails[2]));

		// check the action performed and accordingly update the grid or damage
		switch (actionDetails[0]) {
		case ("Kill"):
			System.out.println("hamoot" + (prevNode.myLoc.y == Integer.parseInt(agents[1])));
			// update grid by removing the killed agent or mutant hostage
			// increment Neo's damage by 20
			kills++;
			neoD += 20;
			// increment the number of killings by 1 if it is an agent
			for (int i = 0; i < agents.length - 1; i += 2) {
				if (Integer.parseInt(actionDetails[1]) == Integer.parseInt(agents[i])
						&& Integer.parseInt(actionDetails[2]) == Integer.parseInt(agents[i + 1])) {
					
					// replace the x and y with negatives so that when we combine the string again
					// we can know that this is not valid
					
					agents[i] = "-1";
					agents[i + 1] = "-1";
					break;
				}
			}
			for (int i = 0; i < mutantHostages.size() - 1; i += 2) {
				if (prevNode.myLoc.x == Integer.parseInt(mutantHostages.get(i))
						&& prevNode.myLoc.y == Integer.parseInt(mutantHostages.get(i + 1))) {
					// remove the mutant hostages from the arraylist
					mutantHostages.remove(i + 1);
					mutantHostages.remove(i);
					// also remove the hostage from the grid string
					break;
				}
			}

			break;
		case ("Pill"):
			// update grid method above
			// Decrement the damages of hostages and Neo by 20
			for (int i = 0; i < pills.length - 1; i += 2) {
				if (prevNode.myLoc.x == Integer.parseInt(pills[i])
						&& prevNode.myLoc.y == Integer.parseInt(pills[i + 1])) {
					// replace the x and y with negatives so that when we combine the string again
					// we can know that this is not valid
					pills[i] = "-1";
					pills[i + 1] = "-1";
					break;
				}
			}

			if (neoD < 20) {
				neoD = 0;
			} else {
				neoD -= 20;
			}

			for (int i = 0; i < hostages.size(); i++) {
				// each entry in the arraylist is a string with commas splitting the x and y and
				// damage
				String[] splitted2 = hostages.get(i).split(",");
				// the third element is the damage
				// decrement by 22 because we already incremented by 2 at the beginning of the
				// method
				int oldDamage2 = Integer.parseInt(splitted2[2]);
				if (oldDamage2 < 20) {
					oldDamage2 = 0;
				} else {
					oldDamage2 -= 20;
				}
				// set the new damage
				if (oldDamage2 < 0) {
					hostages.set(i, splitted2[0] + "," + splitted2[1] + "," + oldDamage2);
					// check that is cannot reach below 0
				}
			}
			// Decrement Neo damage by 20
			break;
		case ("Carry"):
			// update grid method above
			int cAllowed = Integer.parseInt(splitted[1]);
			if (carried.size() + 1 < cAllowed) {
				// increment c by 1
				for (int i = 0; i < hostages.size() - 1; i += 3) {
					if (prevNode.myLoc.x == Integer.parseInt(hostages.get(i))
							&& prevNode.myLoc.y == Integer.parseInt(hostages.get(i + 1))) {
						// replace the x and y with negatives so that when we combine the string again
						// we can know that this is not valid

						// set the location to that of neo
						hostages.remove(i + 1);
						hostages.remove(i);
						carried.add(Integer.parseInt(hostages.remove(i + 2)));
						break;
					}
				}
			}

			break;
		case ("Drop"):
			// Reset carried
			prevNode.carried = new ArrayList<Integer>();
			carried = new ArrayList<Integer>();
			break;
		case ("Down"):
			System.out.println("here2");
			// nothing changes in the grid only the overall hostage damage increases by 2
			// and this is already handled above
			newLocation = moveTo;

			break;
		case ("Up"):
			// nothing changes in the grid only the overall hostage damage increases by 2
			// and this is already handled above
			newLocation = moveTo;

			break;
		case ("Right"):
			// nothing changes in the grid only the overall hostage damage increases by 2
			// and this is already handled above
			newLocation = moveTo;

			break;
		case ("Left"):
			// nothing changes in the grid only the overall hostage damage increases by 2
			// and this is already handled above
			newLocation = moveTo;

			break;
		case ("Fly"):
			// change hostages carried location
			// nothing changes in the grid only the overall hostage damage increases by 2
			// and this is already handled above
			newLocation = moveTo;
			break;
		default:
			break;
		}

		// then we need to form the new grid

		for (int i = 0; i < agents.length - 1; i += 2) {
			if (agents[i] == "-1") {
				// killed
				continue;
			} else {
				result += agents[i] + "," + agents[i + 1];
				if (i < agents.length - 3) {
					result += ",";
				}
			}
		}
		result += ";";

		for (int i = 0; i < pills.length - 1; i += 2) {
			if (pills[i] == "-1") {
				// taken
				continue;
			} else {

				result += pills[i] + "," + pills[i + 1];
				if (i < pills.length - 3) {
					result += ",";
				}
			}
		}

		result += ";" + pads + ";";

		for (int i = 0; i < hostages.size() - 2; i += 3) {
			result += hostages.get(i) + "," + hostages.get(i + 1) + "," + hostages.get(i + 2);
			if (i < hostages.size() - 4) {
				result += ",";
			}
		}

		// add the mutant hostages to the hostages category in the grid
		for (int i = 0; i < mutantHostages.size() - 1; i += 2) {
			result += mutantHostages.get(i) + "," + mutantHostages.get(i + 1) + "," + "100";
			if (i < mutantHostages.size() - 3) {
				result += ",";
			}
		}

		TreeNode resNode = new TreeNode(prevNode, prevNodes, newLocation, neoD, result, kills, deaths, actionDetails[0],
				prevNode.depth + 1, 0, carried);
		System.out.println(result + "griiiid");
		return resNode;

	}

	// raz3yn el depth wl costs
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-11-15 23:13:13.155
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-11-15 23:13:13.155
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-11-15 23:13:15.126
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package code;

import java.util.ArrayList;

import code.Location;
import code.TreeNode;
import code.Queue.*;

public abstract class GeneralSearch {

	// habdyn el cost wl depth
	// check game over

	public static String generalSearch(String grid, String strategy, boolean visualize) {
		String result = "";
		//initialize everything as this is the start
		ArrayList<TreeNode> prevNodes = new ArrayList<TreeNode>();
		ArrayList<PreNode> preNodes = new ArrayList<PreNode>();
		String[] splitted = grid.split(";");
		//get Neo's starting position
		String[] preNeo = splitted[2].split(",");
		Location neo = new Location(Integer.parseInt(preNeo[0]), Integer.parseInt(preNeo[1]));
		//array to store the damages of the carried hostages
		//also used to keep track of the number of carried hostages
		ArrayList<Integer> carried = new ArrayList<Integer>();
		
		// create initial starting node
		##TO-DO
		// reminder: cost
		TreeNode start = new TreeNode(null, prevNodes, neo, 0, grid, 0, 0, "Start", 0, 0, carried);
		PreNode startPre = new PreNode("Start", neo, start, 0);

		prevNodes.add(start);

		// create the queue for search
		Queue queue;
		switch (strategy) {
		case ("DF"):
			queue = new DFQueue();
			break;
		default:
			//temporary
			queue = new DFQueue();
			break;
		}

		// get the possible actions for the starting node
		ArrayList<String> possibleActions = getPossibleActions(neo, grid);
		printArr(possibleActions);
		for (int i = 0; i < possibleActions.size(); i++) {
			String[] pa = possibleActions.get(i).split(",");
			Location affected = new Location(Integer.parseInt(pa[1]), Integer.parseInt(pa[2]));
			PreNode pn = new PreNode(pa[0], affected, start, 0);
			queue.enqueue(pn);
		}

		queue.display();

		boolean failed = false;
		String finalGrid = "";

		while (!queue.queue.isEmpty()) {
			System.out.println("habd2 ml awl");
			PreNode frontPreNode = queue.dequeue();
			boolean repeated = false;
			/*
			for (int i = 0 ; i < prevNodes.size(); i++) {
				if(frontPreNode.prevNode.myLoc.x == prevNodes.get(i).myLoc.x && 
						frontPreNode.prevNode.myLoc.y == prevNodes.get(i).myLoc.y) {
					if (!(queue.queue.isEmpty())) {
					frontPreNode = queue.dequeue();
					}
				}
			}
			*/
			TreeNode frontTreeNode = update(
					frontPreNode.action + "," + frontPreNode.affectedCell.x + "," + frontPreNode.affectedCell.y,
					frontPreNode.prevNode, prevNodes);
			for (int i = 0 ; i < prevNodes.size(); i++) {
				if(frontTreeNode.myLoc.x == prevNodes.get(i).myLoc.x && 
						frontTreeNode.myLoc.y == prevNodes.get(i).myLoc.y &&
						compareGrids(frontTreeNode.grid, prevNodes.get(i).grid) == true) {
					//ignore this path
					repeated = true;
					break;
					//if (!(queue.queue.isEmpty())) {
					//frontPreNode = queue.dequeue();
					//}
				}
			}
			if (repeated == true) {
				System.out.println("msh hakml");
				continue;
			}
			System.out.println("tamam");
			prevNodes.add(frontTreeNode);
			possibleActions = getPossibleActions(frontTreeNode.myLoc, frontTreeNode.grid);
			
			for (int i = 0; i < possibleActions.size(); i++) {
				String[] pa = possibleActions.get(i).split(",");
				//System.out.println(possibleActions.get(i));
				Location affected = new Location(Integer.parseInt(pa[1]), Integer.parseInt(pa[2]));
				PreNode pn = new PreNode(pa[0], affected, frontTreeNode, 0);
				queue.enqueue(pn);
				//queue.display();
			}
			boolean goal = isItGoal(frontTreeNode);
			System.out.println(frontPreNode.action);
			queue.display();
			if (queue.queue.isEmpty()) {
				failed = true;
			}
			
			if (frontTreeNode.neoDamage >= 100) {
				return "fail";
			}
			
			finalGrid = frontTreeNode.grid;

		}
		return finalGrid;
	}
	
	//this might be tricky if we needed the damages as a difference
	public static boolean compareGrids(String grid1, String grid2) {
		boolean similar = false;
		//if same number of agents and hostages and pills then similar
		String[] splitted1 = grid1.split(";");
		String[] splitted2 = grid2.split(";");
		String[] agents1 = splitted1[4].split(",");
		String[] agents2 = splitted2[4].split(",");
		if (agents1.length == agents2.length) {
			//check pills
			String[] pills1 = splitted1[5].split(",");
			String[] pills2 = splitted2[5].split(",");
			if (pills1.length == pills2.length) {
				//check hostages
				String[] hos1;
				if (splitted1.length <= 7 ) {
					//no more hostages
					hos1 = new String[0];
				}else {
					hos1 = splitted1[7].split(",");
				}
				
				String[] hos2;
				if (splitted2.length <= 7 ) {
					//no more hostages
					hos2 = new String[0];
				}else {
					hos2 = splitted2[7].split(",");
				}
				if (hos1.length ==hos2.length) {
					similar = true;
				}else {
					similar = false;
				}
			}else {
				similar = false;
			}
		}else {
			similar = false;
		}
		return similar;
	}

	// goal test
	public static boolean isItGoal(TreeNode n) {

		boolean goal = false;
		String grid = n.grid;
		ArrayList<String> hostages = getHostages(grid);
		ArrayList<String> mutantHostages = getMutantHostages(grid);
		if (mutantHostages.size() == 0 && hostages.size() == 0) {
			goal = true;
		}
		return goal;

	}

	// method to print the content of any array
	public static void printArr(ArrayList<String> arr) {
		for (int i = 0; i < arr.size(); i++) {
			System.out.println(arr.get(i));
		}
		System.out.println(" ");
	}

	// method to fill the hostages and damage
	public static ArrayList<String> getHostages(String grid) {
		ArrayList<String> result = new ArrayList<String>();
		String[] splitted = grid.split(";");
		// System.out.println(splitted.length);
		// array that contains locations of all the hostages
		String[] hostages;
		if (splitted.length <= 7) {
			hostages = new String[0];
		}else {
			hostages = splitted[7].split(",");
		}

		for (int i = 0; i < hostages.length - 1; i += 3) {
			// store the location and damage in a string
			String temp = "";
			// check the damage to know if mutant or alive
			// if mutant then skip this iteration
			if (Integer.parseInt(hostages[i + 2]) < 100) {
				temp += hostages[i] + "," + hostages[i + 1] + "," + hostages[i + 2];
				result.add(temp);
			}

		}

		return result;
	}

	// method to fill the mutant hostages
	public static ArrayList<String> getMutantHostages(String grid) {
		ArrayList<String> result = new ArrayList<String>();

		String[] splitted = grid.split(";");
		// array that contains locations of all the hostages
		String[] hostages;
		if (splitted.length <= 7) {
			hostages = new String[0];
		}else {
			hostages = splitted[7].split(",");
		}

		for (int i = 0; i < hostages.length - 1; i += 3) {
			// store the location in a string
			String temp = "";
			// check the damage to know if mutant or alive
			// if alive then skip this iteration
			if (Integer.parseInt(hostages[i + 2]) >= 100) {
				// add only the location since we do not need the damage
				temp += hostages[i] + "," + hostages[i + 1];
				result.add(temp);
			}

		}

		return result;
	}

	// method to get the content of the given cell and useful information about
	// content of cell
	// can be used to determine the surroundings of the current cell
	public static String whatInCell(int x, int y, String grid) {
		String result = "";
		// split the grid at ; to extract different categories in the grid
		String[] splitted = grid.split(";");
		// array that consists of (x,y) of the telephone booth
		String[] telephone = splitted[3].split(",");
		// array that contains locations of all the agents
		String[] agents = splitted[4].split(",");
		// array that contains locations of all pills
		String[] pills = splitted[5].split(",");
		// array that contains locations of all the pads
		// this array is always divisible by 4 since the pad comes in pairs
		// (startx, starty, finishx, finishy)
		String[] pads = splitted[6].split(",");
		// array that contains locations of all the hostages
		String[] hostages;
		if (splitted.length <=7) {
			hostages = new String[0];
		}else {
			hostages = splitted[7].split(",");
		}

		if (x == Integer.parseInt(telephone[0]) && y == Integer.parseInt(telephone[1])) {
			result = "telephone;" + x + ";" + y;
			return result;
		}
		for (int i = 0; i < agents.length - 1; i += 2) {
			if (x == Integer.parseInt(agents[i]) && y == Integer.parseInt(agents[i + 1])) {
				result = "agent;" + x + ";" + y;
				return result;
			}
		}
		for (int i = 0; i < pills.length - 1; i += 2) {
			if (x == Integer.parseInt(pills[i]) && y == Integer.parseInt(pills[i + 1])) {
				result = "pill;" + x + ";" + y;
				return result;
			}
		}
		for (int i = 0; i < pads.length - 1; i += 2) {
			if (x == Integer.parseInt(pads[i]) && y == Integer.parseInt(pads[i + 1])) {
				result = "pad;" + x + ";" + y;
				if ((i / 2) % 2 == 0) {
					result += ";" + pads[i + 2] + ";" + pads[i + 3];
				} else {
					result += ";" + pads[i - 2] + ";" + pads[i - 1];
				}
				// return pair of pads attached together
				return result;
			}
		}
		for (int i = 0; i < hostages.length - 1; i += 3) {
			if (x == Integer.parseInt(hostages[i]) && y == Integer.parseInt(hostages[i + 1])) {
				result = "hostage;" + x + ";" + y + ";" + hostages[i + 2];
				return result;
			}
		}

		return result;
	}

	// method to detect where can I move
	public static ArrayList<String> whereCanIMove(Location current, String grid) {
		ArrayList<String> result = new ArrayList<String>();
		// check all possible directions
		String[] splitted = grid.split(";");
		String[] dimensions = splitted[0].split(",");
		int cols = Integer.parseInt(dimensions[1]);
		int rows = Integer.parseInt(dimensions[0]);
		boolean up = false;
		boolean right = false;
		boolean down = false;
		boolean left = false;
		// check if I can go left
		if (current.y > 0) {
			// check if there is an agent or a mutant agent
			String upCellComponent = whatInCell(current.x, current.y - 1, grid);
			if (!(upCellComponent.contains("agent"))) {
				// check if there is a mutant hostage
				if (upCellComponent.contains("hostage")) {
					// check the damage to know if it is mutant
					String[] hos = upCellComponent.split(";");
					if (Integer.parseInt(hos[3]) < 100) {
						left = true;
					} else {
						result.add("KillLeft");
					}
				}
				left = true;
			} else {
				result.add("KillLeft");
			}
		}
		// check if I can go down
		if (current.x < rows - 1) {
			// check if there is an agent or a mutant agent
			String rightCellComponent = whatInCell(current.x + 1, current.y, grid);
			if (!(rightCellComponent.contains("agent"))) {
				// check if there is a mutant hostage
				if (rightCellComponent.contains("hostage")) {
					// System.out.println(rightCellComponent);
					// check the damage to know if it is mutant
					String[] hos = rightCellComponent.split(";");
					if (Integer.parseInt(hos[3]) < 100) {
						down = true;
					} else {
						result.add("KillDown");
					}
				}
				down = true;
			} else {
				result.add("KillDown");
			}
		}
		// check if I can go right
		if (current.y < cols - 1) {
			// check if there is an agent or a mutant agent
			String downCellComponent = whatInCell(current.x, current.y + 1, grid);
			if (!(downCellComponent.contains("agent"))) {
				// check if there is a mutant hostage
				if (downCellComponent.contains("hostage")) {
					// check the damage to know if it is mutant
					String[] hos = downCellComponent.split(";");
					if (Integer.parseInt(hos[3]) < 100) {
						right = true;
					} else {
						result.add("KillRight");
					}
				}
				right = true;
			} else {
				result.add("KillRight");
			}
		}
		// check if I can go Up
		if (current.x > 0) {
			// check if there is an agent or a mutant agent
			String leftCellComponent = whatInCell(current.x - 1, current.y, grid);
			if (!(leftCellComponent.contains("agent"))) {
				// check if there is a mutant hostage
				if (leftCellComponent.contains("hostage")) {
					// check the damage to know if it is mutant
					String[] hos = leftCellComponent.split(";");
					if (Integer.parseInt(hos[3]) < 100) {
						up = true;
					} else {
						result.add("KillUp");
					}
				}
				up = true;
			} else {
				result.add("KillUp");
			}
		}
		if (up) {
			result.add("Up");
		}
		if (right) {
			result.add("Right");
		}
		if (down) {
			result.add("Down");
		}
		if (left) {
			result.add("Left");
		}

		return result;
	}

	// method to detect possible actions and insert in queue
	// this method returns array of strings of the following format
	// "ActionName", "affectedLocation"
	public static ArrayList<String> getPossibleActions(Location current, String grid) {
		ArrayList<String> result = new ArrayList<String>();
		// check the current cell components
		String currentCellComponent = whatInCell(current.x, current.y, grid);
		if (currentCellComponent.contains("pill")) {
			// either take it or leave it
			result.add("Pill," + current.x + "," + current.y);
		}
		if (currentCellComponent.contains("hostage")) {
			// cannot be a mutant hostage because we do not add this option to happen during
			// movement
			result.add("Carry," + current.x + "," + current.y);
		}
		if (currentCellComponent.contains("pad")) {
			// get the go-to pad from the string
			String[] pillData = currentCellComponent.split(";");
			// we know that the current cell is the first pad in the string so ignore it
			int fx = Integer.parseInt(pillData[3]);
			int fy = Integer.parseInt(pillData[4]);
			result.add("Fly," + fx + "," + fy);
		}
		if (currentCellComponent.contains("telephone")) {
			// you can either drop or leave
			// check before drop if there is a hostage to drop
			result.add("Drop," + current.x + "," + current.y);
		}

		// get the possible movements
		ArrayList<String> movements = whereCanIMove(current, grid);
		if (!(movements.isEmpty())) {
			for (int i = 0; i < movements.size(); i++) {
				if (movements.get(i) == "Up") {
					result.add("Up," + (current.x - 1) + "," + current.y);
				} else if (movements.get(i) == "Right") {
					result.add("Right," + current.x + "," + (current.y + 1));
				} else if (movements.get(i) == "Down") {
					result.add("Down," + (current.x + 1) + "," + current.y);
				} else if (movements.get(i) == "Left") {
					result.add("Left," + current.x + "," + (current.y - 1));
				} else if (movements.get(i) == "KillUp") {
					result.add("Kill," + (current.x - 1) + "," + current.y);
				} else if (movements.get(i) == "KillRight") {
					result.add("Kill," + current.x + "," + (current.y + 1));
				} else if (movements.get(i) == "KillDown") {
					result.add("Kill," + (current.x + 1) + "," + current.y);
				} else if (movements.get(i) == "KillLeft") {
					result.add("Kill," + current.x + "," + (current.y - 1));
				}

			}
		}
		return result;

	}

	// reminder: make the location of the carried hostage should be that of neo
	// reminder: adjust damage abl maymot law pill
	// reminder e3mly el ba2y
	// 5aly update ta5od el node

	// updates everything needed according to the action taken
	// I think it should return the new grid string
	public static TreeNode update(String action, TreeNode prevNode, ArrayList<TreeNode> prevNodes) {
		// we assume that Neo starts with 0 damage
		// update damage of all hostages

		// resultant grid
		String result = "";
		// split the grid at ; to extract different categories in the grid
		String[] splitted = prevNode.grid.split(";");
		// since the dimensions and neo's initial position and TB position are constant,
		// append to result
		result += splitted[0] + ";" + splitted[1] + ";" + splitted[2] + ";" + splitted[3] + ";";

		// array that contains locations of all the agents
		String[] agents = splitted[4].split(",");
		// array that contains the locations of all mutant hostages
		ArrayList<String> mutantHostages = getMutantHostages(prevNode.grid);
		// array that contains locations of all the pills
		String[] pills = splitted[5].split(",");
		// array that contains locations of all the pads
		// this array is always divisible by 4 since the pad comes in pairs
		// (startx, starty, finishx, finishy)
		String pads = splitted[6];
		// array that contains locations of all the hostages
		// get this array from the method getHostages to avoid getting mutant hostages
		// from the grid string
		ArrayList<String> hostages = getHostages(prevNode.grid);
		ArrayList<Integer> carried = prevNode.carried;
		int deaths = prevNode.deaths;

		for (int i = 0; i < hostages.size(); i++) {
			// each entry in the arraylist is a string with commas splitting the x and y and
			// damage
			String[] splittedHos = hostages.get(i).split(",");
			// the third element is the damage
			int oldDamage = Integer.parseInt(splittedHos[2]) + 2;
			if (action == "Pill") {
				oldDamage -= 2;
			}
			// set the new damage
			hostages.set(i, splittedHos[0] + "," + splittedHos[1] + "," + oldDamage);
			// check if it reached 100
			if (oldDamage >= 100) {
				// remove this hostage from the hostages array and add it to mutant
				mutantHostages.add(hostages.get(i));
				hostages.remove(i);
				// update the grid by adding the new hostage damage
				// as we do not add a different category in the grid string to represent the
				// mutant hostages
				// we rely on having the damage of 100 or greater to reflect this change
			}
		}
		for (int i = 0; i < carried.size(); i++) {
			int d = carried.get(i);
			if (action == "Pill") {
				if (d < 100) {
					if (d < 20) {
						carried.set(i, 0);
					} else {
						carried.set(i, d - 20);
					}

				}
			} else if (d < 100) {
				carried.set(i, d + 2);
				if (carried.get(i) >= 100) {
					deaths++;
				}
			}

		}
		int kills = prevNode.kills;
		int neoD = prevNode.neoDamage;
		Location newLocation = prevNode.myLoc;

		// get the affected location from action
		String[] actionDetails = action.split(",");
		Location moveTo = new Location(Integer.parseInt(actionDetails[1]), Integer.parseInt(actionDetails[2]));

		// check the action performed and accordingly update the grid or damage
		switch (actionDetails[0]) {
		case ("Kill"):
			System.out.println("hamoot" + (prevNode.myLoc.y == Integer.parseInt(agents[1])));
			// update grid by removing the killed agent or mutant hostage
			// increment Neo's damage by 20
			kills++;
			neoD += 20;
			// increment the number of killings by 1 if it is an agent
			for (int i = 0; i < agents.length - 1; i += 2) {
				if (Integer.parseInt(actionDetails[1]) == Integer.parseInt(agents[i])
						&& Integer.parseInt(actionDetails[2]) == Integer.parseInt(agents[i + 1])) {
					
					// replace the x and y with negatives so that when we combine the string again
					// we can know that this is not valid
					
					agents[i] = "-1";
					agents[i + 1] = "-1";
					break;
				}
			}
			for (int i = 0; i < mutantHostages.size() - 1; i += 2) {
				if (prevNode.myLoc.x == Integer.parseInt(mutantHostages.get(i))
						&& prevNode.myLoc.y == Integer.parseInt(mutantHostages.get(i + 1))) {
					// remove the mutant hostages from the arraylist
					mutantHostages.remove(i + 1);
					mutantHostages.remove(i);
					// also remove the hostage from the grid string
					break;
				}
			}

			break;
		case ("Pill"):
			// update grid method above
			// Decrement the damages of hostages and Neo by 20
			for (int i = 0; i < pills.length - 1; i += 2) {
				if (prevNode.myLoc.x == Integer.parseInt(pills[i])
						&& prevNode.myLoc.y == Integer.parseInt(pills[i + 1])) {
					// replace the x and y with negatives so that when we combine the string again
					// we can know that this is not valid
					pills[i] = "-1";
					pills[i + 1] = "-1";
					break;
				}
			}

			if (neoD < 20) {
				neoD = 0;
			} else {
				neoD -= 20;
			}

			for (int i = 0; i < hostages.size(); i++) {
				// each entry in the arraylist is a string with commas splitting the x and y and
				// damage
				String[] splitted2 = hostages.get(i).split(",");
				// the third element is the damage
				// decrement by 22 because we already incremented by 2 at the beginning of the
				// method
				int oldDamage2 = Integer.parseInt(splitted2[2]);
				if (oldDamage2 < 20) {
					oldDamage2 = 0;
				} else {
					oldDamage2 -= 20;
				}
				// set the new damage
				if (oldDamage2 < 0) {
					hostages.set(i, splitted2[0] + "," + splitted2[1] + "," + oldDamage2);
					// check that is cannot reach below 0
				}
			}
			// Decrement Neo damage by 20
			break;
		case ("Carry"):
			// update grid method above
			int cAllowed = Integer.parseInt(splitted[1]);
			if (carried.size() + 1 < cAllowed) {
				// increment c by 1
				for (int i = 0; i < hostages.size() - 1; i += 3) {
					if (prevNode.myLoc.x == Integer.parseInt(hostages.get(i))
							&& prevNode.myLoc.y == Integer.parseInt(hostages.get(i + 1))) {
						// replace the x and y with negatives so that when we combine the string again
						// we can know that this is not valid

						// set the location to that of neo
						hostages.remove(i + 1);
						hostages.remove(i);
						carried.add(Integer.parseInt(hostages.remove(i + 2)));
						break;
					}
				}
			}

			break;
		case ("Drop"):
			// Reset carried
			prevNode.carried = new ArrayList<Integer>();
			carried = new ArrayList<Integer>();
			break;
		case ("Down"):
			System.out.println("here2");
			// nothing changes in the grid only the overall hostage damage increases by 2
			// and this is already handled above
			newLocation = moveTo;

			break;
		case ("Up"):
			// nothing changes in the grid only the overall hostage damage increases by 2
			// and this is already handled above
			newLocation = moveTo;

			break;
		case ("Right"):
			// nothing changes in the grid only the overall hostage damage increases by 2
			// and this is already handled above
			newLocation = moveTo;

			break;
		case ("Left"):
			// nothing changes in the grid only the overall hostage damage increases by 2
			// and this is already handled above
			newLocation = moveTo;

			break;
		case ("Fly"):
			// change hostages carried location
			// nothing changes in the grid only the overall hostage damage increases by 2
			// and this is already handled above
			newLocation = moveTo;
			break;
		default:
			break;
		}

		// then we need to form the new grid

		for (int i = 0; i < agents.length - 1; i += 2) {
			if (agents[i] == "-1") {
				// killed
				continue;
			} else {
				result += agents[i] + "," + agents[i + 1];
				if (i < agents.length - 3) {
					result += ",";
				}
			}
		}
		result += ";";

		for (int i = 0; i < pills.length - 1; i += 2) {
			if (pills[i] == "-1") {
				// taken
				continue;
			} else {

				result += pills[i] + "," + pills[i + 1];
				if (i < pills.length - 3) {
					result += ",";
				}
			}
		}

		result += ";" + pads + ";";

		for (int i = 0; i < hostages.size() - 2; i += 3) {
			result += hostages.get(i) + "," + hostages.get(i + 1) + "," + hostages.get(i + 2);
			if (i < hostages.size() - 4) {
				result += ",";
			}
		}

		// add the mutant hostages to the hostages category in the grid
		for (int i = 0; i < mutantHostages.size() - 1; i += 2) {
			result += mutantHostages.get(i) + "," + mutantHostages.get(i + 1) + "," + "100";
			if (i < mutantHostages.size() - 3) {
				result += ",";
			}
		}

		TreeNode resNode = new TreeNode(prevNode, prevNodes, newLocation, neoD, result, kills, deaths, actionDetails[0],
				prevNode.depth + 1, 0, carried);
		System.out.println(result + "griiiid");
		return resNode;

	}

	// raz3yn el depth wl costs
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-11-15 23:13:15.126
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-11-15 23:13:15.126
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2021-11-15 23:13:15.149
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package code;

import java.util.ArrayList;

import code.Location;
import code.TreeNode;
import code.Queue.*;

public abstract class GeneralSearch {

	// habdyn el cost wl depth
	// check game over

	public static String generalSearch(String grid, String strategy, boolean visualize) {
		String result = "";
		//initialize everything as this is the start
		ArrayList<TreeNode> prevNodes = new ArrayList<TreeNode>();
		ArrayList<PreNode> preNodes = new ArrayList<PreNode>();
		String[] splitted = grid.split(";");
		//get Neo's starting position
		String[] preNeo = splitted[2].split(",");
		Location neo = new Location(Integer.parseInt(preNeo[0]), Integer.parseInt(preNeo[1]));
		//array to store the damages of the carried hostages
		//also used to keep track of the number of carried hostages
		ArrayList<Integer> carried = new ArrayList<Integer>();
		
		// create initial starting node
		##TO-DO
		// reminder: cost
		TreeNode start = new TreeNode(null, prevNodes, neo, 0, grid, 0, 0, "Start", 0, 0, carried);
		PreNode startPre = new PreNode("Start", neo, start, 0);

		prevNodes.add(start);

		// create the queue for search
		Queue queue;
		switch (strategy) {
		case ("DF"):
			queue = new DFQueue();
			break;
		default:
			//temporary
			queue = new DFQueue();
			break;
		}

		// get the possible actions for the starting node
		ArrayList<String> possibleActions = getPossibleActions(neo, grid);
		printArr(possibleActions);
		for (int i = 0; i < possibleActions.size(); i++) {
			String[] pa = possibleActions.get(i).split(",");
			Location affected = new Location(Integer.parseInt(pa[1]), Integer.parseInt(pa[2]));
			PreNode pn = new PreNode(pa[0], affected, start, 0);
			queue.enqueue(pn);
		}

		queue.display();

		boolean failed = false;
		String finalGrid = "";

		while (!queue.queue.isEmpty()) {
			System.out.println("habd2 ml awl");
			PreNode frontPreNode = queue.dequeue();
			boolean repeated = false;
			/*
			for (int i = 0 ; i < prevNodes.size(); i++) {
				if(frontPreNode.prevNode.myLoc.x == prevNodes.get(i).myLoc.x && 
						frontPreNode.prevNode.myLoc.y == prevNodes.get(i).myLoc.y) {
					if (!(queue.queue.isEmpty())) {
					frontPreNode = queue.dequeue();
					}
				}
			}
			*/
			TreeNode frontTreeNode = update(
					frontPreNode.action + "," + frontPreNode.affectedCell.x + "," + frontPreNode.affectedCell.y,
					frontPreNode.prevNode, prevNodes);
			for (int i = 0 ; i < prevNodes.size(); i++) {
				if(frontTreeNode.myLoc.x == prevNodes.get(i).myLoc.x && 
						frontTreeNode.myLoc.y == prevNodes.get(i).myLoc.y &&
						compareGrids(frontTreeNode.grid, prevNodes.get(i).grid) == true) {
					//ignore this path
					repeated = true;
					break;
					//if (!(queue.queue.isEmpty())) {
					//frontPreNode = queue.dequeue();
					//}
				}
			}
			if (repeated == true) {
				System.out.println("msh hakml");
				continue;
			}
			System.out.println("tamam");
			prevNodes.add(frontTreeNode);
			possibleActions = getPossibleActions(frontTreeNode.myLoc, frontTreeNode.grid);
			
			for (int i = 0; i < possibleActions.size(); i++) {
				String[] pa = possibleActions.get(i).split(",");
				//System.out.println(possibleActions.get(i));
				Location affected = new Location(Integer.parseInt(pa[1]), Integer.parseInt(pa[2]));
				PreNode pn = new PreNode(pa[0], affected, frontTreeNode, 0);
				queue.enqueue(pn);
				//queue.display();
			}
			boolean goal = isItGoal(frontTreeNode);
			System.out.println(frontPreNode.action);
			queue.display();
			if (queue.queue.isEmpty()) {
				failed = true;
			}
			
			if (frontTreeNode.neoDamage >= 100) {
				return "fail";
			}
			
			finalGrid = frontTreeNode.grid;

		}
		return finalGrid;
	}
	
	//this might be tricky if we needed the damages as a difference
	public static boolean compareGrids(String grid1, String grid2) {
		boolean similar = false;
		//if same number of agents and hostages and pills then similar
		String[] splitted1 = grid1.split(";");
		String[] splitted2 = grid2.split(";");
		String[] agents1 = splitted1[4].split(",");
		String[] agents2 = splitted2[4].split(",");
		if (agents1.length == agents2.length) {
			//check pills
			String[] pills1 = splitted1[5].split(",");
			String[] pills2 = splitted2[5].split(",");
			if (pills1.length == pills2.length) {
				//check hostages
				String[] hos1;
				if (splitted1.length <= 7 ) {
					//no more hostages
					hos1 = new String[0];
				}else {
					hos1 = splitted1[7].split(",");
				}
				
				String[] hos2;
				if (splitted2.length <= 7 ) {
					//no more hostages
					hos2 = new String[0];
				}else {
					hos2 = splitted2[7].split(",");
				}
				if (hos1.length ==hos2.length) {
					similar = true;
				}else {
					similar = false;
				}
			}else {
				similar = false;
			}
		}else {
			similar = false;
		}
		return similar;
	}

	// goal test
	public static boolean isItGoal(TreeNode n) {

		boolean goal = false;
		String grid = n.grid;
		ArrayList<String> hostages = getHostages(grid);
		ArrayList<String> mutantHostages = getMutantHostages(grid);
		if (mutantHostages.size() == 0 && hostages.size() == 0) {
			goal = true;
		}
		return goal;

	}

	// method to print the content of any array
	public static void printArr(ArrayList<String> arr) {
		for (int i = 0; i < arr.size(); i++) {
			System.out.println(arr.get(i));
		}
		System.out.println(" ");
	}

	// method to fill the hostages and damage
	public static ArrayList<String> getHostages(String grid) {
		ArrayList<String> result = new ArrayList<String>();
		String[] splitted = grid.split(";");
		// System.out.println(splitted.length);
		// array that contains locations of all the hostages
		String[] hostages;
		if (splitted.length <= 7) {
			hostages = new String[0];
		}else {
			hostages = splitted[7].split(",");
		}

		for (int i = 0; i < hostages.length - 1; i += 3) {
			// store the location and damage in a string
			String temp = "";
			// check the damage to know if mutant or alive
			// if mutant then skip this iteration
			if (Integer.parseInt(hostages[i + 2]) < 100) {
				temp += hostages[i] + "," + hostages[i + 1] + "," + hostages[i + 2];
				result.add(temp);
			}

		}

		return result;
	}

	// method to fill the mutant hostages
	public static ArrayList<String> getMutantHostages(String grid) {
		ArrayList<String> result = new ArrayList<String>();

		String[] splitted = grid.split(";");
		// array that contains locations of all the hostages
		String[] hostages;
		if (splitted.length <= 7) {
			hostages = new String[0];
		}else {
			hostages = splitted[7].split(",");
		}

		for (int i = 0; i < hostages.length - 1; i += 3) {
			// store the location in a string
			String temp = "";
			// check the damage to know if mutant or alive
			// if alive then skip this iteration
			if (Integer.parseInt(hostages[i + 2]) >= 100) {
				// add only the location since we do not need the damage
				temp += hostages[i] + "," + hostages[i + 1];
				result.add(temp);
			}

		}

		return result;
	}

	// method to get the content of the given cell and useful information about
	// content of cell
	// can be used to determine the surroundings of the current cell
	public static String whatInCell(int x, int y, String grid) {
		String result = "";
		// split the grid at ; to extract different categories in the grid
		String[] splitted = grid.split(";");
		// array that consists of (x,y) of the telephone booth
		String[] telephone = splitted[3].split(",");
		// array that contains locations of all the agents
		String[] agents = splitted[4].split(",");
		// array that contains locations of all pills
		String[] pills = splitted[5].split(",");
		// array that contains locations of all the pads
		// this array is always divisible by 4 since the pad comes in pairs
		// (startx, starty, finishx, finishy)
		String[] pads = splitted[6].split(",");
		// array that contains locations of all the hostages
		String[] hostages;
		if (splitted.length <=7) {
			hostages = new String[0];
		}else {
			hostages = splitted[7].split(",");
		}

		if (x == Integer.parseInt(telephone[0]) && y == Integer.parseInt(telephone[1])) {
			result = "telephone;" + x + ";" + y;
			return result;
		}
		for (int i = 0; i < agents.length - 1; i += 2) {
			if (x == Integer.parseInt(agents[i]) && y == Integer.parseInt(agents[i + 1])) {
				result = "agent;" + x + ";" + y;
				return result;
			}
		}
		for (int i = 0; i < pills.length - 1; i += 2) {
			if (x == Integer.parseInt(pills[i]) && y == Integer.parseInt(pills[i + 1])) {
				result = "pill;" + x + ";" + y;
				return result;
			}
		}
		for (int i = 0; i < pads.length - 1; i += 2) {
			if (x == Integer.parseInt(pads[i]) && y == Integer.parseInt(pads[i + 1])) {
				result = "pad;" + x + ";" + y;
				if ((i / 2) % 2 == 0) {
					result += ";" + pads[i + 2] + ";" + pads[i + 3];
				} else {
					result += ";" + pads[i - 2] + ";" + pads[i - 1];
				}
				// return pair of pads attached together
				return result;
			}
		}
		for (int i = 0; i < hostages.length - 1; i += 3) {
			if (x == Integer.parseInt(hostages[i]) && y == Integer.parseInt(hostages[i + 1])) {
				result = "hostage;" + x + ";" + y + ";" + hostages[i + 2];
				return result;
			}
		}

		return result;
	}

	// method to detect where can I move
	public static ArrayList<String> whereCanIMove(Location current, String grid) {
		ArrayList<String> result = new ArrayList<String>();
		// check all possible directions
		String[] splitted = grid.split(";");
		String[] dimensions = splitted[0].split(",");
		int cols = Integer.parseInt(dimensions[1]);
		int rows = Integer.parseInt(dimensions[0]);
		boolean up = false;
		boolean right = false;
		boolean down = false;
		boolean left = false;
		// check if I can go left
		if (current.y > 0) {
			// check if there is an agent or a mutant agent
			String upCellComponent = whatInCell(current.x, current.y - 1, grid);
			if (!(upCellComponent.contains("agent"))) {
				// check if there is a mutant hostage
				if (upCellComponent.contains("hostage")) {
					// check the damage to know if it is mutant
					String[] hos = upCellComponent.split(";");
					if (Integer.parseInt(hos[3]) < 100) {
						left = true;
					} else {
						result.add("KillLeft");
					}
				}
				left = true;
			} else {
				result.add("KillLeft");
			}
		}
		// check if I can go down
		if (current.x < rows - 1) {
			// check if there is an agent or a mutant agent
			String rightCellComponent = whatInCell(current.x + 1, current.y, grid);
			if (!(rightCellComponent.contains("agent"))) {
				// check if there is a mutant hostage
				if (rightCellComponent.contains("hostage")) {
					// System.out.println(rightCellComponent);
					// check the damage to know if it is mutant
					String[] hos = rightCellComponent.split(";");
					if (Integer.parseInt(hos[3]) < 100) {
						down = true;
					} else {
						result.add("KillDown");
					}
				}
				down = true;
			} else {
				result.add("KillDown");
			}
		}
		// check if I can go right
		if (current.y < cols - 1) {
			// check if there is an agent or a mutant agent
			String downCellComponent = whatInCell(current.x, current.y + 1, grid);
			if (!(downCellComponent.contains("agent"))) {
				// check if there is a mutant hostage
				if (downCellComponent.contains("hostage")) {
					// check the damage to know if it is mutant
					String[] hos = downCellComponent.split(";");
					if (Integer.parseInt(hos[3]) < 100) {
						right = true;
					} else {
						result.add("KillRight");
					}
				}
				right = true;
			} else {
				result.add("KillRight");
			}
		}
		// check if I can go Up
		if (current.x > 0) {
			// check if there is an agent or a mutant agent
			String leftCellComponent = whatInCell(current.x - 1, current.y, grid);
			if (!(leftCellComponent.contains("agent"))) {
				// check if there is a mutant hostage
				if (leftCellComponent.contains("hostage")) {
					// check the damage to know if it is mutant
					String[] hos = leftCellComponent.split(";");
					if (Integer.parseInt(hos[3]) < 100) {
						up = true;
					} else {
						result.add("KillUp");
					}
				}
				up = true;
			} else {
				result.add("KillUp");
			}
		}
		if (up) {
			result.add("Up");
		}
		if (right) {
			result.add("Right");
		}
		if (down) {
			result.add("Down");
		}
		if (left) {
			result.add("Left");
		}

		return result;
	}

	// method to detect possible actions and insert in queue
	// this method returns array of strings of the following format
	// "ActionName", "affectedLocation"
	public static ArrayList<String> getPossibleActions(Location current, String grid) {
		ArrayList<String> result = new ArrayList<String>();
		// check the current cell components
		String currentCellComponent = whatInCell(current.x, current.y, grid);
		if (currentCellComponent.contains("pill")) {
			// either take it or leave it
			result.add("Pill," + current.x + "," + current.y);
		}
		if (currentCellComponent.contains("hostage")) {
			// cannot be a mutant hostage because we do not add this option to happen during
			// movement
			result.add("Carry," + current.x + "," + current.y);
		}
		if (currentCellComponent.contains("pad")) {
			// get the go-to pad from the string
			String[] pillData = currentCellComponent.split(";");
			// we know that the current cell is the first pad in the string so ignore it
			int fx = Integer.parseInt(pillData[3]);
			int fy = Integer.parseInt(pillData[4]);
			result.add("Fly," + fx + "," + fy);
		}
		if (currentCellComponent.contains("telephone")) {
			// you can either drop or leave
			// check before drop if there is a hostage to drop
			result.add("Drop," + current.x + "," + current.y);
		}

		// get the possible movements
		ArrayList<String> movements = whereCanIMove(current, grid);
		if (!(movements.isEmpty())) {
			for (int i = 0; i < movements.size(); i++) {
				if (movements.get(i) == "Up") {
					result.add("Up," + (current.x - 1) + "," + current.y);
				} else if (movements.get(i) == "Right") {
					result.add("Right," + current.x + "," + (current.y + 1));
				} else if (movements.get(i) == "Down") {
					result.add("Down," + (current.x + 1) + "," + current.y);
				} else if (movements.get(i) == "Left") {
					result.add("Left," + current.x + "," + (current.y - 1));
				} else if (movements.get(i) == "KillUp") {
					result.add("Kill," + (current.x - 1) + "," + current.y);
				} else if (movements.get(i) == "KillRight") {
					result.add("Kill," + current.x + "," + (current.y + 1));
				} else if (movements.get(i) == "KillDown") {
					result.add("Kill," + (current.x + 1) + "," + current.y);
				} else if (movements.get(i) == "KillLeft") {
					result.add("Kill," + current.x + "," + (current.y - 1));
				}

			}
		}
		return result;

	}

	// reminder: make the location of the carried hostage should be that of neo
	// reminder: adjust damage abl maymot law pill
	// reminder e3mly el ba2y
	// 5aly update ta5od el node

	// updates everything needed according to the action taken
	// I think it should return the new grid string
	public static TreeNode update(String action, TreeNode prevNode, ArrayList<TreeNode> prevNodes) {
		// we assume that Neo starts with 0 damage
		// update damage of all hostages

		// resultant grid
		String result = "";
		// split the grid at ; to extract different categories in the grid
		String[] splitted = prevNode.grid.split(";");
		// since the dimensions and neo's initial position and TB position are constant,
		// append to result
		result += splitted[0] + ";" + splitted[1] + ";" + splitted[2] + ";" + splitted[3] + ";";

		// array that contains locations of all the agents
		String[] agents = splitted[4].split(",");
		// array that contains the locations of all mutant hostages
		ArrayList<String> mutantHostages = getMutantHostages(prevNode.grid);
		// array that contains locations of all the pills
		String[] pills = splitted[5].split(",");
		// array that contains locations of all the pads
		// this array is always divisible by 4 since the pad comes in pairs
		// (startx, starty, finishx, finishy)
		String pads = splitted[6];
		// array that contains locations of all the hostages
		// get this array from the method getHostages to avoid getting mutant hostages
		// from the grid string
		ArrayList<String> hostages = getHostages(prevNode.grid);
		ArrayList<Integer> carried = prevNode.carried;
		int deaths = prevNode.deaths;

		for (int i = 0; i < hostages.size(); i++) {
			// each entry in the arraylist is a string with commas splitting the x and y and
			// damage
			String[] splittedHos = hostages.get(i).split(",");
			// the third element is the damage
			int oldDamage = Integer.parseInt(splittedHos[2]) + 2;
			if (action == "Pill") {
				oldDamage -= 2;
			}
			// set the new damage
			hostages.set(i, splittedHos[0] + "," + splittedHos[1] + "," + oldDamage);
			// check if it reached 100
			if (oldDamage >= 100) {
				// remove this hostage from the hostages array and add it to mutant
				mutantHostages.add(hostages.get(i));
				hostages.remove(i);
				// update the grid by adding the new hostage damage
				// as we do not add a different category in the grid string to represent the
				// mutant hostages
				// we rely on having the damage of 100 or greater to reflect this change
			}
		}
		for (int i = 0; i < carried.size(); i++) {
			int d = carried.get(i);
			if (action == "Pill") {
				if (d < 100) {
					if (d < 20) {
						carried.set(i, 0);
					} else {
						carried.set(i, d - 20);
					}

				}
			} else if (d < 100) {
				carried.set(i, d + 2);
				if (carried.get(i) >= 100) {
					deaths++;
				}
			}

		}
		int kills = prevNode.kills;
		int neoD = prevNode.neoDamage;
		Location newLocation = prevNode.myLoc;

		// get the affected location from action
		String[] actionDetails = action.split(",");
		Location moveTo = new Location(Integer.parseInt(actionDetails[1]), Integer.parseInt(actionDetails[2]));

		// check the action performed and accordingly update the grid or damage
		switch (actionDetails[0]) {
		case ("Kill"):
			System.out.println("hamoot" + (prevNode.myLoc.y == Integer.parseInt(agents[1])));
			// update grid by removing the killed agent or mutant hostage
			// increment Neo's damage by 20
			kills++;
			neoD += 20;
			// increment the number of killings by 1 if it is an agent
			for (int i = 0; i < agents.length - 1; i += 2) {
				if (Integer.parseInt(actionDetails[1]) == Integer.parseInt(agents[i])
						&& Integer.parseInt(actionDetails[2]) == Integer.parseInt(agents[i + 1])) {
					
					// replace the x and y with negatives so that when we combine the string again
					// we can know that this is not valid
					
					agents[i] = "-1";
					agents[i + 1] = "-1";
					break;
				}
			}
			for (int i = 0; i < mutantHostages.size() - 1; i += 2) {
				if (prevNode.myLoc.x == Integer.parseInt(mutantHostages.get(i))
						&& prevNode.myLoc.y == Integer.parseInt(mutantHostages.get(i + 1))) {
					// remove the mutant hostages from the arraylist
					mutantHostages.remove(i + 1);
					mutantHostages.remove(i);
					// also remove the hostage from the grid string
					break;
				}
			}

			break;
		case ("Pill"):
			// update grid method above
			// Decrement the damages of hostages and Neo by 20
			for (int i = 0; i < pills.length - 1; i += 2) {
				if (prevNode.myLoc.x == Integer.parseInt(pills[i])
						&& prevNode.myLoc.y == Integer.parseInt(pills[i + 1])) {
					// replace the x and y with negatives so that when we combine the string again
					// we can know that this is not valid
					pills[i] = "-1";
					pills[i + 1] = "-1";
					break;
				}
			}

			if (neoD < 20) {
				neoD = 0;
			} else {
				neoD -= 20;
			}

			for (int i = 0; i < hostages.size(); i++) {
				// each entry in the arraylist is a string with commas splitting the x and y and
				// damage
				String[] splitted2 = hostages.get(i).split(",");
				// the third element is the damage
				// decrement by 22 because we already incremented by 2 at the beginning of the
				// method
				int oldDamage2 = Integer.parseInt(splitted2[2]);
				if (oldDamage2 < 20) {
					oldDamage2 = 0;
				} else {
					oldDamage2 -= 20;
				}
				// set the new damage
				if (oldDamage2 < 0) {
					hostages.set(i, splitted2[0] + "," + splitted2[1] + "," + oldDamage2);
					// check that is cannot reach below 0
				}
			}
			// Decrement Neo damage by 20
			break;
		case ("Carry"):
			// update grid method above
			int cAllowed = Integer.parseInt(splitted[1]);
			if (carried.size() + 1 < cAllowed) {
				// increment c by 1
				for (int i = 0; i < hostages.size() - 1; i += 3) {
					if (prevNode.myLoc.x == Integer.parseInt(hostages.get(i))
							&& prevNode.myLoc.y == Integer.parseInt(hostages.get(i + 1))) {
						// replace the x and y with negatives so that when we combine the string again
						// we can know that this is not valid

						// set the location to that of neo
						hostages.remove(i + 1);
						hostages.remove(i);
						carried.add(Integer.parseInt(hostages.remove(i + 2)));
						break;
					}
				}
			}

			break;
		case ("Drop"):
			// Reset carried
			prevNode.carried = new ArrayList<Integer>();
			carried = new ArrayList<Integer>();
			break;
		case ("Down"):
			System.out.println("here2");
			// nothing changes in the grid only the overall hostage damage increases by 2
			// and this is already handled above
			newLocation = moveTo;

			break;
		case ("Up"):
			// nothing changes in the grid only the overall hostage damage increases by 2
			// and this is already handled above
			newLocation = moveTo;

			break;
		case ("Right"):
			// nothing changes in the grid only the overall hostage damage increases by 2
			// and this is already handled above
			newLocation = moveTo;

			break;
		case ("Left"):
			// nothing changes in the grid only the overall hostage damage increases by 2
			// and this is already handled above
			newLocation = moveTo;

			break;
		case ("Fly"):
			// change hostages carried location
			// nothing changes in the grid only the overall hostage damage increases by 2
			// and this is already handled above
			newLocation = moveTo;
			break;
		default:
			break;
		}

		// then we need to form the new grid

		for (int i = 0; i < agents.length - 1; i += 2) {
			if (agents[i] == "-1") {
				// killed
				continue;
			} else {
				result += agents[i] + "," + agents[i + 1];
				if (i < agents.length - 3) {
					result += ",";
				}
			}
		}
		result += ";";

		for (int i = 0; i < pills.length - 1; i += 2) {
			if (pills[i] == "-1") {
				// taken
				continue;
			} else {

				result += pills[i] + "," + pills[i + 1];
				if (i < pills.length - 3) {
					result += ",";
				}
			}
		}

		result += ";" + pads + ";";

		for (int i = 0; i < hostages.size() - 2; i += 3) {
			result += hostages.get(i) + "," + hostages.get(i + 1) + "," + hostages.get(i + 2);
			if (i < hostages.size() - 4) {
				result += ",";
			}
		}

		// add the mutant hostages to the hostages category in the grid
		for (int i = 0; i < mutantHostages.size() - 1; i += 2) {
			result += mutantHostages.get(i) + "," + mutantHostages.get(i + 1) + "," + "100";
			if (i < mutantHostages.size() - 3) {
				result += ",";
			}
		}

		TreeNode resNode = new TreeNode(prevNode, prevNodes, newLocation, neoD, result, kills, deaths, actionDetails[0],
				prevNode.depth + 1, 0, carried);
		System.out.println(result + "griiiid");
		return resNode;

	}

	// raz3yn el depth wl costs
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-11-15 23:13:15.150
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-11-15 23:13:15.150
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2021-11-15 23:13:15.994
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package code;

import java.util.ArrayList;

import code.Location;
import code.TreeNode;
import code.Queue.*;

public abstract class GeneralSearch {

	// habdyn el cost wl depth
	// check game over

	public static String generalSearch(String grid, String strategy, boolean visualize) {
		String result = "";
		//initialize everything as this is the start
		ArrayList<TreeNode> prevNodes = new ArrayList<TreeNode>();
		ArrayList<PreNode> preNodes = new ArrayList<PreNode>();
		String[] splitted = grid.split(";");
		//get Neo's starting position
		String[] preNeo = splitted[2].split(",");
		Location neo = new Location(Integer.parseInt(preNeo[0]), Integer.parseInt(preNeo[1]));
		//array to store the damages of the carried hostages
		//also used to keep track of the number of carried hostages
		ArrayList<Integer> carried = new ArrayList<Integer>();
		
		// create initial starting node
		##TO-DO
		// reminder: cost
		TreeNode start = new TreeNode(null, prevNodes, neo, 0, grid, 0, 0, "Start", 0, 0, carried);
		PreNode startPre = new PreNode("Start", neo, start, 0);

		prevNodes.add(start);

		// create the queue for search
		Queue queue;
		switch (strategy) {
		case ("DF"):
			queue = new DFQueue();
			break;
		default:
			//temporary
			queue = new DFQueue();
			break;
		}

		// get the possible actions for the starting node
		ArrayList<String> possibleActions = getPossibleActions(neo, grid);
		printArr(possibleActions);
		for (int i = 0; i < possibleActions.size(); i++) {
			String[] pa = possibleActions.get(i).split(",");
			Location affected = new Location(Integer.parseInt(pa[1]), Integer.parseInt(pa[2]));
			PreNode pn = new PreNode(pa[0], affected, start, 0);
			queue.enqueue(pn);
		}

		queue.display();

		boolean failed = false;
		String finalGrid = "";

		while (!queue.queue.isEmpty()) {
			System.out.println("habd2 ml awl");
			PreNode frontPreNode = queue.dequeue();
			boolean repeated = false;
			/*
			for (int i = 0 ; i < prevNodes.size(); i++) {
				if(frontPreNode.prevNode.myLoc.x == prevNodes.get(i).myLoc.x && 
						frontPreNode.prevNode.myLoc.y == prevNodes.get(i).myLoc.y) {
					if (!(queue.queue.isEmpty())) {
					frontPreNode = queue.dequeue();
					}
				}
			}
			*/
			TreeNode frontTreeNode = update(
					frontPreNode.action + "," + frontPreNode.affectedCell.x + "," + frontPreNode.affectedCell.y,
					frontPreNode.prevNode, prevNodes);
			for (int i = 0 ; i < prevNodes.size(); i++) {
				if(frontTreeNode.myLoc.x == prevNodes.get(i).myLoc.x && 
						frontTreeNode.myLoc.y == prevNodes.get(i).myLoc.y &&
						compareGrids(frontTreeNode.grid, prevNodes.get(i).grid) == true) {
					//ignore this path
					repeated = true;
					break;
					//if (!(queue.queue.isEmpty())) {
					//frontPreNode = queue.dequeue();
					//}
				}
			}
			if (repeated == true) {
				System.out.println("msh hakml");
				continue;
			}
			System.out.println("tamam");
			prevNodes.add(frontTreeNode);
			possibleActions = getPossibleActions(frontTreeNode.myLoc, frontTreeNode.grid);
			
			for (int i = 0; i < possibleActions.size(); i++) {
				String[] pa = possibleActions.get(i).split(",");
				//System.out.println(possibleActions.get(i));
				Location affected = new Location(Integer.parseInt(pa[1]), Integer.parseInt(pa[2]));
				PreNode pn = new PreNode(pa[0], affected, frontTreeNode, 0);
				queue.enqueue(pn);
				//queue.display();
			}
			boolean goal = isItGoal(frontTreeNode);
			System.out.println(frontPreNode.action);
			queue.display();
			if (queue.queue.isEmpty()) {
				failed = true;
			}
			
			if (frontTreeNode.neoDamage >= 100) {
				return "fail";
			}
			
			finalGrid = frontTreeNode.grid;

		}
		return finalGrid;
	}
	
	//this might be tricky if we needed the damages as a difference
	public static boolean compareGrids(String grid1, String grid2) {
		boolean similar = false;
		//if same number of agents and hostages and pills then similar
		String[] splitted1 = grid1.split(";");
		String[] splitted2 = grid2.split(";");
		String[] agents1 = splitted1[4].split(",");
		String[] agents2 = splitted2[4].split(",");
		if (agents1.length == agents2.length) {
			//check pills
			String[] pills1 = splitted1[5].split(",");
			String[] pills2 = splitted2[5].split(",");
			if (pills1.length == pills2.length) {
				//check hostages
				String[] hos1;
				if (splitted1.length <= 7 ) {
					//no more hostages
					hos1 = new String[0];
				}else {
					hos1 = splitted1[7].split(",");
				}
				
				String[] hos2;
				if (splitted2.length <= 7 ) {
					//no more hostages
					hos2 = new String[0];
				}else {
					hos2 = splitted2[7].split(",");
				}
				if (hos1.length ==hos2.length) {
					similar = true;
				}else {
					similar = false;
				}
			}else {
				similar = false;
			}
		}else {
			similar = false;
		}
		return similar;
	}

	// goal test
	public static boolean isItGoal(TreeNode n) {

		boolean goal = false;
		String grid = n.grid;
		ArrayList<String> hostages = getHostages(grid);
		ArrayList<String> mutantHostages = getMutantHostages(grid);
		if (mutantHostages.size() == 0 && hostages.size() == 0) {
			goal = true;
		}
		return goal;

	}

	// method to print the content of any array
	public static void printArr(ArrayList<String> arr) {
		for (int i = 0; i < arr.size(); i++) {
			System.out.println(arr.get(i));
		}
		System.out.println(" ");
	}

	// method to fill the hostages and damage
	public static ArrayList<String> getHostages(String grid) {
		ArrayList<String> result = new ArrayList<String>();
		String[] splitted = grid.split(";");
		// System.out.println(splitted.length);
		// array that contains locations of all the hostages
		String[] hostages;
		if (splitted.length <= 7) {
			hostages = new String[0];
		}else {
			hostages = splitted[7].split(",");
		}

		for (int i = 0; i < hostages.length - 1; i += 3) {
			// store the location and damage in a string
			String temp = "";
			// check the damage to know if mutant or alive
			// if mutant then skip this iteration
			if (Integer.parseInt(hostages[i + 2]) < 100) {
				temp += hostages[i] + "," + hostages[i + 1] + "," + hostages[i + 2];
				result.add(temp);
			}

		}

		return result;
	}

	// method to fill the mutant hostages
	public static ArrayList<String> getMutantHostages(String grid) {
		ArrayList<String> result = new ArrayList<String>();

		String[] splitted = grid.split(";");
		// array that contains locations of all the hostages
		String[] hostages;
		if (splitted.length <= 7) {
			hostages = new String[0];
		}else {
			hostages = splitted[7].split(",");
		}

		for (int i = 0; i < hostages.length - 1; i += 3) {
			// store the location in a string
			String temp = "";
			// check the damage to know if mutant or alive
			// if alive then skip this iteration
			if (Integer.parseInt(hostages[i + 2]) >= 100) {
				// add only the location since we do not need the damage
				temp += hostages[i] + "," + hostages[i + 1];
				result.add(temp);
			}

		}

		return result;
	}

	// method to get the content of the given cell and useful information about
	// content of cell
	// can be used to determine the surroundings of the current cell
	public static String whatInCell(int x, int y, String grid) {
		String result = "";
		// split the grid at ; to extract different categories in the grid
		String[] splitted = grid.split(";");
		// array that consists of (x,y) of the telephone booth
		String[] telephone = splitted[3].split(",");
		// array that contains locations of all the agents
		String[] agents = splitted[4].split(",");
		// array that contains locations of all pills
		String[] pills = splitted[5].split(",");
		// array that contains locations of all the pads
		// this array is always divisible by 4 since the pad comes in pairs
		// (startx, starty, finishx, finishy)
		String[] pads = splitted[6].split(",");
		// array that contains locations of all the hostages
		String[] hostages;
		if (splitted.length <=7) {
			hostages = new String[0];
		}else {
			hostages = splitted[7].split(",");
		}

		if (x == Integer.parseInt(telephone[0]) && y == Integer.parseInt(telephone[1])) {
			result = "telephone;" + x + ";" + y;
			return result;
		}
		for (int i = 0; i < agents.length - 1; i += 2) {
			if (x == Integer.parseInt(agents[i]) && y == Integer.parseInt(agents[i + 1])) {
				result = "agent;" + x + ";" + y;
				return result;
			}
		}
		for (int i = 0; i < pills.length - 1; i += 2) {
			if (x == Integer.parseInt(pills[i]) && y == Integer.parseInt(pills[i + 1])) {
				result = "pill;" + x + ";" + y;
				return result;
			}
		}
		for (int i = 0; i < pads.length - 1; i += 2) {
			if (x == Integer.parseInt(pads[i]) && y == Integer.parseInt(pads[i + 1])) {
				result = "pad;" + x + ";" + y;
				if ((i / 2) % 2 == 0) {
					result += ";" + pads[i + 2] + ";" + pads[i + 3];
				} else {
					result += ";" + pads[i - 2] + ";" + pads[i - 1];
				}
				// return pair of pads attached together
				return result;
			}
		}
		for (int i = 0; i < hostages.length - 1; i += 3) {
			if (x == Integer.parseInt(hostages[i]) && y == Integer.parseInt(hostages[i + 1])) {
				result = "hostage;" + x + ";" + y + ";" + hostages[i + 2];
				return result;
			}
		}

		return result;
	}

	// method to detect where can I move
	public static ArrayList<String> whereCanIMove(Location current, String grid) {
		ArrayList<String> result = new ArrayList<String>();
		// check all possible directions
		String[] splitted = grid.split(";");
		String[] dimensions = splitted[0].split(",");
		int cols = Integer.parseInt(dimensions[1]);
		int rows = Integer.parseInt(dimensions[0]);
		boolean up = false;
		boolean right = false;
		boolean down = false;
		boolean left = false;
		// check if I can go left
		if (current.y > 0) {
			// check if there is an agent or a mutant agent
			String upCellComponent = whatInCell(current.x, current.y - 1, grid);
			if (!(upCellComponent.contains("agent"))) {
				// check if there is a mutant hostage
				if (upCellComponent.contains("hostage")) {
					// check the damage to know if it is mutant
					String[] hos = upCellComponent.split(";");
					if (Integer.parseInt(hos[3]) < 100) {
						left = true;
					} else {
						result.add("KillLeft");
					}
				}
				left = true;
			} else {
				result.add("KillLeft");
			}
		}
		// check if I can go down
		if (current.x < rows - 1) {
			// check if there is an agent or a mutant agent
			String rightCellComponent = whatInCell(current.x + 1, current.y, grid);
			if (!(rightCellComponent.contains("agent"))) {
				// check if there is a mutant hostage
				if (rightCellComponent.contains("hostage")) {
					// System.out.println(rightCellComponent);
					// check the damage to know if it is mutant
					String[] hos = rightCellComponent.split(";");
					if (Integer.parseInt(hos[3]) < 100) {
						down = true;
					} else {
						result.add("KillDown");
					}
				}
				down = true;
			} else {
				result.add("KillDown");
			}
		}
		// check if I can go right
		if (current.y < cols - 1) {
			// check if there is an agent or a mutant agent
			String downCellComponent = whatInCell(current.x, current.y + 1, grid);
			if (!(downCellComponent.contains("agent"))) {
				// check if there is a mutant hostage
				if (downCellComponent.contains("hostage")) {
					// check the damage to know if it is mutant
					String[] hos = downCellComponent.split(";");
					if (Integer.parseInt(hos[3]) < 100) {
						right = true;
					} else {
						result.add("KillRight");
					}
				}
				right = true;
			} else {
				result.add("KillRight");
			}
		}
		// check if I can go Up
		if (current.x > 0) {
			// check if there is an agent or a mutant agent
			String leftCellComponent = whatInCell(current.x - 1, current.y, grid);
			if (!(leftCellComponent.contains("agent"))) {
				// check if there is a mutant hostage
				if (leftCellComponent.contains("hostage")) {
					// check the damage to know if it is mutant
					String[] hos = leftCellComponent.split(";");
					if (Integer.parseInt(hos[3]) < 100) {
						up = true;
					} else {
						result.add("KillUp");
					}
				}
				up = true;
			} else {
				result.add("KillUp");
			}
		}
		if (up) {
			result.add("Up");
		}
		if (right) {
			result.add("Right");
		}
		if (down) {
			result.add("Down");
		}
		if (left) {
			result.add("Left");
		}

		return result;
	}

	// method to detect possible actions and insert in queue
	// this method returns array of strings of the following format
	// "ActionName", "affectedLocation"
	public static ArrayList<String> getPossibleActions(Location current, String grid) {
		ArrayList<String> result = new ArrayList<String>();
		// check the current cell components
		String currentCellComponent = whatInCell(current.x, current.y, grid);
		if (currentCellComponent.contains("pill")) {
			// either take it or leave it
			result.add("Pill," + current.x + "," + current.y);
		}
		if (currentCellComponent.contains("hostage")) {
			// cannot be a mutant hostage because we do not add this option to happen during
			// movement
			result.add("Carry," + current.x + "," + current.y);
		}
		if (currentCellComponent.contains("pad")) {
			// get the go-to pad from the string
			String[] pillData = currentCellComponent.split(";");
			// we know that the current cell is the first pad in the string so ignore it
			int fx = Integer.parseInt(pillData[3]);
			int fy = Integer.parseInt(pillData[4]);
			result.add("Fly," + fx + "," + fy);
		}
		if (currentCellComponent.contains("telephone")) {
			// you can either drop or leave
			// check before drop if there is a hostage to drop
			result.add("Drop," + current.x + "," + current.y);
		}

		// get the possible movements
		ArrayList<String> movements = whereCanIMove(current, grid);
		if (!(movements.isEmpty())) {
			for (int i = 0; i < movements.size(); i++) {
				if (movements.get(i) == "Up") {
					result.add("Up," + (current.x - 1) + "," + current.y);
				} else if (movements.get(i) == "Right") {
					result.add("Right," + current.x + "," + (current.y + 1));
				} else if (movements.get(i) == "Down") {
					result.add("Down," + (current.x + 1) + "," + current.y);
				} else if (movements.get(i) == "Left") {
					result.add("Left," + current.x + "," + (current.y - 1));
				} else if (movements.get(i) == "KillUp") {
					result.add("Kill," + (current.x - 1) + "," + current.y);
				} else if (movements.get(i) == "KillRight") {
					result.add("Kill," + current.x + "," + (current.y + 1));
				} else if (movements.get(i) == "KillDown") {
					result.add("Kill," + (current.x + 1) + "," + current.y);
				} else if (movements.get(i) == "KillLeft") {
					result.add("Kill," + current.x + "," + (current.y - 1));
				}

			}
		}
		return result;

	}

	// reminder: make the location of the carried hostage should be that of neo
	// reminder: adjust damage abl maymot law pill
	// reminder e3mly el ba2y
	// 5aly update ta5od el node

	// updates everything needed according to the action taken
	// I think it should return the new grid string
	public static TreeNode update(String action, TreeNode prevNode, ArrayList<TreeNode> prevNodes) {
		// we assume that Neo starts with 0 damage
		// update damage of all hostages

		// resultant grid
		String result = "";
		// split the grid at ; to extract different categories in the grid
		String[] splitted = prevNode.grid.split(";");
		// since the dimensions and neo's initial position and TB position are constant,
		// append to result
		result += splitted[0] + ";" + splitted[1] + ";" + splitted[2] + ";" + splitted[3] + ";";

		// array that contains locations of all the agents
		String[] agents = splitted[4].split(",");
		// array that contains the locations of all mutant hostages
		ArrayList<String> mutantHostages = getMutantHostages(prevNode.grid);
		// array that contains locations of all the pills
		String[] pills = splitted[5].split(",");
		// array that contains locations of all the pads
		// this array is always divisible by 4 since the pad comes in pairs
		// (startx, starty, finishx, finishy)
		String pads = splitted[6];
		// array that contains locations of all the hostages
		// get this array from the method getHostages to avoid getting mutant hostages
		// from the grid string
		ArrayList<String> hostages = getHostages(prevNode.grid);
		ArrayList<Integer> carried = prevNode.carried;
		int deaths = prevNode.deaths;

		for (int i = 0; i < hostages.size(); i++) {
			// each entry in the arraylist is a string with commas splitting the x and y and
			// damage
			String[] splittedHos = hostages.get(i).split(",");
			// the third element is the damage
			int oldDamage = Integer.parseInt(splittedHos[2]) + 2;
			if (action == "Pill") {
				oldDamage -= 2;
			}
			// set the new damage
			hostages.set(i, splittedHos[0] + "," + splittedHos[1] + "," + oldDamage);
			// check if it reached 100
			if (oldDamage >= 100) {
				// remove this hostage from the hostages array and add it to mutant
				mutantHostages.add(hostages.get(i));
				hostages.remove(i);
				// update the grid by adding the new hostage damage
				// as we do not add a different category in the grid string to represent the
				// mutant hostages
				// we rely on having the damage of 100 or greater to reflect this change
			}
		}
		for (int i = 0; i < carried.size(); i++) {
			int d = carried.get(i);
			if (action == "Pill") {
				if (d < 100) {
					if (d < 20) {
						carried.set(i, 0);
					} else {
						carried.set(i, d - 20);
					}

				}
			} else if (d < 100) {
				carried.set(i, d + 2);
				if (carried.get(i) >= 100) {
					deaths++;
				}
			}

		}
		int kills = prevNode.kills;
		int neoD = prevNode.neoDamage;
		Location newLocation = prevNode.myLoc;

		// get the affected location from action
		String[] actionDetails = action.split(",");
		Location moveTo = new Location(Integer.parseInt(actionDetails[1]), Integer.parseInt(actionDetails[2]));

		// check the action performed and accordingly update the grid or damage
		switch (actionDetails[0]) {
		case ("Kill"):
			System.out.println("hamoot" + (prevNode.myLoc.y == Integer.parseInt(agents[1])));
			// update grid by removing the killed agent or mutant hostage
			// increment Neo's damage by 20
			kills++;
			neoD += 20;
			// increment the number of killings by 1 if it is an agent
			for (int i = 0; i < agents.length - 1; i += 2) {
				if (Integer.parseInt(actionDetails[1]) == Integer.parseInt(agents[i])
						&& Integer.parseInt(actionDetails[2]) == Integer.parseInt(agents[i + 1])) {
					
					// replace the x and y with negatives so that when we combine the string again
					// we can know that this is not valid
					
					agents[i] = "-1";
					agents[i + 1] = "-1";
					break;
				}
			}
			for (int i = 0; i < mutantHostages.size() - 1; i += 2) {
				if (prevNode.myLoc.x == Integer.parseInt(mutantHostages.get(i))
						&& prevNode.myLoc.y == Integer.parseInt(mutantHostages.get(i + 1))) {
					// remove the mutant hostages from the arraylist
					mutantHostages.remove(i + 1);
					mutantHostages.remove(i);
					// also remove the hostage from the grid string
					break;
				}
			}

			break;
		case ("Pill"):
			// update grid method above
			// Decrement the damages of hostages and Neo by 20
			for (int i = 0; i < pills.length - 1; i += 2) {
				if (prevNode.myLoc.x == Integer.parseInt(pills[i])
						&& prevNode.myLoc.y == Integer.parseInt(pills[i + 1])) {
					// replace the x and y with negatives so that when we combine the string again
					// we can know that this is not valid
					pills[i] = "-1";
					pills[i + 1] = "-1";
					break;
				}
			}

			if (neoD < 20) {
				neoD = 0;
			} else {
				neoD -= 20;
			}

			for (int i = 0; i < hostages.size(); i++) {
				// each entry in the arraylist is a string with commas splitting the x and y and
				// damage
				String[] splitted2 = hostages.get(i).split(",");
				// the third element is the damage
				// decrement by 22 because we already incremented by 2 at the beginning of the
				// method
				int oldDamage2 = Integer.parseInt(splitted2[2]);
				if (oldDamage2 < 20) {
					oldDamage2 = 0;
				} else {
					oldDamage2 -= 20;
				}
				// set the new damage
				if (oldDamage2 < 0) {
					hostages.set(i, splitted2[0] + "," + splitted2[1] + "," + oldDamage2);
					// check that is cannot reach below 0
				}
			}
			// Decrement Neo damage by 20
			break;
		case ("Carry"):
			// update grid method above
			int cAllowed = Integer.parseInt(splitted[1]);
			if (carried.size() + 1 < cAllowed) {
				// increment c by 1
				for (int i = 0; i < hostages.size() - 1; i += 3) {
					if (prevNode.myLoc.x == Integer.parseInt(hostages.get(i))
							&& prevNode.myLoc.y == Integer.parseInt(hostages.get(i + 1))) {
						// replace the x and y with negatives so that when we combine the string again
						// we can know that this is not valid

						// set the location to that of neo
						hostages.remove(i + 1);
						hostages.remove(i);
						carried.add(Integer.parseInt(hostages.remove(i + 2)));
						break;
					}
				}
			}

			break;
		case ("Drop"):
			// Reset carried
			prevNode.carried = new ArrayList<Integer>();
			carried = new ArrayList<Integer>();
			break;
		case ("Down"):
			System.out.println("here2");
			// nothing changes in the grid only the overall hostage damage increases by 2
			// and this is already handled above
			newLocation = moveTo;

			break;
		case ("Up"):
			// nothing changes in the grid only the overall hostage damage increases by 2
			// and this is already handled above
			newLocation = moveTo;

			break;
		case ("Right"):
			// nothing changes in the grid only the overall hostage damage increases by 2
			// and this is already handled above
			newLocation = moveTo;

			break;
		case ("Left"):
			// nothing changes in the grid only the overall hostage damage increases by 2
			// and this is already handled above
			newLocation = moveTo;

			break;
		case ("Fly"):
			// change hostages carried location
			// nothing changes in the grid only the overall hostage damage increases by 2
			// and this is already handled above
			newLocation = moveTo;
			break;
		default:
			break;
		}

		// then we need to form the new grid

		for (int i = 0; i < agents.length - 1; i += 2) {
			if (agents[i] == "-1") {
				// killed
				continue;
			} else {
				result += agents[i] + "," + agents[i + 1];
				if (i < agents.length - 3) {
					result += ",";
				}
			}
		}
		result += ";";

		for (int i = 0; i < pills.length - 1; i += 2) {
			if (pills[i] == "-1") {
				// taken
				continue;
			} else {

				result += pills[i] + "," + pills[i + 1];
				if (i < pills.length - 3) {
					result += ",";
				}
			}
		}

		result += ";" + pads + ";";

		for (int i = 0; i < hostages.size() - 2; i += 3) {
			result += hostages.get(i) + "," + hostages.get(i + 1) + "," + hostages.get(i + 2);
			if (i < hostages.size() - 4) {
				result += ",";
			}
		}

		// add the mutant hostages to the hostages category in the grid
		for (int i = 0; i < mutantHostages.size() - 1; i += 2) {
			result += mutantHostages.get(i) + "," + mutantHostages.get(i + 1) + "," + "100";
			if (i < mutantHostages.size() - 3) {
				result += ",";
			}
		}

		TreeNode resNode = new TreeNode(prevNode, prevNodes, newLocation, neoD, result, kills, deaths, actionDetails[0],
				prevNode.depth + 1, 0, carried);
		System.out.println(result + "griiiid");
		return resNode;

	}

	// raz3yn el depth wl costs
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-11-15 23:13:15.994
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-11-15 23:13:15.994
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2031)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3795)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1943)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1974)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3052)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2021-11-16 19:50:17.842 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=16.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-16 19:50:29.549
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-16 19:50:29.549
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@32caae19,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@60e67c06,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-16 19:50:32.933
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\safam'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-11-17 23:04:15.075 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=16.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-17 23:04:28.860
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-17 23:04:28.860
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2bc59ab7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@410f53b2,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-17 23:04:31.896
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\safam'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-11-18 21:55:44.783 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=16.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-18 21:55:55.115
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-18 21:55:55.115
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7507d96c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7210f559,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-18 21:55:58.233
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\safam'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-11-18 23:36:59.622 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=16.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-18 23:37:10.109
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-18 23:37:10.109
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@49b9ba6a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7be62956,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-18 23:37:12.502
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\safam'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-11-23 17:29:39.241 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=16.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-23 17:29:52.539
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-23 17:29:52.539
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@32caae19,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@60e67c06,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-23 17:29:56.389
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\safam'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.junit 4 0 2021-11-23 19:48:35.502
!MESSAGE No tests found with test runner 'JUnit 5'.

!ENTRY org.eclipse.jdt.junit 4 0 2021-11-23 19:51:34.769
!MESSAGE No tests found with test runner 'JUnit 5'.

!ENTRY org.eclipse.ui.ide 4 4 2021-11-23 19:58:37.044
!MESSAGE Not properly disposed SWT resource
!STACK 0
java.lang.Error: SWT Resource was not properly disposed
	at org.eclipse.swt.graphics.Resource.initNonDisposeTracking(Resource.java:172)
	at org.eclipse.swt.graphics.Resource.<init>(Resource.java:120)
	at org.eclipse.swt.graphics.Image.<init>(Image.java:728)
	at org.eclipse.swt.dnd.TreeDragSourceEffect.getDragSourceImage(TreeDragSourceEffect.java:149)
	at org.eclipse.swt.dnd.TreeDragSourceEffect.dragStart(TreeDragSourceEffect.java:81)
	at org.eclipse.swt.dnd.DNDListener.handleEvent(DNDListener.java:36)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1043)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1067)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1052)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:766)
	at org.eclipse.swt.dnd.DragSource.drag(DragSource.java:475)
	at org.eclipse.swt.dnd.DragSource.lambda$0(DragSource.java:380)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1043)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4026)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3626)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:823)
	at org.eclipse.jface.window.Window.open(Window.java:799)
	at org.eclipse.jdt.internal.ui.wizards.buildpaths.newsourcepage.ConfigureBuildPathAction.run(ConfigureBuildPathAction.java:88)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:580)
	at org.eclipse.jface.action.ActionContributionItem.lambda$4(ActionContributionItem.java:414)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1043)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4026)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3626)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:78)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:654)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1462)
!SESSION 2021-11-24 00:14:32.630 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=16.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-24 00:14:48.498
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-24 00:14:48.498
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@30e143ff,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@452ec287,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-24 00:14:51.809
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\safam'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-11-24 13:16:38.717 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=16.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-24 13:16:49.764
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-24 13:16:49.764
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@452ec287,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@41404aa2,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-24 13:16:52.984
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\safam'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2021-11-24 19:10:51.655
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package tests;
import static org.junit.Assert.*;

import java.util.ArrayList;
import java.util.HashMap;

import org.junit.FixMethodOrder;
import org.junit.Test;
import org.junit.runners.MethodSorters;

import code.Matrix;

@FixMethodOrder(MethodSorters.NAME_ASCENDING)

public class TestMatrixPublic {
	
	String grid0 = "5,5;2;3,4;1,2;0,3,1,4;2,3;4,4,0,2,0,2,4,4;2,2,91,2,4,62";
	String grid1 = "5,5;1;1,4;1,0;0,4;0,0,2,2;3,4,4,2,4,2,3,4;0,2,32,0,1,38";
	String grid2 = "5,5;2;3,2;0,1;4,1;0,3;1,2,4,2,4,2,1,2,0,4,3,0,3,0,0,4;1,1,77,3,4,34";
	String grid3 = "5,5;1;0,4;4,4;0,3,1,4,2,1,3,0,4,1;4,0;2,4,3,4,3,4,2,4;0,2,98,1,2,98,2,2,98,3,2,98,4,2,98,2,0,1";
	String grid4 = "5,5;1;0,4;4,4;0,3,1,4,2,1,3,0,4,1;4,0;2,4,3,4,3,4,2,4;0,2,98,1,2,98,2,2,98,3,2,98,4,2,98,2,0,98,1,0,98";
	String grid5 = "5,5;2;0,4;3,4;3,1,1,1;2,3;3,0,0,1,0,1,3,0;4,2,54,4,0,85,1,0,43";
	String grid6 = "5,5;2;3,0;4,3;2,1,2,2,3,1,0,0,1,1,4,2,3,3,1,3,0,1;2,4,3,2,3,4,0,4;4,4,4,0,4,0,4,4;1,4,57,2,0,46";
	String grid7 = "5,5;3;1,3;4,0;0,1,3,2,4,3,2,4,0,4;3,4,3,0,4,2;1,4,1,2,1,2,1,4,0,3,1,0,1,0,0,3;4,4,45,3,3,12,0,2,88";
	String grid8 = "5,5;2;4,3;2,1;2,0,0,4,0,3,0,1;3,1,3,2;4,4,3,3,3,3,4,4;4,0,17,1,2,54,0,0,46,4,1,22";
	String grid9 = "5,5;2;0,4;1,4;0,1,1,1,2,1,3,1,3,3,3,4;1,0,2,4;0,3,4,3,4,3,0,3;0,0,30,3,0,80,4,4,80";
	String grid10 = "5,5;4;1,1;4,1;2,4,0,4,3,2,3,0,4,2,0,1,1,3,2,1;4,0,4,4,1,0;2,0,0,2,0,2,2,0,2;0,0,62,4,3,45,3,3,39,2,3,40";
	
	/*
	@Test(timeout = 10000)
	public void testa0() throws Exception {
		String solution = Matrix.solve(grid0, "BF", false);
		solution = solution.replace(" ", "");
		System.out.println(solution);
		assertTrue("The output actions do not lead to a goal state.", applyPlan(grid0, solution));
		//passed
	}
	*/
	/*
	@Test(timeout = 10000)
	public void testa1() throws Exception {
		String solution = Matrix.solve(grid1, "BF", false);
		solution = solution.replace(" ", "");
		System.out.println(solution);
		assertTrue("The output actions do not lead to a goal state.", applyPlan(grid1, solution));
		//one extra death because of error in calculating the damage of the carried
	}
	*/
	
	@Test(timeout = 10000)
	public void testa2() throws Exception {
		String solution = Matrix.solve(grid2, "BF", false);
		solution = solution.replace(" ", "");
		assertTrue("The output actions do not lead to a goal state.", applyPlan(grid2, solution));
	}
	
	@T
	est(timeout = 10000)
	public void testa3() throws Exception {
		String solution = Matrix.solve(grid3, "BF", false);
		solution = solution.replace(" ", "");
		assertTrue("The output actions do not lead to a goal state.", applyPlan(grid3, solution));
	}
	
	@Test(timeout = 10000)
	public void testa4() throws Exception {
		String solution = Matrix.solve(grid4, "BF", false);
		assertTrue("The output actions do not lead to a goal state.", solution.equals("No Solution"));
	}
	
	@Test(timeout = 10000)
	public void testa5() throws Exception {
		String solution = Matrix.solve(grid5, "BF", false);
		solution = solution.replace(" ", "");
		assertTrue("The output actions do not lead to a goal state.", applyPlan(grid5, solution));
	}
	
	@Test(timeout = 10000)
	public void testa6() throws Exception {
		String solution = Matrix.solve(grid6, "BF", false);
		solution = solution.replace(" ", "");
		assertTrue("The output actions do not lead to a goal state.", applyPlan(grid6, solution));
	}
	
	@Test(timeout = 30000)
	public void testa7() throws Exception {
		String solution = Matrix.solve(grid7, "BF", false);
		solution = solution.replace(" ", "");
		assertTrue("The output actions do not lead to a goal state.", applyPlan(grid7, solution));
	}
	
	@Test(timeout = 30000)
	public void testa8() throws Exception {
		String solution = Matrix.solve(grid8, "BF", false);
		solution = solution.replace(" ", "");
		assertTrue("The output actions do not lead to a goal state.", applyPlan(grid8, solution));
	}
	
	@Test(timeout = 30000)
	public void testa9() throws Exception {
		String solution = Matrix.solve(grid9, "BF", false);
		solution = solution.replace(" ", "");
		assertTrue("The output actions do not lead to a goal state.", applyPlan(grid9, solution));
	}
	
	@Test(timeout = 60000)
	public void testaz10() throws Exception {
		String solution = Matrix.solve(grid10, "BF", false);
		solution = solution.replace(" ", "");
		assertTrue("The output actions do not lead to a goal state.", applyPlan(grid10, solution));
	}

	@Test(timeout = 10000)
	public void testb0() throws Exception {
		String solution = Matrix.solve(grid0, "DF", false);
		solution = solution.replace(" ", "");
		assertTrue("The output actions do not lead to a goal state.", applyPlan(grid0, solution));
	}
	
	@Test(timeout = 10000)
	public void testb1() throws Exception {
		String solution = Matrix.solve(grid1, "DF", false);
		solution = solution.replace(" ", "");
		assertTrue("The output actions do not lead to a goal state.", applyPlan(grid1, solution));
	}
	
	@Test(timeout = 10000)
	public void testb2() throws Exception {
		String solution = Matrix.solve(grid2, "DF", false);
		solution = solution.replace(" ", "");
		assertTrue("The output actions do not lead to a goal state.", applyPlan(grid2, solution));
	}
	
	@Test(timeout = 10000)
	public void testb3() throws Exception {
		String solution = Matrix.solve(grid3, "DF", false);
		solution = solution.replace(" ", "");
		assertTrue("The output actions do not lead to a goal state.", applyPlan(grid3, solution));
	}
	
	@Test(timeout = 10000)
	public void testb4() throws Exception {
		String solution = Matrix.solve(grid4, "DF", false);
		assertTrue("The output actions do not lead to a goal state.", solution.equals("No Solution"));
	}
	
	@Test(timeout = 10000)
	public void testb5() throws Exception {
		String solution = Matrix.solve(grid5, "DF", false);
		solution = solution.replace(" ", "");
		assertTrue("The output actions do not lead to a goal state.", applyPlan(grid5, solution));
	}
	
	@Test(timeout = 10000)
	public void testb6() throws Exception {
		String solution = Matrix.solve(grid6, "DF", false);
		solution = solution.replace(" ", "");
		assertTrue("The output actions do not lead to a goal state.", applyPlan(grid6, solution));
	}
	
	@Test(timeout = 30000)
	public void testb7() throws Exception {
		String solution = Matrix.solve(grid7, "DF", false);
		solution = solution.replace(" ", "");
		assertTrue("The output actions do not lead to a goal state.",applyPlan(grid7, solution) );
	}
	
	@Test(timeout = 30000)
	public void testb8() throws Exception {
		String solution = Matrix.solve(grid8, "DF", false);
		solution = solution.replace(" ", "");
		assertTrue("The output actions do not lead to a goal state.",applyPlan(grid8, solution));
	}
	
	@Test(timeout = 30000)
	public void testb9() throws Exception {
		String solution = Matrix.solve(grid9, "DF", false);
		solution = solution.replace(" ", "");
		assertTrue("The output actions do not lead to a goal state.", applyPlan(grid9, solution));
	}
	
	@Test(timeout = 60000)
	public void testbz10() throws Exception {
		String solution = Matrix.solve(grid10, "DF", false);
		solution = solution.replace(" ", "");
		assertTrue("The output actions do not lead to a goal state.", applyPlan(grid10, solution));
	}
	
	@Test(timeout = 10000)
	public void testc0() throws Exception {
		String solution = Matrix.solve(grid0, "UC", false);
		solution = solution.replace(" ", "");
		assertTrue("The output actions do not lead to a goal state.", applyPlan(grid0, solution));
	}
	
	@Test(timeout = 10000)
	public void testc1() throws Exception {
		String solution = Matrix.solve(grid1, "UC", false);
		solution = solution.replace(" ", "");
		assertTrue("The output actions do not lead to a goal state.", applyPlan(grid1, solution));
	}
	
	@Test(timeout = 10000)
	public void testc2() throws Exception {
		String solution = Matrix.solve(grid2, "UC", false);
		solution = solution.replace(" ", "");
		assertTrue("The output actions do not lead to a goal state.", applyPlan(grid2, solution));
	}
	
	@Test(timeout = 10000)
	public void testc3() throws Exception {
		String solution = Matrix.solve(grid3, "UC", false);
		solution = solution.replace(" ", "");
		assertTrue("The output actions do not lead to a goal state.", applyPlan(grid3, solution));
	}
	
	
	@Test(timeout = 10000)
	public void testc4() throws Exception {
		String solution = Matrix.solve(grid4, "UC", false);
		assertTrue("The output actions do not lead to a goal state.", solution.equals("No Solution"));
	}
	
	@Test(timeout = 10000)
	public void testc5() throws Exception {
		String solution = Matrix.solve(grid5, "UC", false);
		solution = solution.replace(" ", "");
		assertTrue("The output actions do not lead to a goal state.", applyPlan(grid5, solution));
	}
	
	@Test(timeout = 30000)
	public void testc6() throws Exception {
		String solution = Matrix.solve(grid6, "UC", false);
		solution = solution.replace(" ", "");
		assertTrue("The output actions do not lead to a goal state.", applyPlan(grid6, solution));
	}
	
	@Test(timeout = 400000)
	public void testc7() throws Exception {
		String solution = Matrix.solve(grid7, "UC", false);
		solution = solution.replace(" ", "");
		assertTrue("The output actions do not lead to a goal state.",  applyPlan(grid7, solution));
	}
	
	@Test(timeout = 400000)
	public void testc8() throws Exception {
		String solution = Matrix.solve(grid8, "UC", false);
		solution = solution.replace(" ", "");
		assertTrue("The output actions do not lead to a goal state.", applyPlan(grid8, solution));
	}
	
	@Test(timeout = 400000)
	public void testc9() throws Exception {
		String solution = Matrix.solve(grid9, "UC", false);
		solution = solution.replace(" ", "");
		assertTrue("The output actions do not lead to a goal state.", applyPlan(grid9, solution));
	}
	
	
	@Test(timeout = 10000)
	public void testd0() throws Exception {
		String solution = Matrix.solve(grid0, "ID", false);
		solution = solution.replace(" ", "");
		assertTrue("The output actions do not lead to a goal state.", applyPlan(grid0, solution));
	}
	
	@Test(timeout = 10000)
	public void testd1() throws Exception {
		String solution = Matrix.solve(grid1, "ID", false);
		solution = solution.replace(" ", "");
		assertTrue("The output actions do not lead to a goal state.", applyPlan(grid1, solution));
	}
	
	@Test(timeout = 10000)
	public void testd2() throws Exception {
		String solution = Matrix.solve(grid2, "ID", false);
		solution = solution.replace(" ", "");
		assertTrue("The output actions do not lead to a goal state.", applyPlan(grid2, solution));
	}
	
	@Test(timeout = 10000)
	public void testd3() throws Exception {
		String solution = Matrix.solve(grid3, "ID", false);
		solution = solution.replace(" ", "");
		assertTrue("The output actions do not lead to a goal state.", applyPlan(grid3, solution));
	}
	
	@Test(timeout = 10000)
	public void testd5() throws Exception {
		String solution = Matrix.solve(grid5, "ID", false);
		solution = solution.replace(" ", "");
		assertTrue("The output actions do not lead to a goal state.", applyPlan(grid5, solution));
	}
	
	@Test(timeout = 10000)
	public void testd6() throws Exception {
		String solution = Matrix.solve(grid6, "ID", false);
		solution = solution.replace(" ", "");
		assertTrue("The output actions do not lead to a goal state.", applyPlan(grid6, solution));
	}
	

	@Test(timeout = 10000)
	public void teste0() throws Exception {
		String solution = Matrix.solve(grid0, "GR1", false);
		solution = solution.replace(" ", "");
		assertTrue("The output actions do not lead to a goal state.", applyPlan(grid0, solution));
	}
	
	@Test(timeout = 10000)
	public void teste1() throws Exception {
		String solution = Matrix.solve(grid1, "GR1", false);
		solution = solution.replace(" ", "");
		assertTrue("The output actions do not lead to a goal state.", applyPlan(grid1, solution));
	}
	
	@Test(timeout = 10000)
	public void teste2() throws Exception {
		String solution = Matrix.solve(grid2, "GR1", false);
		solution = solution.replace(" ", "");
		assertTrue("The output actions do not lead to a goal state.", applyPlan(grid2, solution));
	}
	
	@Test(timeout = 10000)
	public void teste3() throws Exception {
		String solution = Matrix.solve(grid3, "GR1", false);
		solution = solution.replace(" ", "");
		assertTrue("The output actions do not lead to a goal state.", applyPlan(grid3, solution));
	}
	
	@Test(timeout = 10000)
	public void teste4() throws Exception {
		String solution = Matrix.solve(grid4, "GR1", false);
		assertTrue("The output actions do not lead to a goal state.", solution.equals("No Solution"));
	}
	
	@Test(timeout = 10000)
	public void teste5() throws Exception {
		String solution = Matrix.solve(grid5, "GR1", false);
		solution = solution.replace(" ", "");
		assertTrue("The output actions do not lead to a goal state.", applyPlan(grid5, solution));
	}
	
	@Test(timeout = 30000)
	public void teste6() throws Exception {
		String solution = Matrix.solve(grid6, "GR1", false);
		solution = solution.replace(" ", "");
		assertTrue("The output actions do not lead to a goal state.", applyPlan(grid6, solution));
	}
	
	@Test(timeout = 400000)
	public void teste7() throws Exception {
		String solution = Matrix.solve(grid7, "GR1", false);
		solution = solution.replace(" ", "");
		assertTrue("The output actions do not lead to a goal state.", applyPlan(grid7, solution));
	}
	
	@Test(timeout = 400000)
	public void teste8() throws Exception {
		String solution = Matrix.solve(grid8, "GR1", false);
		solution = solution.replace(" ", "");
		assertTrue("The output actions do not lead to a goal state.", applyPlan(grid8, solution));
	}
	
	@Test(timeout = 400000)
	public void teste9() throws Exception {
		String solution = Matrix.solve(grid9, "GR1", false);
		solution = solution.replace(" ", "");
		assertTrue("The output actions do not lead to a goal state.", applyPlan(grid9, solution));
	}
	
	@Test(timeout = 10000)
	public void testf0() throws Exception {
		String solution = Matrix.solve(grid0, "GR2", false);
		solution = solution.replace(" ", "");
		assertTrue("The output actions do not lead to a goal state.", applyPlan(grid0, solution));
	}
	
	@Test(timeout = 10000)
	public void testf1() throws Exception {
		String solution = Matrix.solve(grid1, "GR2", false);
		solution = solution.replace(" ", "");
		assertTrue("The output actions do not lead to a goal state.", applyPlan(grid1, solution));
	}
	
	@Test(timeout = 10000)
	public void testf2() throws Exception {
		String solution = Matrix.solve(grid2, "GR2", false);
		solution = solution.replace(" ", "");
		assertTrue("The output actions do not lead to a goal state.", applyPlan(grid2, solution));
	}
	
	@Test(timeout = 10000)
	public void testf3() throws Exception {
		String solution = Matrix.solve(grid3, "GR2", false);
		solution = solution.replace(" ", "");
		assertTrue("The output actions do not lead to a goal state.", applyPlan(grid3, solution));
	}
	
	@Test(timeout = 10000)
	public void testf4() throws Exception {
		String solution = Matrix.solve(grid4, "GR2", false);
		assertTrue("The output actions do not lead to a goal state.", solution.equals("No Solution"));
	}
	
	@Test(timeout = 10000)
	public void testf5() throws Exception {
		String solution = Matrix.solve(grid5, "GR2", false);
		solution = solution.replace(" ", "");
		assertTrue("The output actions do not lead to a goal state.", applyPlan(grid5, solution));
	}
	
	@Test(timeout = 30000)
	public void testf6() throws Exception {
		String solution = Matrix.solve(grid6, "GR2", false);
		solution = solution.replace(" ", "");
		assertTrue("The output actions do not lead to a goal state.", applyPlan(grid6, solution));
	}
	
	@Test(timeout = 400000)
	public void testf7() throws Exception {
		String solution = Matrix.solve(grid7, "GR2", false);
		solution = solution.replace(" ", "");
		assertTrue("The output actions do not lead to a goal state.", applyPlan(grid7, solution));
	}
	
	@Test(timeout = 400000)
	public void testf8() throws Exception {
		String solution = Matrix.solve(grid8, "GR2", false);
		solution = solution.replace(" ", "");
		assertTrue("The output actions do not lead to a goal state.", applyPlan(grid8, solution));
	}
	
	@Test(timeout = 400000)
	public void testf9() throws Exception {
		String solution = Matrix.solve(grid9, "GR2", false);
		solution = solution.replace(" ", "");
		assertTrue("The output actions do not lead to a goal state.", applyPlan(grid9, solution));
	}
	
	@Test(timeout = 10000)
	public void testg0() throws Exception {
		String solution = Matrix.solve(grid0, "AS1", false);
		solution = solution.replace(" ", "");
		assertTrue("The output actions do not lead to a goal state.", applyPlan(grid0, solution));
	}
	
	@Test(timeout = 10000)
	public void testg1() throws Exception {
		String solution = Matrix.solve(grid1, "AS1", false);
		solution = solution.replace(" ", "");
		assertTrue("The output actions do not lead to a goal state.", applyPlan(grid1, solution));
	}
	
	@Test(timeout = 10000)
	public void testg2() throws Exception {
		String solution = Matrix.solve(grid2, "AS1", false);
		solution = solution.replace(" ", "");
		assertTrue("The output actions do not lead to a goal state.", applyPlan(grid2, solution));
	}
	
	@Test(timeout = 10000)
	public void testg3() throws Exception {
		String solution = Matrix.solve(grid3, "AS1", false);
		solution = solution.replace(" ", "");
		assertTrue("The output actions do not lead to a goal state.", applyPlan(grid3, solution));
	}
	
	@Test(timeout = 10000)
	public void testg4() throws Exception {
		String solution = Matrix.solve(grid4, "AS1", false);
		assertTrue("The output actions do not lead to a goal state.", solution.equals("No Solution"));
	}
	
	@Test(timeout = 10000)
	public void testg5() throws Exception {
		String solution = Matrix.solve(grid5, "AS1", false);
		solution = solution.replace(" ", "");
		assertTrue("The output actions do not lead to a goal state.", applyPlan(grid5, solution));
	}
	
	@Test(timeout = 30000)
	public void testg6() throws Exception {
		String solution = Matrix.solve(grid6, "AS1", false);
		solution = solution.replace(" ", "");
		assertTrue("The output actions do not lead to a goal state.", applyPlan(grid6, solution));
	}

	@Test(timeout = 400000)
	public void testg7() throws Exception {
		String solution = Matrix.solve(grid7, "AS1", false);
		solution = solution.replace(" ", "");
		assertTrue("The output actions do not lead to a goal state.", applyPlan(grid7, solution));
	}
	
	@Test(timeout = 400000)
	public void testg8() throws Exception {
		String solution = Matrix.solve(grid8, "AS1", false);
		solution = solution.replace(" ", "");
		assertTrue("The output actions do not lead to a goal state.", applyPlan(grid8, solution));
	}
	
	@Test(timeout = 400000)
	public void testg9() throws Exception {
		String solution = Matrix.solve(grid9, "AS1", false);
		solution = solution.replace(" ", "");
		assertTrue("The output actions do not lead to a goal state.", applyPlan(grid9, solution));
	}
	
	@Test(timeout = 400000)
	public void testgz10() throws Exception {
		String solution = Matrix.solve(grid10, "AS1", false);
		solution = solution.replace(" ", "");
		assertTrue("The output actions do not lead to a goal state.", applyPlan(grid10, solution));
	}

	
	@Test(timeout = 10000)
	public void testh0() throws Exception {
		String solution = Matrix.solve(grid0, "AS2", false);
		solution = solution.replace(" ", "");
		assertTrue("The output actions do not lead to a goal state.", applyPlan(grid0, solution));
	}
	
	@Test(timeout = 10000)
	public void testh1() throws Exception {
		String solution = Matrix.solve(grid1, "AS2", false);
		solution = solution.replace(" ", "");
		assertTrue("The output actions do not lead to a goal state.", applyPlan(grid1, solution));
	}
	
	@Test(timeout = 10000)
	public void testh2() throws Exception {
		String solution = Matrix.solve(grid2, "AS2", false);
		solution = solution.replace(" ", "");
		assertTrue("The output actions do not lead to a goal state.", applyPlan(grid2, solution));
	}
	
	@Test(timeout = 10000)
	public void testh3() throws Exception {
		String solution = Matrix.solve(grid3, "AS2", false);
		solution = solution.replace(" ", "");
		assertTrue("The output actions do not lead to a goal state.", applyPlan(grid3, solution));
	}
	
	@Test(timeout = 10000)
	public void testh4() throws Exception {
		String solution = Matrix.solve(grid4, "AS2", false);
		assertTrue("The output actions do not lead to a goal state.", solution.equals("No Solution"));
	}
	
	@Test(timeout = 10000)
	public void testh5() throws Exception {
		String solution = Matrix.solve(grid5, "AS2", false);
		solution = solution.replace(" ", "");
		assertTrue("The output actions do not lead to a goal state.", applyPlan(grid5, solution));
	}
	
	@Test(timeout = 30000)
	public void testh6() throws Exception {
		String solution = Matrix.solve(grid6, "AS2", false);
		solution = solution.replace(" ", "");
		assertTrue("The output actions do not lead to a goal state.", applyPlan(grid6, solution));
	}

	@Test(timeout = 400000)
	public void testh7() throws Exception {
		String solution = Matrix.solve(grid7, "AS2", false);
		solution = solution.replace(" ", "");
		assertTrue("The output actions do not lead to a goal state.", applyPlan(grid7, solution));
	}
	
	@Test(timeout = 400000)
	public void testh8() throws Exception {
		String solution = Matrix.solve(grid8, "AS2", false);
		solution = solution.replace(" ", "");
		assertTrue("The output actions do not lead to a goal state.", applyPlan(grid8, solution));
	}
	
	@Test(timeout = 400000)
	public void testh9() throws Exception {
		String solution = Matrix.solve(grid9, "AS2", false);
		solution = solution.replace(" ", "");
		assertTrue("The output actions do not lead to a goal state.", applyPlan(grid9, solution));
	}
	
	@Test(timeout = 400000)
	public void testhz10() throws Exception {
		String solution = Matrix.solve(grid10, "AS2", false);
		solution = solution.replace(" ", "");
		assertTrue("The output actions do not lead to a goal state.", applyPlan(grid10, solution));
	}
	*/
	
	 static class TH {
			int m;
			int n;
			int x10;
			int x11;
			int x00;
			int x01;
			int m1;
			int m2;
			int m3;
			ArrayList<String> xyz;
			ArrayList<String> xyzw;
			ArrayList<String> m4;
			HashMap<String,String> m5;
			HashMap<String,Integer> m7;
			HashMap<String,Integer> m6;
			ArrayList<String> m10;
			int m23;
			boolean ll;

			public TH(int m, int n, int x10, int x11, int x00, int x01, int m1,
					ArrayList<String> xyz,ArrayList<String> m4,
					HashMap<String, String> m5, HashMap<String, Integer> m7) {
				this.m = m;
				this.n = n;
				this.x10 = x10;
				this.x11 = x11;
				this.x00 = x00;
				this.x01 = x01;
				this.m1 = m1;
				this.m2 = 0;
				this.m3 = 0;
				this.xyz = xyz;
				this.xyzw = new ArrayList<String>();
				this.m4 = m4;
				this.m5 = m5;
				this.m7 = m7;
				this.m6 = new HashMap<String,Integer>();
				this.m10 = new ArrayList<String>();
				this.m23 = 0;
				this.ll = false;
			}

			public String f1(int x, int y) {
				return x+","+y;
			}
			
			public boolean f12(int x, int y) {
				return x <0 || x>m || y<0 || y>n ? false: true;
			}
			
			public ArrayList<String> f52(int x, int y) {
				ArrayList<String> result = new ArrayList<String>();
				if(f12(x-1,y))
					result.add((x-1)+","+y);
				if(f12(x+1,y))
					result.add((x+1)+","+y);
				if(f12(x,y-1))
					result.add(x+","+(y-1));
				if(f12(x,y+1))
					result.add(x+","+(y+1));
				return result;
			}

			public boolean f42(int x, int y) {
				String ln = f1(x,y);
				if(this.xyz.contains(ln) || this.xyzw.contains(ln)
						|| (this.m7.containsKey(ln) && this.m7.get(ln)>97))
					return false;
				return true;	
			}
			
			public boolean f2() { 
				if(!f42(x00-1, x01)) return false;
				if(x00 - 1 >= 0)
					x00--;
				ll2();
				return true;
			}
			
			public boolean f3() {
				if(!f42(x00+1, x01)) return false;
				if(x00 + 1 < this.m)
					x00++;
				ll2();
				return true;
					
			}
			
			public boolean applyLeft() {
				if(!f42(x00, x01-1)) return false;
				if(x01 - 1 >= 0)
					x01--;
				ll2();
				return true;

			}
			
			public boolean f4() {
				if(!f42(x00, x01+1)) return false;
				if(x01 + 1 < this.n)
					x01++;
				ll2();
				return true;
			}
			
			public boolean f100() {
				ArrayList<String> acdc = f52(x00,x01);
				if(acdc.size()>0) {
					for(String led:acdc) {
						if(xyz.contains(led)) {
							xyz.remove(led);
							this.m23++;
						}
						if(xyzw.contains(led)) {
							xyzw.remove(led);
							this.m23++;
						}
					}
					m3 +=20;
					if(m3 == 100)
						ll = true;
					
					ll2();
					return true;
				}
				return false;
				
			}
			
			public boolean f209() {
				String floyd = f1(x00,x01);
				if(m2 <= m1) {
					if(m7.containsKey(floyd)) {
						m2++;
						m6.put(floyd, m7.get(floyd));
						m7.remove(floyd);
						ll2();
						return true;
					}
				}
				
				return false;
			}
			
			public boolean f220() {
				if(x00 == x10 && x01 == x11 && m2 >0) {
					m2 = 0;
					m6.clear();
					ll2();
					return true;
				}
				return false;
			}
			
			public boolean f320() {
				String floyd = f1(x00,x01);
				if(this.m5.containsKey(floyd)) {
					String tofloyd = this.m5.get(floyd);
					String [] s = tofloyd.split(",");
					x00 = Integer.parseInt(s[0]);
					x01 = Integer.parseInt(s[1]);
					ll2();
					return true;
				}
				return false;
				
			}
			
			public boolean f32() {
				if(this.m4.contains(f1(x00,x01))) {
					m3 = (m3 -20 <0) ? 0 : m3 -20;
					for(String abc: m7.keySet()) {
						int beatles = m7.get(abc)-20 <0? 0 : m7.get(abc)-20;
						m7.put(abc,beatles);
					}
					this.m4.remove(f1(x00,x01));
					return true;
				}
				return false;
				
			}
			
			public void ll2() {
				
				HashMap<String,Integer> newm7 = new HashMap<String,Integer>();
				
				for(String abc: m6.keySet()) {
					int beatles = m6.get(abc)+2;
					if(beatles >= 100)  {
						this.edu(abc);
						m6.put(abc,100);
					}
					else 
						m6.put(abc,beatles);
				  }
				
				for(String abc: m7.keySet()) {
					int beatles = m7.get(abc)+2;
					if(beatles >= 100) {
						this.edu(abc);
						xyzw.add(abc);
					}
					else 
						newm7.put(abc,beatles);
				}
				this.m7 = newm7;
			}
			
			public void edu(String abc) {
				if(!this.m10.contains(abc))
					this.m10.add(abc);
			}
			
			public boolean grace() {	
				return !this.ll && this.m3<100 && this.m7.size() == 0 
						&& this.xyzw.size() == 0 && this.x00 == this.x10
						&& this.x01 == this.x11;
			}
	 }

			
			public static boolean applyPlan(String grid, String solution) {
				String[] solutionArray  = solution.split(";");
				String plan = solutionArray[0];
				int blue = Integer.parseInt(solutionArray[1]);
				int doors = Integer.parseInt(solutionArray[2]);
				
				plan.replace(" ", "");
				plan.replace("\n", "");
				plan.replace("\r", "");
				plan.replace("\n\r", "");
				plan.replace("\t", "");

				String[] actions = plan.split(",");
				
				String[] gridArray=  grid.split(";");
				String[] dimensions = gridArray[0].split(",");
				int m = Integer.parseInt(dimensions[0]);
				int n = Integer.parseInt(dimensions[1]);
				
				int capacity = Integer.parseInt(gridArray[1]);
				
				String[] neo = gridArray[2].split(",");
				int x00 = Integer.parseInt(neo[0]);
				int x01 = Integer.parseInt(neo[1]);
				
				String[] booth = gridArray[3].split(",");
				int x10 = Integer.parseInt(booth[0]);
				int x11 = Integer.parseInt(booth[1]);
				
				String[] ag = gridArray[4].split(",");
				ArrayList<String> xyz = new ArrayList<String>();
				for(int i = 0;i< ag.length -1; i+=2) {
					xyz.add(ag[i]+","+ag[i+1]);
				}
				
				String[] pl = gridArray[5].split(",");
				ArrayList<String> m4 = new ArrayList<String>();
				for(int i = 0;i< pl.length -1; i+=2) {
					m4.add(pl[i]+","+pl[i+1]);
				}

				String[] pas = gridArray[6].split(",");
				HashMap<String,String> m5 = new HashMap<String,String>();
				for(int i = 0;i< pas.length -3; i+=4) {
					m5.put(pas[i]+","+pas[i+1],pas[i+2]+","+pas[i+3]);
				}
				
				String[] hstg = gridArray[7].split(",");
				HashMap<String,Integer> m7 = new HashMap<String,Integer>();
				for(int i = 0;i< hstg.length -2; i+=3) {
					m7.put(hstg[i]+","+hstg[i+1],Integer.parseInt(hstg[i+2]));
				}
				
				TH s = new TH(m,n,x10,x11,x00, x01,capacity, xyz,m4,m5,m7);
				boolean linkin = true;
				
				for (int i = 0; i < actions.length; i++) {
				
					switch (actions[i]) {
					case "up":
						linkin = s.f2();
						break;
					case "down":
						linkin = s.f3();
						break;
					case "right":
						linkin = s.f4();
						break;
					case "left":
						linkin = s.applyLeft();
						break;
					case "carry":
						linkin = s.f209();
						break;
					case "drop":
						linkin = s.f220();
						break;
					case "fly":
						linkin = s.f320();
						break;
					case "takePill":
						linkin = s.f32();
						break;
					case "kill":
						linkin = s.f100();
						break;
					default: linkin = false; break;
								
					}

					if(!linkin)
						return false;		
					
						
						
				}
				System.out.println(s.m23 + " ," + doors);
				System.out.println(s.m10.size() + " ," + blue);
				return s.grace() && s.m23 == doors && s.m10.size() == blue;
			}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3189)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:494)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-11-24 19:10:51.657
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3189)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:494)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-11-24 19:10:51.657
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3189)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3347)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1524)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:494)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 2 2021-11-24 19:28:05.127
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core".
!STACK 0
org.eclipse.core.runtime.AssertionFailedException: null argument:
	at org.eclipse.core.runtime.Assert.isNotNull(Assert.java:88)
	at org.eclipse.core.runtime.Assert.isNotNull(Assert.java:76)
	at org.eclipse.jdt.ui.text.folding.DefaultJavaFoldingStructureProvider.computeCurrentStructure(DefaultJavaFoldingStructureProvider.java:1403)
	at org.eclipse.jdt.ui.text.folding.DefaultJavaFoldingStructureProvider.update(DefaultJavaFoldingStructureProvider.java:900)
	at org.eclipse.jdt.ui.text.folding.DefaultJavaFoldingStructureProvider.access$9(DefaultJavaFoldingStructureProvider.java:890)
	at org.eclipse.jdt.ui.text.folding.DefaultJavaFoldingStructureProvider$ElementChangedListener.elementChanged(DefaultJavaFoldingStructureProvider.java:368)
	at org.eclipse.jdt.internal.core.DeltaProcessor$3.run(DeltaProcessor.java:1755)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.core.DeltaProcessor.notifyListeners(DeltaProcessor.java:1743)
	at org.eclipse.jdt.internal.core.DeltaProcessor.firePostChangeDelta(DeltaProcessor.java:1576)
	at org.eclipse.jdt.internal.core.DeltaProcessor.fire(DeltaProcessor.java:1552)
	at org.eclipse.jdt.internal.core.DeltaProcessor.notifyAndFire(DeltaProcessor.java:2273)
	at org.eclipse.jdt.internal.core.DeltaProcessor.resourceChanged(DeltaProcessor.java:2163)
	at org.eclipse.jdt.internal.core.DeltaProcessingState.resourceChanged(DeltaProcessingState.java:478)
	at org.eclipse.core.internal.events.NotificationManager$1.run(NotificationManager.java:305)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.NotificationManager.notify(NotificationManager.java:295)
	at org.eclipse.core.internal.events.NotificationManager.broadcastChanges(NotificationManager.java:158)
	at org.eclipse.core.internal.resources.Workspace.broadcastPostChange(Workspace.java:381)
	at org.eclipse.core.internal.resources.Workspace.endOperation(Workspace.java:1503)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2327)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2338)
	at org.eclipse.ui.actions.WorkspaceModifyOperation.run(WorkspaceModifyOperation.java:131)
	at org.eclipse.ui.internal.editors.text.WorkspaceOperationRunner.run(WorkspaceOperationRunner.java:76)
	at org.eclipse.ui.internal.editors.text.WorkspaceOperationRunner.run(WorkspaceOperationRunner.java:66)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider.executeOperation(TextFileDocumentProvider.java:461)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider.saveDocument(TextFileDocumentProvider.java:764)
	at org.eclipse.ui.texteditor.AbstractTextEditor.performSave(AbstractTextEditor.java:5007)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.performSave(CompilationUnitEditor.java:1262)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.doSave(CompilationUnitEditor.java:1316)
	at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.doSave(AbstractTextEditor.java:7151)
	at org.eclipse.ui.Saveable.doSave(Saveable.java:213)
	at org.eclipse.ui.internal.SaveableHelper.doSaveModel(SaveableHelper.java:333)
	at org.eclipse.ui.internal.SaveableHelper.lambda$1(SaveableHelper.java:196)
	at org.eclipse.ui.internal.SaveableHelper.lambda$3(SaveableHelper.java:271)
	at org.eclipse.jface.operation.ModalContext.runInCurrentThread(ModalContext.java:436)
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:352)
	at org.eclipse.ui.internal.WorkbenchWindow.lambda$7(WorkbenchWindow.java:2345)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.ui.internal.WorkbenchWindow.run(WorkbenchWindow.java:2343)
	at org.eclipse.ui.internal.SaveableHelper.runProgressMonitorOperation(SaveableHelper.java:278)
	at org.eclipse.ui.internal.SaveableHelper.runProgressMonitorOperation(SaveableHelper.java:260)
	at org.eclipse.ui.internal.SaveableHelper.saveModels(SaveableHelper.java:207)
	at org.eclipse.ui.internal.SaveableHelper.savePart(SaveableHelper.java:150)
	at org.eclipse.ui.internal.WorkbenchPage.saveSaveable(WorkbenchPage.java:3820)
	at org.eclipse.ui.internal.WorkbenchPage.saveEditor(WorkbenchPage.java:3833)
	at org.eclipse.ui.internal.handlers.SaveHandler.execute(SaveHandler.java:82)
	at org.eclipse.ui.internal.handlers.HandlerProxy.execute(HandlerProxy.java:283)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor50.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:319)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:253)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:487)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:584)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:653)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:443)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1270)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1042)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1067)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1052)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1094)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1519)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4882)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4760)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4930)
	at org.eclipse.swt.internal.win32.OS.CallWindowProc(Native Method)
	at org.eclipse.swt.internal.BidiUtil.windowProc(BidiUtil.java:648)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3624)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:78)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:654)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1462)

!ENTRY org.eclipse.jdt.core 4 4 2021-11-24 19:28:05.129
!MESSAGE Exception occurred in listener of Java element change notification
!STACK 0
org.eclipse.core.runtime.AssertionFailedException: null argument:
	at org.eclipse.core.runtime.Assert.isNotNull(Assert.java:88)
	at org.eclipse.core.runtime.Assert.isNotNull(Assert.java:76)
	at org.eclipse.jdt.ui.text.folding.DefaultJavaFoldingStructureProvider.computeCurrentStructure(DefaultJavaFoldingStructureProvider.java:1403)
	at org.eclipse.jdt.ui.text.folding.DefaultJavaFoldingStructureProvider.update(DefaultJavaFoldingStructureProvider.java:900)
	at org.eclipse.jdt.ui.text.folding.DefaultJavaFoldingStructureProvider.access$9(DefaultJavaFoldingStructureProvider.java:890)
	at org.eclipse.jdt.ui.text.folding.DefaultJavaFoldingStructureProvider$ElementChangedListener.elementChanged(DefaultJavaFoldingStructureProvider.java:368)
	at org.eclipse.jdt.internal.core.DeltaProcessor$3.run(DeltaProcessor.java:1755)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.core.DeltaProcessor.notifyListeners(DeltaProcessor.java:1743)
	at org.eclipse.jdt.internal.core.DeltaProcessor.firePostChangeDelta(DeltaProcessor.java:1576)
	at org.eclipse.jdt.internal.core.DeltaProcessor.fire(DeltaProcessor.java:1552)
	at org.eclipse.jdt.internal.core.DeltaProcessor.notifyAndFire(DeltaProcessor.java:2273)
	at org.eclipse.jdt.internal.core.DeltaProcessor.resourceChanged(DeltaProcessor.java:2163)
	at org.eclipse.jdt.internal.core.DeltaProcessingState.resourceChanged(DeltaProcessingState.java:478)
	at org.eclipse.core.internal.events.NotificationManager$1.run(NotificationManager.java:305)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.NotificationManager.notify(NotificationManager.java:295)
	at org.eclipse.core.internal.events.NotificationManager.broadcastChanges(NotificationManager.java:158)
	at org.eclipse.core.internal.resources.Workspace.broadcastPostChange(Workspace.java:381)
	at org.eclipse.core.internal.resources.Workspace.endOperation(Workspace.java:1503)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2327)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2338)
	at org.eclipse.ui.actions.WorkspaceModifyOperation.run(WorkspaceModifyOperation.java:131)
	at org.eclipse.ui.internal.editors.text.WorkspaceOperationRunner.run(WorkspaceOperationRunner.java:76)
	at org.eclipse.ui.internal.editors.text.WorkspaceOperationRunner.run(WorkspaceOperationRunner.java:66)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider.executeOperation(TextFileDocumentProvider.java:461)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider.saveDocument(TextFileDocumentProvider.java:764)
	at org.eclipse.ui.texteditor.AbstractTextEditor.performSave(AbstractTextEditor.java:5007)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.performSave(CompilationUnitEditor.java:1262)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.doSave(CompilationUnitEditor.java:1316)
	at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.doSave(AbstractTextEditor.java:7151)
	at org.eclipse.ui.Saveable.doSave(Saveable.java:213)
	at org.eclipse.ui.internal.SaveableHelper.doSaveModel(SaveableHelper.java:333)
	at org.eclipse.ui.internal.SaveableHelper.lambda$1(SaveableHelper.java:196)
	at org.eclipse.ui.internal.SaveableHelper.lambda$3(SaveableHelper.java:271)
	at org.eclipse.jface.operation.ModalContext.runInCurrentThread(ModalContext.java:436)
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:352)
	at org.eclipse.ui.internal.WorkbenchWindow.lambda$7(WorkbenchWindow.java:2345)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.ui.internal.WorkbenchWindow.run(WorkbenchWindow.java:2343)
	at org.eclipse.ui.internal.SaveableHelper.runProgressMonitorOperation(SaveableHelper.java:278)
	at org.eclipse.ui.internal.SaveableHelper.runProgressMonitorOperation(SaveableHelper.java:260)
	at org.eclipse.ui.internal.SaveableHelper.saveModels(SaveableHelper.java:207)
	at org.eclipse.ui.internal.SaveableHelper.savePart(SaveableHelper.java:150)
	at org.eclipse.ui.internal.WorkbenchPage.saveSaveable(WorkbenchPage.java:3820)
	at org.eclipse.ui.internal.WorkbenchPage.saveEditor(WorkbenchPage.java:3833)
	at org.eclipse.ui.internal.handlers.SaveHandler.execute(SaveHandler.java:82)
	at org.eclipse.ui.internal.handlers.HandlerProxy.execute(HandlerProxy.java:283)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor50.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:319)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:253)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:487)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:584)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:653)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:443)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1270)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1042)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1067)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1052)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1094)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1519)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4882)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4760)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4930)
	at org.eclipse.swt.internal.win32.OS.CallWindowProc(Native Method)
	at org.eclipse.swt.internal.BidiUtil.windowProc(BidiUtil.java:648)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3624)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:78)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:654)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1462)
