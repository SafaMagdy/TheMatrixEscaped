package code;
import java.util.ArrayList;

import code.Location;

public class TreeNode {
	
	//list for tracking the previous nodes visited to avoid repeated states
	public ArrayList<TreeNode> prevNodes;
	//current node location
	public Location myLoc;
	//track of neo's damage
	public int neoDamage;
	//the updated string according to the path that led to the current node
	public String grid;
	//keeps track of kills and deaths till now
	public int kills;
	public int deaths;
	//array containing hostages and their locations
	//this array is created in each node using the given grid
	public ArrayList<String> hostages;
	//array containing mutant hostages and their locations
	//this array is created in each node using the given grid
	public ArrayList<String> mutantHostages;
	
	
	
	public TreeNode(ArrayList<TreeNode> prevNodes, Location myLoc, int neoD, String grid, int kills, int deaths) {
		
		this.prevNodes = prevNodes;
		this.myLoc = myLoc;
		this.neoDamage = neoD;
		this.grid = grid;
		this.kills = kills;
		this.deaths = deaths;
		this.hostages = getHostages(grid);
		this.mutantHostages = getMutantHostages(grid);
	}
	
	
	//method to print the content of any array
	public static void printArr (String[] arr)
	{
		for ( int i = 0 ; i < arr.length; i++) {
			System.out.print(arr[i]);
		}
		System.out.println(" ");
	}
	
	// method to fill the hostages and damage
		public ArrayList<String> getHostages() {
			ArrayList<String> result = new ArrayList<String>();

			String[] splitted = this.grid.split(";");
			// array that contains locations of all the hostages
			String[] hostages = splitted[7].split(",");

			for (int i = 0; i < hostages.length - 1; i += 3) {
				// store the location and damage in a string
				String temp = "";
				// check the damage to know if mutant or alive
				// if mutant then skip this iteration
				if (Integer.parseInt(hostages[i + 2]) < 100) {
					temp += hostages[i] + "," + hostages[i + 1] + "," + hostages[i + 2];
					result.add(temp);
				}

			}

			return result;
		}

		// method to fill the mutant hostages
		public ArrayList<String> getMutantHostages() {
			ArrayList<String> result = new ArrayList<String>();

			String[] splitted = this.grid.split(";");
			// array that contains locations of all the hostages
			String[] hostages = splitted[7].split(",");

			for (int i = 0; i < hostages.length - 1; i += 3) {
				// store the location in a string
				String temp = "";
				// check the damage to know if mutant or alive
				// if alive then skip this iteration
				if (Integer.parseInt(hostages[i + 2]) >= 100) {
					// add only the location since we do not need the damage
					temp += hostages[i] + "," + hostages[i + 1];
					result.add(temp);
				}

			}

			return result;
		}

		// this method is responsible for only updating the grid itself
		// the action represents the different effects on the grid
		// this method returns an updated grid string
		public void updateGrid(int x, int y, String action) {
			String result = "";
			// split the grid at ; to extract different categories in the grid
			String[] splitted = this.grid.split(";");
			// since the dimensions and neo's initial position and TB position are constant,
			// append to result
			result += splitted[0] + ";" + splitted[1] + ";" + splitted[2] + ";" + splitted[3] + ";";

			// array that contains locations of all the agents
			String[] agents = splitted[4].split(",");
			// array that contains the locations of all mutant hostages
			ArrayList<String> mutantHostages = this.getMutantHostages();
			// array that contains locations of all the pills
			String[] pills = splitted[5].split(",");
			// array that contains locations of all the pads
			// this array is always divisible by 4 since the pad comes in pairs
			// (startx, starty, finishx, finishy)
			String pads = splitted[6];
			// array that contains locations of all the hostages 
			// get this array from the method getHostages to avoid getting mutant hostages from the grid string
			ArrayList<String> hostages = this.getHostages();

			// we need cases
			switch (action) {
			case ("Kill"): // Neo killed the agent/mutantHostage at x and y
							// remove this agent/mutantHostage from the grid

				for (int i = 0; i < agents.length - 1; i += 2) {
					if (x == Integer.parseInt(agents[i]) && y == Integer.parseInt(agents[i + 1])) {
						// replace the x and y with negatives so that when we combine the string again
						// we can know that this is not valid
						agents[i] = "-1";
						agents[i + 1] = "-1";
						break;
					}
				}
				for (int i = 0; i < mutantHostages.size() - 1; i += 2) {
					if (x == Integer.parseInt(mutantHostages.get(i)) && y == Integer.parseInt(mutantHostages.get(i + 1))) {
						// remove the mutant hostages from the arraylist
						mutantHostages.remove(i + 1);
						mutantHostages.remove(i);
						//also remove the hostage from the grid string
						break;
					}
				}
				this.kills++;
				break;
			case ("Pill"): // Neo took the pill at x and y
							// remove this pill from the grid

				for (int i = 0; i < pills.length - 1; i += 2) {
					if (x == Integer.parseInt(pills[i]) && y == Integer.parseInt(pills[i + 1])) {
						// replace the x and y with negatives so that when we combine the string again
						// we can know that this is not valid
						pills[i] = "-1";
						pills[i + 1] = "-1";
						break;
					}
				}
				break;
			case ("Carry"): // Neo took the hostage at x and y
							// remove this hostage from the grid

				for (int i = 0; i < hostages.size() - 1; i += 3) {
					if (x == Integer.parseInt(hostages.get(i)) && y == Integer.parseInt(hostages.get(i+1))) {
						// replace the x and y with negatives so that when we combine the string again
						// we can know that this is not valid
						hostages.remove(i+1);
						hostages.remove(i);
						break;
					}
				}
				break;
			default:
				break;
			}

			// then we need to form the new grid

			for (int i = 0; i < agents.length - 1; i += 2) {
				if (agents[i] == "-1") {
					// killed
					continue;
				} else {

					result += agents[i] + "," + agents[i + 1];
					if (i < agents.length - 3) {
						result += ",";
					}
				}
			}

			for (int i = 0; i < pills.length - 1; i += 2) {
				if (pills[i] == "-1") {
					// taken
					continue;
				} else {

					result += pills[i] + "," + pills[i + 1];
					if (i < pills.length - 3) {
						result += ",";
					}
				}
			}

			result += ";" + pads + ";";

			for (int i = 0; i < hostages.size() - 1; i += 3) {
				result += hostages.get(i) + "," + hostages.get(i+1) + "," + hostages.get(i+2);
					if (i < hostages.size() - 4) {
						result += ",";
					}
				}

			// add the mutant hostages to the hostages category in the grid
			for (int i = 0; i < mutantHostages.size() - 1; i += 2) {
				result += mutantHostages.get(i) + "," + mutantHostages.get(i + 1) + "," + "100";
				if (i < mutantHostages.size() - 3) {
					result += ",";
				}
			}

			return result;
		}

		// reminder: Safa's opinion: if Neo carried a hostage we should remove this
		// hostage from its position
		// because we will increment the c and there is no need to monitor the damage of
		// the hostage
		// because if he died then nothing will change
		// However, if we kept it in the hostages array we will need to add a condition
		// while monitoring the damage
		// that if the damage reached 100 while Neo is carrying him do not turn in
		// mutant
		// and I believe this is complex for no good
		

		// updates everything needed according to the action taken
		// I think it should return the new grid string
		public void update(String action, Location loc, String grid) {
			// we assume that Neo starts with 0 damage

			// update damage of all hostages
			ArrayList<String> hostages = getHostages(grid);
			ArrayList<String> mutantHostages = getMutantHostages(grid);

			for (int i = 0; i < hostages.size(); i++) {
				// each entry in the arraylist is a string with commas splitting the x and y and
				// damage
				String[] splitted = hostages.get(i).split(",");
				// the third element is the damage
				splitted[2] += 2;
				// check if it reached 100
				if (Integer.parseInt(splitted[2]) >= 100) {
					// remove this hostage from the hostages array and add it to mutant
					mutantHostages.add(hostages.get(i));
					hostages.remove(i);
					this.deaths++;
					// update the grid by adding the new hostage damage
					// this update will be reflected when we call updateGrid method above 
					// as it takes the input of hostages and mutant hostages from the grid in this method
					// as we do not add a different category in the grid string to represent the mutant hostages
					// we rely on having the damage of 100 or greater to reflect this change
				}
			}

			// check the action performed and accordingly update the grid or damage
			switch (action) {
			case ("Move"): // nothing changes in the grid only the overall hostage damage increases by 2
							//which is handled in the updateGrid method
				//Move is not defined in the cases in updateGrid so it will only handle the damage
				updateGrid(loc.x, loc.y, grid, "Move");
				break;
			case ("Kill"):
				// update grid by removing the killed agent or mutant hostage(method above)
				// increment Neo's damage by 20
				// increment the number of killings by 1 if it is an agent
				this.neoDamage += 20;
			
				break;
			case ("Pill"):
				// update grid method above
				// Decrement the damages of hostages and Neo by 20
				break;
			case ("Carry"):
				// update grid method above
				// increment c by 1
				break;
			case ("Drop"):
				// Decrement c by 1
				break;
			default:
				break;
			}

		}

	

	

	
	public static void main(String[] args) {
		
		//System.out.println(whatInCell(2,1, "3,3;1;0,0;1,1;0,1;1,2;0,2,2,0;1,0,0,2,1,50,2,2,90"));
	}
	
	

}
