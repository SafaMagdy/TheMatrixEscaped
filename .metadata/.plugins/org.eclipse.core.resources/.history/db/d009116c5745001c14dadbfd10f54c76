package code;

import java.util.Random;
import code.Location;
import code.TreeNode;
import code.Queue.*;

import java.util.ArrayList;

public class Matrix {

	// create a class for action methods?
	// use array list instead of queue

	/*
	public static String genGrid() {
		String grid = "";
		ArrayList<Location> busyLocations = new ArrayList<Location>();

		Random rand = new Random();
		int m = rand.nextInt((15 - 5) + 1) + 5;
		int n = rand.nextInt((15 - 5) + 1) + 5;
		System.out.println(m);
		System.out.println(n);
		// calculate the total number of cells as a check for later
		int totalCells = m * n;
		int c = rand.nextInt((4 - 1) + 1) + 1;
		int neoX = rand.nextInt((n - 5) + 1) + 5;
		int neoY = rand.nextInt((m - 5) + 1) + 5;
		Location neo = new Location(neoX, neoY);
		busyLocations.add(neo);
		grid = m + "," + n + ";" + c + ";" + neoX + "," + neoY + ";";
		int teleX = -1;
		int teleY = -1;
		// random variables till false
		teleX = rand.nextInt((n - 5) + 1) + 5;
		teleY = rand.nextInt((m - 5) + 1) + 5;
		Location tele = new Location(teleX, teleY);
		while (isBusy(busyLocations, tele)) {
			teleX = rand.nextInt((n - 5) + 1) + 5;
			//System.out.println(teleX);
			teleY = rand.nextInt((m - 5) + 1) + 5;
			tele.x = teleX;
			tele.y = teleY;
			//tele = new Location(teleX, teleY);
		}
		System.out.println("out of loop 1");
		// if it comes out of the loop then it is not busy
		busyLocations.add(tele);
		grid += teleX + "," + teleY + ";";

		int hostagesNum = 0;
		// check to avoid overflow of hostages
		// generate number of hostages first since there is a restriction on it
		hostagesNum = rand.nextInt((10 - 3) + 1) + 3;
		
		while (hostagesNum > (totalCells - busyLocations.size())) {
			// try again
			hostagesNum = rand.nextInt((10 - 3) + 1) + 3;
		}
		System.out.println("hostages: " + hostagesNum);
		// the number of hostages is suitable
		// assign them to cells and add them to the grid string
		// since agents come first create a new string and append it to the grid string
		String hostages = "";
		for (int i = 0; i < hostagesNum; i++) {
			int hosX = rand.nextInt((n - 5) + 1) + 5;
			int hosY = rand.nextInt((m - 5) + 1) + 5;
			int damage = rand.nextInt((99 - 1) + 1) + 1;
			Location hos = new Location(hosX, hosY);
			// check if this location is valid
			while (isBusy(busyLocations, hos)) {
				// try again
				hosX = rand.nextInt((n - 5) + 1) + 5;
				hosY = rand.nextInt((m - 5) + 1) + 5;
				damage = rand.nextInt((99 - 1) + 1) + 1;
				//hos = new Location(hosX, hosY);
				hos.x = hosX;
				hos.y = hosY;
				System.out.println("maznoo2: " + hos.x + "   " + hos.y);
			}
			busyLocations.add(hos);
			System.out.println("out of loop 2: " + i);
			// append to string
			hostages += hosX + "," + hosY + "," + damage;
			// to add the comma after each hostage

			if (i < hostagesNum - 1) {
				hostages += ",";
			}

		}
		hostages += ";";

		// check if full
		if (busyLocations.size() < totalCells) {
			// generate agents
			int agentsNum = 0;
			// to avoid overflow of agents put the max as the number of available cells
			agentsNum = rand.nextInt((totalCells - busyLocations.size()) + 1);
			System.out.println("agents: " + agentsNum);
			// assign them to cells and add them to the grid string
			for (int i = 0; i < agentsNum; i++) {
				int ageX = rand.nextInt((n - 5) + 1) + 5;
				int ageY = rand.nextInt((m - 5) + 1) + 5;
				Location agent = new Location(ageX, ageY);
				// check if this location is valid
				// System.out.println(busyLocations.size());
				// System.out.println(totalCells);
				while (isBusy(busyLocations, agent)) {
					// try again
					ageX = rand.nextInt((n - 5) + 1) + 5;
					ageY = rand.nextInt((m - 5) + 1) + 5;
					//agent = new Location(ageX, ageY);
					agent.x = ageX;
					agent.y = ageY;
					System.out.println("e7tmal at7shr " + ageX + "   " + ageY);

				}
				busyLocations.add(agent);
				System.out.println("out of loop 3: " + i);
				// append to string
				grid += ageX + "," + ageY;
				// to add the comma after each agent
				if (i < agentsNum - 1) {
					grid += ",";
				}
			}
			System.out.println("out of loop 4");
			
			grid += ';';
		}
		// check if full
		//System.out.println(isBusy(busyLocations, tele));
		if (busyLocations.size() < totalCells) {
			// generate the pills
			int pillsNum = 0;
			// check to avoid overflow of pills
			// the max number of pills is the number of hostages
			pillsNum = rand.nextInt(hostagesNum + 1);
			while (pillsNum > (totalCells - busyLocations.size())) {
				// try again
				pillsNum = rand.nextInt(hostagesNum + 1);
			}
			System.out.println("pills: " + pillsNum);
			// assign them to cells and add them to the grid string
			for (int i = 0; i < pillsNum; i++) {
				int pillX = rand.nextInt((n - 5) + 1) + 5;
				int pillY = rand.nextInt((m - 5) + 1) + 5;
				Location pill = new Location(pillX, pillY);
				// check if this location is valid
				while (isBusy(busyLocations, pill)) {
					// try again
					pillX = rand.nextInt((n - 5) + 1) + 5;
					pillY = rand.nextInt((m - 5) + 1) + 5;
					//pill = new Location(pillX, pillY);
					pill.x = pillX;
					pill.y = pillY;
					System.out.println("e7tmal at7shr2");

				}
				busyLocations.add(pill);
				System.out.println("out of loop 5");
				// append to string
				grid += pillX + "," + pillY;
				// to add the comma after each pill
				if (i < pillsNum - 1) {
					grid += ",";
				}
				System.out.println("out of loop 6: " + i);
			}
			

			grid += ";";
		}

		// check if full
		// subtract 1 because the pads come in pairs
		if (busyLocations.size() < totalCells - 1) {
			// generate the pads
			int padsNum = 0;
			// check to avoid overflow of pills
			padsNum = rand.nextInt((totalCells - busyLocations.size()) + 1);
			// check if the number is divisible by 2
			while (padsNum > (totalCells - busyLocations.size()) || padsNum % 2 != 0) {
				// try again
				rand.nextInt((totalCells - busyLocations.size()) + 1);
				
			}
			System.out.println("pads: " + padsNum);
			// assign them to cells and add them to the grid string
			for (int i = 0; i < padsNum; i++) {
				int padX = rand.nextInt((n - 5) + 1) + 5;
				int padY = rand.nextInt((m - 5) + 1) + 5;
				Location pad = new Location(padX, padY);
				// check if this location is valid
				while (isBusy(busyLocations, pad)) {
					// try again
					padX = rand.nextInt((n - 5) + 1) + 5;
					padY = rand.nextInt((m - 5) + 1) + 5;
					pad.x = padX;
					pad.y = padY;
					//pad = new Location(padX, padY);
					System.out.println("e7tmal at7shr3");

				}
				busyLocations.add(pad);
				System.out.println("out of loop 7: " + i);
				// append to string
				grid += padX + "," + padY;
				// to add the comma after each pad
				if (i < padsNum - 1) {
					grid += ",";
				}
			}

			grid += ";";
			System.out.println("out of loop 8");
		}
		
		System.out.println("e7tmal at7shr4");
		grid += hostages;

		System.out.println(grid);
		return grid;
	}
	*/
	
	public static String genGrid() {
		String grid = "";
		// should be randomized
		int m = 3;
		int n = 3;
		int c = 1;
		int neoX = 0;
		int neoY = 0;
		grid = m + "," + n + ";" + c + ";" + neoX + "," + neoY + ";";
		int teleX = 1;
		int teleY = 1;
		grid += teleX + "," + teleY;
		int agentNumber = 1;
		for (int i = 0; i < agentNumber; i++) {
			int agentX = 0;
			int agentY = 1;
			grid += ";" + agentX + "," + agentY;
		}
		int pillNumber = 1;
		for (int i = 0; i < pillNumber; i++) {
			int pillX = 1;
			int pillY = 2;
			grid += ";" + pillX + "," + pillY;
		}
		int padNumber = 1;
		for (int i = 0; i < padNumber; i++) {
			int spadX = 0;
			int spadY = 2;
			int fpadX = 2;
			int fpadY = 0;
			grid += ";" + spadX + "," + spadY + "," + fpadX + "," + fpadY;
		}
		int hosNumber = 3;
		for (int i = 0; i < 1; i++) {
			int hosX = 1;
			int hosY = 0;
			int hosDamage = 0;
			grid += ";" + hosX + "," + hosY + "," + hosDamage;
		}
		for (int i = 0; i < 1; i++) {
			int hosX = 2;
			int hosY = 1;
			int hosDamage = 50;
			grid += "," + hosX + "," + hosY + "," + hosDamage;
			;
		}
		for (int i = 0; i < 1; i++) {
			int hosX = 2;
			int hosY = 2;
			int hosDamage = 90;
			grid += "," + hosX + "," + hosY + "," + hosDamage;
			;
		}
		return grid;
	}


	// this method check whether or not the cell is empty in order to avoid overlap
	// in cells
	public static boolean isBusy(ArrayList<Location> busyLocations, Location loc) {
		boolean busy = false;
		if (busyLocations.contains(loc)) {
			busy = true;
		}
		//System.out.println(busy);
		/*
		 * for (int i = 0; i < busyLocations.size(); i++) { if (busyLocations.get(i).x
		 * == loc.x && busyLocations.get(i).y == loc.y) { busy = true; break; } }
		 */
		return busy;

	}
	
	// method to fill the hostages and damage
	public static ArrayList<String> getHostages(String grid) {
		ArrayList<String> result = new ArrayList<String>();
		String[] splitted = grid.split(";");
		// array that contains locations of all the hostages
		String[] hostages = splitted[7].split(",");

		for (int i = 0; i < hostages.length - 1; i += 3) {
			// store the location and damage in a string
			String temp = "";
			// check the damage to know if mutant or alive
			// if mutant then skip this iteration
			if (Integer.parseInt(hostages[i + 2]) < 100) {
				temp += hostages[i] + "," + hostages[i + 1] + "," + hostages[i + 2];
				result.add(temp);
			}

		}

		return result;
	}
	
	// method to fill the mutant hostages
		public static ArrayList<String> getMutantHostages(String grid) {
			ArrayList<String> result = new ArrayList<String>();

			String[] splitted = grid.split(";");
			// array that contains locations of all the hostages
			String[] hostages = splitted[7].split(",");

			for (int i = 0; i < hostages.length - 1; i += 3) {
				// store the location in a string
				String temp = "";
				// check the damage to know if mutant or alive
				// if alive then skip this iteration
				if (Integer.parseInt(hostages[i + 2]) >= 100) {
					// add only the location since we do not need the damage
					temp += hostages[i] + "," + hostages[i + 1];
					result.add(temp);
				}

			}

			return result;
		}
		
		// method to get the content of the given cell and useful information about
		// content of cell
		// can be used to determine the surroundings of the current cell
		public static String whatInCell(int x, int y, String grid) {
			String result = "";
			// split the grid at ; to extract different categories in the grid
			String[] splitted = grid.split(";");
			// array that consists of (x,y) of the telephone booth
			String[] telephone = splitted[3].split(",");
			// array that contains locations of all the agents
			String[] agents = splitted[4].split(",");
			// array that contains locations of all pills
			String[] pills = splitted[5].split(",");
			// array that contains locations of all the pads
			// this array is always divisible by 4 since the pad comes in pairs
			// (startx, starty, finishx, finishy)
			String[] pads = splitted[6].split(",");
			// array that contains locations of all the hostages
			String[] hostages = splitted[7].split(",");

			if (x == Integer.parseInt(telephone[0]) && y == Integer.parseInt(telephone[1])) {
				result = "telephone;" + x + ";" + y;
				return result;
			}
			for (int i = 0; i < agents.length - 1; i += 2) {
				if (x == Integer.parseInt(agents[i]) && y == Integer.parseInt(agents[i + 1])) {
					result = "agent;" + x + ";" + y;
					return result;
				}
			}
			for (int i = 0; i < pills.length - 1; i += 2) {
				if (x == Integer.parseInt(pills[i]) && y == Integer.parseInt(pills[i + 1])) {
					result = "pill;" + x + ";" + y;
					return result;
				}
			}
			for (int i = 0; i < pads.length - 1; i += 2) {
				if (x == Integer.parseInt(pads[i]) && y == Integer.parseInt(pads[i + 1])) {
					result = "pad;" + x + ";" + y;
					if ((i / 2) % 2 == 0) {
						result += ";" + pads[i + 2] + ";" + pads[i + 3];
					} else {
						result += ";" + pads[i - 2] + ";" + pads[i - 1];
					}
					// return pair of pads attached together
					return result;
				}
			}
			for (int i = 0; i < hostages.length - 1; i += 3) {
				if (x == Integer.parseInt(hostages[i]) && y == Integer.parseInt(hostages[i + 1])) {
					result = "hostage;" + x + ";" + y + ";" + hostages[i + 2];
					return result;
				}
			}

			return result;
		}
		
		// method to detect where can I move
		public static ArrayList<String> whereCanIMove(Location current, String grid) {
			ArrayList<String> result = new ArrayList<String>();
			// check all possible directions
			String[] splitted = grid.split(";");
			String[] dimensions = splitted[0].split(",");
			int cols = Integer.parseInt(dimensions[0]);
			int rows = Integer.parseInt(dimensions[1]);
			boolean up = false;
			boolean right = false;
			boolean down = false;
			boolean left = false;
			// check if I can go up
			if (current.y > 0) {
				// check if there is an agent or a mutant agent
				String upCellComponent = whatInCell(current.x, current.y - 1, grid);
				if (!(upCellComponent.contains("agent"))) {
					// check if there is a mutant hostage
					if (upCellComponent.contains("hostage")) {
						// check the damage to know if it is mutant
						String[] hos = upCellComponent.split(";");
						if (Integer.parseInt(hos[3]) < 100) {
							up = true;
						}else {
							result.add("KillUp");
						}
					}
					up = true;
				}else {
					result.add("KillUp");
				}
			}
			// check if I can go right
			if (current.x < cols - 1) {
				// check if there is an agent or a mutant agent
				String rightCellComponent = whatInCell(current.x + 1, current.y, grid);
				if (!(rightCellComponent.contains("agent"))) {
					// check if there is a mutant hostage
					if (rightCellComponent.contains("hostage")) {
						//System.out.println(rightCellComponent);
						// check the damage to know if it is mutant
						String[] hos = rightCellComponent.split(";");
						if (Integer.parseInt(hos[3]) < 100) {
							right = true;
						}else {
							result.add("KillRight");
						}
					}
					right = true;
				}else {
					result.add("KillRight");
				}
			}
			// check if I can go down
			if (current.y < rows - 1) {
				// check if there is an agent or a mutant agent
				String downCellComponent = whatInCell(current.x, current.y + 1, grid);
				if (!(downCellComponent.contains("agent"))) {
					// check if there is a mutant hostage
					if (downCellComponent.contains("hostage")) {
						// check the damage to know if it is mutant
						String[] hos = downCellComponent.split(";");
						if (Integer.parseInt(hos[3]) < 100) {
							down = true;
						}else {
							result.add("KillDown");
						}
					}
					down = true;
				}else {
					result.add("KillDown");
				}
			}
			// check if I can go left
			if (current.x > 0) {
				// check if there is an agent or a mutant agent
				String leftCellComponent = whatInCell(current.x - 1, current.y, grid);
				if (!(leftCellComponent.contains("agent"))) {
					// check if there is a mutant hostage
					if (leftCellComponent.contains("hostage")) {
						// check the damage to know if it is mutant
						String[] hos = leftCellComponent.split(";");
						if (Integer.parseInt(hos[3]) < 100) {
							left = true;
						}else {
							result.add("KillLeft");
						}
					}
					left = true;
				}
			}
			if (up) {
				result.add("Up");
			}
			if (right) {
				result.add("Right");
			}
			if (down) {
				result.add("Down");
			}
			if (left) {
				result.add("Left");
			}
				
			return result;
		}

		// method to detect possible actions and insert in queue
		// this method returns array of strings of the following format
		// "ActionName", "affectedLocation"
		public static ArrayList<String> getPossibleActions(Location current, String grid) {
			ArrayList<String> result = new ArrayList<String>();
			// check the current cell components
			String currentCellComponent = whatInCell(current.x, current.y, grid);
			if (currentCellComponent.contains("pill")) {
				// either take it or leave it
				result.add("Pill," + current.x + "," + current.y);
			}
			if (currentCellComponent.contains("hostage")) {
				// cannot be a mutant hostage because we do not add this option to happen during movement
				result.add("Carry," + current.x + "," + current.y);
			}
			if (currentCellComponent.contains("pad")) {
				// get the go-to pad from the string
				String[] pillData = currentCellComponent.split(";");
				//we know that the current cell is the first pad in the string so ignore it
				int fx = Integer.parseInt(pillData[3]);
				int fy = Integer.parseInt(pillData[4]);
				result.add("Fly," + fx + "," + fy);
			}
			if (currentCellComponent.contains("telephone")) {
				// you can either drop or leave
				//check before drop if there is a hostage to drop
				result.add("Drop," + current.x + "," + current.y);
			}
			
			//get the possible movements
			ArrayList<String> movements = whereCanIMove(current, grid);
			if (!(movements.isEmpty())) {
				for (int i = 0; i < movements.size(); i++) {
					if (movements.get(i) == "Up") {
						result.add("Move," + current.x + "," + (current.y-1));
					}else if (movements.get(i) == "Right") {
						result.add("Move," + (current.x+1) + "," + (current.y));
					}else if (movements.get(i) == "Down") {
						result.add("Move," + current.x + "," + (current.y+1));
					}else if (movements.get(i) == "Left") {
						result.add("Move," + (current.x-1) + "," + current.y);
					}
					
				}
			}
			return result;

		}
	
	public static String solve(String grid, String strategy, boolean visualize) {
		String result = "";
		//initialize empty array of previous nodes
		ArrayList<TreeNode> prevNodes = new ArrayList<TreeNode>();
		//get Neo's location
		String[] splitted = grid.split(";");
		String[] preNeo = splitted[2].split(",");
		Location neo = new Location(Integer.parseInt(preNeo[0]), Integer.parseInt(preNeo[1]));
		//create initial starting node
		TreeNode start = new TreeNode(null, prevNodes, neo, 0, grid, 0, 0, getHostages(grid), 
				getMutantHostages(grid), "Start", 0, 0);
		
		ArrayList<String> possibleActions = getPossibleActions(neo, grid);
		printArr(possibleActions);
		
		Queue queue = new DFQueue();
		
		return result;
	}
	
	//method to print the content of any array
		public static void printArr (ArrayList<String> arr)
		{
			for ( int i = 0 ; i < arr.size(); i++) {
				System.out.print(arr.get(i));
			}
			System.out.println(" ");
		}

	public static void main(String[] args) {

		String grid = genGrid();
		System.out.println(grid);
		solve(grid, "df", false);
	}

	// gen grid
	// solve
	// update

}
